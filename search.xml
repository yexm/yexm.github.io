<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>example</title>
      <link href="2021/05/16/example/"/>
      <url>2021/05/16/example/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>使用go/analysis自己实现linter</title>
      <link href="2021/05/11/798f7e7017cd550dfc61b041d5250ac9/"/>
      <url>2021/05/11/798f7e7017cd550dfc61b041d5250ac9/</url>
      
        <content type="html"><![CDATA[<p><a href="https://cloud.tencent.com/developer/article/1561604">https://cloud.tencent.com/developer/article/1561604</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>go底层利器之ast以及它的妙用</title>
      <link href="2021/05/10/eec19ee821d35d2e8d8cbfa6c0831b9a/"/>
      <url>2021/05/10/eec19ee821d35d2e8d8cbfa6c0831b9a/</url>
      
        <content type="html"><![CDATA[<p><img src="/2021/05/10/eec19ee821d35d2e8d8cbfa6c0831b9a/1620568601747.png"></p><h2><span id="抽象语法树">抽象语法树</span></h2><p>AST是抽象语法树（Abstract Syntax Tree）的简称，是源代码语法的结构的一种抽象表示，它用树状的方式表示编程语言的语法结构。抽象语法树中的每一个节点都表示源代码中的一个元素，每一棵子树都表示一个语法元素。之所以说语法是“抽象”的，是因为这里的语法并不会表示出真实语法中出现的每个细节。</p><h3><span id="token">Token</span></h3><p>Token是编程语言中最小的具有独立含义的词法单元。Token不仅仅包含关键字，还包含用户自定义的标识符、运算符、分隔符和注释等。每个Token对应的词法单元有三个属性是比较重要的：首先是Token本身的值表示词法单元的类型，其次是Token在源代码中源代码文本形式，最后是Token出现的位置。在所有的Token中，注释和分号是两种比较特殊的Token：普通的注释一般不影响程序的语义，因此很多时候可以忽略注释；而Go语言中经常在行尾自动添加分号Token，而分号是分隔语句的词法单元，因此自动添加分号导致了Go语言左花括弧不能单独一行等细微的语法差异。本章学习如何对源代码进行Token分析。</p><h4><span id="token语法">Token语法</span></h4><p>Go语言所有的Token被分为四类：特殊类型的Token、基础面值对应的Token、运算符Token和关键字。其中标识符的语法定义如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">identifier = letter { letter | unicode_digit } .</span><br><span class="line">letter     = unicode_letter | "_" .</span><br></pre></td></tr></tbody></table></figure><p><img src="/2021/05/10/eec19ee821d35d2e8d8cbfa6c0831b9a/1620729276593.png"></p><p>其中identifier表示标识符，由字母和数字组成，开头第一个字符必须是字母。需要注意的是下划线也是作为字母，因此可以用下划线作为标识符。不过美元符号$并不属于字母，因此标识符中不能包含美元符号。</p><p>在标识符中有一类特殊的标识符被定义为关键字。关键字用于引导特殊的语法结构，不能将关键字作为独立的标识符（）。下面是Go语言定义的25个关键字：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">break        default      func         interface    select</span><br><span class="line">case         defer        go           map          struct</span><br><span class="line">chan         else         goto         package      switch</span><br><span class="line">const        fallthrough  if           range        type</span><br><span class="line">continue     for          import       return       var</span><br></pre></td></tr></tbody></table></figure><h3><span id="astnode">ast.Node</span></h3><p>首先，简单介绍一下ast.Node。<br>go中将所有的token抽象成为ast.Node，每个token需要实现如下接口：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type Node interface {</span><br><span class="line">Pos() token.Pos // position of first character belonging to the node</span><br><span class="line">End() token.Pos // position of first character immediately after the node</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>整个AST语法树由不同的节点组成，节点可分为三种，均会实现上面的ast.Node接口。</p><ul><li>ast.Expr - 代表表达式和类型的节点</li><li>ast.Stmt - 代表语句节点</li><li>ast.Decl - 代表声明节点</li></ul><p>定义如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// All expression nodes implement the Expr interface.</span><br><span class="line">type Expr interface {</span><br><span class="line">Node</span><br><span class="line">exprNode()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// All statement nodes implement the Stmt interface.</span><br><span class="line">type Stmt interface {</span><br><span class="line">Node</span><br><span class="line">stmtNode()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// All declaration nodes implement the Decl interface.</span><br><span class="line">type Decl interface {</span><br><span class="line">Node</span><br><span class="line">declNode()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>其中exprNode，stmtNode，declNode 三个方法除了用于区分类型，并没有其他意义。</p><p>这三个下面又有很多的节点，关系如下图：</p><p><img src="/2021/05/10/eec19ee821d35d2e8d8cbfa6c0831b9a/1620571558950.png"></p><p>来看整个内容详情:</p><p>1.普通Node,不是特定语法结构,属于某个语法结构的一部分.</p><ul><li>Comment 表示一行注释 // 或者 / /</li><li>CommentGroup 表示多行注释</li><li>Field 表示结构体中的一个定义或者变量,或者函数签名当中的参数或者返回值</li><li>FieldList 表示以”{}”或者”()”包围的Filed列表</li></ul><p>2.Expression &amp; Types (都划分成Expr接口)</p><ul><li>BadExpr 用来表示错误表达式的占位符</li><li>Ident 比如报名,函数名,变量名</li><li>Ellipsis 省略号表达式,比如参数列表的最后一个可以写成arg…</li><li>BasicLit 基本字面值,数字或者字符串</li><li>FuncLit 函数定义</li><li>CompositeLit 构造类型,比如{1,2,3,4}</li><li>ParenExpr 括号表达式,被括号包裹的表达式</li><li>SelectorExpr 选择结构,类似于a.b的结构</li><li>IndexExpr 下标结构,类似这样的结构 expr[expr]</li><li>SliceExpr 切片表达式,类似这样 expr[low:mid:high]</li><li>TypeAssertExpr 类型断言类似于 X.(type)</li><li>CallExpr 调用类型,类似于 expr()</li><li>StarExpr 表达式,类似于 X</li><li>UnaryExpr 一元表达式</li><li>BinaryExpr 二元表达式</li><li>KeyValueExp 键值表达式 key:value</li><li>ArrayType 数组类型</li><li>StructType 结构体类型</li><li>FuncType 函数类型</li><li>InterfaceType 接口类型</li><li>MapType map类型</li><li>ChanType 管道类型</li></ul><p>3.Statements</p><ul><li>BadStmt 错误的语句</li><li>DeclStmt 在语句列表里的申明</li><li>EmptyStmt 空语句</li><li>LabeledStmt 标签语句类似于 indent:stmt</li><li>ExprStmt 包含单独的表达式语句</li><li>SendStmt chan发送语句</li><li>IncDecStmt 自增或者自减语句</li><li>AssignStmt 赋值语句</li><li>GoStmt Go语句</li><li>DeferStmt 延迟语句</li><li>ReturnStmt return 语句</li><li>BranchStmt 分支语句 例如break continue</li><li>BlockStmt 块语句 {} 包裹</li><li>IfStmt If 语句</li><li>CaseClause case 语句</li><li>SwitchStmt switch 语句</li><li>TypeSwitchStmt 类型switch 语句 switch x:=y.(type)</li><li>CommClause 发送或者接受的case语句,类似于 case x &lt;-:</li><li>SelectStmt select 语句</li><li>ForStmt for 语句</li><li>RangeStmt range 语句</li></ul><p>4.Declarations</p><ul><li>Spec type<ul><li>Import Spec</li><li>Value Spec</li><li>Type Spec</li></ul></li><li>BadDecl 错误申明</li><li>GenDecl 一般申明(和Spec相关,比如 import “a”,var a,type a)</li><li>FuncDecl 函数申明</li></ul><p>5.Files and Packages</p><ul><li>File 代表一个源文件节点,包含了顶级元素</li><li>Package 代表一个包,包含了很多文件</li></ul><h3><span id="常见token">常见Token</span></h3><h4><span id="11基础面值">1.1基础面值</span></h4><p>面值是在程序代码中直接表示的值，其它的非零初始值只能由面值常量或常量表达式生成。比如表达式x+2*y的2就是面值，而x和y则不是面值而是标识符。Go语言规范明确定义了基础面值只有整数、浮点数、复数、符文和字符串几种类型。需要特别注意的是布尔类型的true和false并不是普通的面值，而是内置的布尔类型标识符（可能被重新定义为其它变量）。但是从Go语言用户角度看，true和false也是预定义的面值类型，因此普通的标识符也被归在面值一类（在literal_beg和literal_end之间）。</p><h4><span id="12构造面值">1.2构造面值</span></h4><p>在了解了基础面值的语法树结构之后，我们可以手工构造简单的基础面值。比如下面的代码构造一个整数9527的面值：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">"go/ast"</span><br><span class="line">"go/token"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">var lit9527 = &amp;ast.BasicLit{</span><br><span class="line">Kind:  token.INT,</span><br><span class="line">Value: "9527",</span><br><span class="line">}</span><br><span class="line">ast.Print(nil, lit9527)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4><span id="13解析基础面值">1.3解析基础面值</span></h4><p>在前面的例子中，我们通过ast.BasicLit结构直接构造了面值。通过手工的方式直接构造ast.BasicLit甚至是完整的语法树都是可以的，从理论上说可以为任何Go语言程序手工构造等价的语法树结构。但是纯手工方式构造语法树毕竟太繁琐，还好Go语言的go/parser可以帮我们解析Go语言代码并自动构造语法树。</p><p>下面的例子是通过parser.ParseExpr函数从十进制的9527生成ast.BasicLit结构：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">func main() {</span><br><span class="line">expr, _ := parser.ParseExpr(`9527`)</span><br><span class="line">ast.Print(nil, expr)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>go/parser包提供了parser.ParseExpr函数用于简化表达式的解析。返回ast.Expr类型的expr和一个错误，expr表示表达式的语法树。然后通过go/ast包提供的ast.Print函数打印语法树。</p><p>输出结果如下:</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0  *ast.BasicLit {</span><br><span class="line">1  .  ValuePos: 1</span><br><span class="line">2  .  Kind: INT</span><br><span class="line">3  .  Value: "9527"</span><br><span class="line">4  }</span><br></pre></td></tr></tbody></table></figure><h2><span id="示例">示例</span></h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">"go/ast"</span><br><span class="line">"go/parser"</span><br><span class="line">"go/token"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main(){</span><br><span class="line">src := `</span><br><span class="line">package main</span><br><span class="line">import "fmt"</span><br><span class="line">func main(){</span><br><span class="line">    fmt.Println("hello world")</span><br><span class="line">}</span><br><span class="line">    `</span><br><span class="line">//创建用于解析源文件的对象</span><br><span class="line">fileset := token.NewFileSet()</span><br><span class="line">//解析源文件，返回ast.File原始文档类型的结构体。</span><br><span class="line">f, err := parser.ParseFile(fileset, "", src, 0)</span><br><span class="line">if err != nil {</span><br><span class="line">panic(err)</span><br><span class="line">}</span><br><span class="line">//查看日志打印</span><br><span class="line">ast.Print(fileset, f)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">qimao@MacBook-Pro-3  ~/goProject/ast/demo08   master ●✚  go run main.go</span><br><span class="line">    0  *ast.File {</span><br><span class="line">    1  .  Package: 2:1</span><br><span class="line">    2  .  Name: *ast.Ident {</span><br><span class="line">    3  .  .  NamePos: 2:9</span><br><span class="line">    4  .  .  Name: "main"</span><br><span class="line">    5  .  }</span><br><span class="line">    6  .  Decls: []ast.Decl (len = 2) {</span><br><span class="line">    7  .  .  0: *ast.GenDecl {</span><br><span class="line">    8  .  .  .  TokPos: 3:1</span><br><span class="line">    9  .  .  .  Tok: import</span><br><span class="line">   10  .  .  .  Lparen: -</span><br><span class="line">   11  .  .  .  Specs: []ast.Spec (len = 1) {</span><br><span class="line">   12  .  .  .  .  0: *ast.ImportSpec {</span><br><span class="line">   13  .  .  .  .  .  Path: *ast.BasicLit {</span><br><span class="line">   14  .  .  .  .  .  .  ValuePos: 3:8</span><br><span class="line">   15  .  .  .  .  .  .  Kind: STRING</span><br><span class="line">   16  .  .  .  .  .  .  Value: "\"fmt\""</span><br><span class="line">   17  .  .  .  .  .  }</span><br><span class="line">   18  .  .  .  .  .  EndPos: -</span><br><span class="line">   19  .  .  .  .  }</span><br><span class="line">   20  .  .  .  }</span><br><span class="line">   21  .  .  .  Rparen: -</span><br><span class="line">   22  .  .  }</span><br><span class="line">   23  .  .  1: *ast.FuncDecl {</span><br><span class="line">   24  .  .  .  Name: *ast.Ident {</span><br><span class="line">   25  .  .  .  .  NamePos: 4:6</span><br><span class="line">   26  .  .  .  .  Name: "main"</span><br><span class="line">   27  .  .  .  .  Obj: *ast.Object {</span><br><span class="line">   28  .  .  .  .  .  Kind: func</span><br><span class="line">   29  .  .  .  .  .  Name: "main"</span><br><span class="line">   30  .  .  .  .  .  Decl: *(obj @ 23)</span><br><span class="line">   31  .  .  .  .  }</span><br><span class="line">   32  .  .  .  }</span><br><span class="line">   33  .  .  .  Type: *ast.FuncType {</span><br><span class="line">   34  .  .  .  .  Func: 4:1</span><br><span class="line">   35  .  .  .  .  Params: *ast.FieldList {</span><br><span class="line">   36  .  .  .  .  .  Opening: 4:10</span><br><span class="line">   37  .  .  .  .  .  Closing: 4:11</span><br><span class="line">   38  .  .  .  .  }</span><br><span class="line">   39  .  .  .  }</span><br><span class="line">   40  .  .  .  Body: *ast.BlockStmt {</span><br><span class="line">   41  .  .  .  .  Lbrace: 4:12</span><br><span class="line">   42  .  .  .  .  List: []ast.Stmt (len = 1) {</span><br><span class="line">   43  .  .  .  .  .  0: *ast.ExprStmt {</span><br><span class="line">   44  .  .  .  .  .  .  X: *ast.CallExpr {</span><br><span class="line">   45  .  .  .  .  .  .  .  Fun: *ast.SelectorExpr {</span><br><span class="line">   46  .  .  .  .  .  .  .  .  X: *ast.Ident {</span><br><span class="line">   47  .  .  .  .  .  .  .  .  .  NamePos: 5:5</span><br><span class="line">   48  .  .  .  .  .  .  .  .  .  Name: "fmt"</span><br><span class="line">   49  .  .  .  .  .  .  .  .  }</span><br><span class="line">   50  .  .  .  .  .  .  .  .  Sel: *ast.Ident {</span><br><span class="line">   51  .  .  .  .  .  .  .  .  .  NamePos: 5:9</span><br><span class="line">   52  .  .  .  .  .  .  .  .  .  Name: "Println"</span><br><span class="line">   53  .  .  .  .  .  .  .  .  }</span><br><span class="line">   54  .  .  .  .  .  .  .  }</span><br><span class="line">   55  .  .  .  .  .  .  .  Lparen: 5:16</span><br><span class="line">   56  .  .  .  .  .  .  .  Args: []ast.Expr (len = 1) {</span><br><span class="line">   57  .  .  .  .  .  .  .  .  0: *ast.BasicLit {</span><br><span class="line">   58  .  .  .  .  .  .  .  .  .  ValuePos: 5:17</span><br><span class="line">   59  .  .  .  .  .  .  .  .  .  Kind: STRING</span><br><span class="line">   60  .  .  .  .  .  .  .  .  .  Value: "\"hello world\""</span><br><span class="line">   61  .  .  .  .  .  .  .  .  }</span><br><span class="line">   62  .  .  .  .  .  .  .  }</span><br><span class="line">   63  .  .  .  .  .  .  .  Ellipsis: -</span><br><span class="line">   64  .  .  .  .  .  .  .  Rparen: 5:30</span><br><span class="line">   65  .  .  .  .  .  .  }</span><br><span class="line">   66  .  .  .  .  .  }</span><br><span class="line">   67  .  .  .  .  }</span><br><span class="line">   68  .  .  .  .  Rbrace: 6:1</span><br><span class="line">   69  .  .  .  }</span><br><span class="line">   70  .  .  }</span><br><span class="line">   71  .  }</span><br><span class="line">   72  .  Scope: *ast.Scope {</span><br><span class="line">   73  .  .  Objects: map[string]*ast.Object (len = 1) {</span><br><span class="line">   74  .  .  .  "main": *(obj @ 27)</span><br><span class="line">   75  .  .  }</span><br><span class="line">   76  .  }</span><br><span class="line">   77  .  Imports: []*ast.ImportSpec (len = 1) {</span><br><span class="line">   78  .  .  0: *(obj @ 12)</span><br><span class="line">   79  .  }</span><br><span class="line">   80  .  Unresolved: []*ast.Ident (len = 1) {</span><br><span class="line">   81  .  .  0: *(obj @ 46)</span><br><span class="line">   82  .  }</span><br><span class="line">   83  }</span><br></pre></td></tr></tbody></table></figure><p>嫌不好看，也可以用<a href="https://yuroyoro.github.io/goast-viewer/index.html">网页工具看</a></p><p>有了之前得到的函数声明啊，类型声明啊，注释之类的信息，我们可以做些啥事呢？</p><p>相信你已经想到了，我可以按照自己制定的字段命名规范去检查出所有不符合规范的变量、函数名。这便是：golint。可以直接给我们的 golang 程序生成文档！然后发现这件事情官方已经做了，这又是godoc的活</p><p>那我们能拿着做些什么呢？</p><h2><span id="应用场景">应用场景</span></h2><h3><span id="避免线上问题">避免线上问题</span></h3><ul><li>检查代码中是否有裸的go，并将裸go换成封装好的有recover的方法。<br>见代码处</li><li>检查代码是否有for死循环<br>自己有兴趣可以实现</li><li>数组预分配</li><li>代码中错误处理等</li></ul><h3><span id="structtag">structtag</span></h3><p>见代码处</p><h3><span id="规则引擎">规则引擎</span></h3><p>规则引擎应用非常广泛，在用户操作比较复杂的场景，经常被用到。例如：风控系统，Waf 系统等安全类系统，游戏引擎，数据库等通用技术框架。</p><p>规则引擎应用于较为复杂的业务场景，增强了系统的扩展性，降低系统耦合，很大程度的提高了开发人员的工作效率，满足用户多种需求，使开发者和用户都得到解放。</p><p>语法树层级较深，嵌套关系复杂，如果不能完全掌握node之间的关系和嵌套规则，我们很难自己写出正确的遍历方法。不过好在ast包已经为我们提供了遍历方法：</p><h2><span id="技巧">技巧</span></h2><p>语法树层级较深，嵌套关系复杂，如果不能完全掌握node之间的关系和嵌套规则，我们很难自己写出正确的遍历方法。不过好在ast包已经为我们提供了遍历方法：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func Walk(v Visitor, node Node)</span><br><span class="line">type Visitor interface {</span><br><span class="line">    Visit(node Node) (w Visitor)</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h2><span id="坑">坑</span></h2><p>至此我们已经完成了语法树的解析，遍历，修改以及输出。但细心的小伙伴可能已经发现：示例中的文件并没有出现一行注释。这的确是有意为之，如果我们加上注释，会发现最终生成文件的注释就像迷途的羔羊，完全找不到自己的位置。比如这样：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//修改前</span><br><span class="line">type Foo interface {</span><br><span class="line">    FooA(i int)</span><br><span class="line">    // FooB</span><br><span class="line">    FooB(j int)</span><br><span class="line">    FooC(ctx context.Context)</span><br><span class="line">}</span><br><span class="line">// 修改后</span><br><span class="line">type Foo interface {</span><br><span class="line">    FooA(ctx context.</span><br><span class="line">            // FooB</span><br><span class="line">            Context, i int)</span><br><span class="line">    FooB(ctx context.Context, j int)</span><br><span class="line">    FooC(ctx context.Context)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>导致这种现象的原因在于：ast包生成的语法树中的注释是”free-floating”的。还记得每个node都有Pos()和End()方法来标识其位置吗？对于非注释节点，语法树能够正确的调整他们的位置，但却不能自动调整注释节点的位置。如果我们想要让注释出现在正确的位置上，我们必须手动设置节点Pos和End。源码注释中提到了这个问题：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Whether and how a comment is associated with a node depends on the interpretation of the syntax tree by the manipulating program: Except for Doc and Comment comments directly associated with nodes, the remaining comments are “free-floating” (see also issues #18593, #20744).</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>issue中有具体的讨论，官方承认这是一个设计缺陷，但还是迟迟未能改进。其中有位迫不及待的小哥提供了自己的方案：<a href="github.com/dave/dst">github.com/dave/dst</a></p><p>如果实在是要对有注释的语法树进行修改，可以尝试一下。 虽然语法树的确存在修改困难问题，但其还是能满足大部分基于语法树分析的代码生成工作了(gomock,wire等等)。</p><h2><span id="总结">总结</span></h2><p>今天只是开拓一下思路，抽象语法树的用途还有很多，这里只是简单举了几个例子，后续大家可以进行相关探索。</p><p>参考文档：</p><ul><li><a href="https://cloud.tencent.com/developer/section/1142075">https://cloud.tencent.com/developer/section/1142075</a></li><li><a href="https://www.jianshu.com/p/443bd82863f8">https://www.jianshu.com/p/443bd82863f8</a></li><li><a href="https://github.com/chai2010/go-ast-book">go语法树入门</a></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>公司为什么需要建立一套统一的开发框架</title>
      <link href="2021/05/09/d1bed1805f4556560852111651ab9507/"/>
      <url>2021/05/09/d1bed1805f4556560852111651ab9507/</url>
      
        <content type="html"><![CDATA[<p><a href="https://zhuanlan.zhihu.com/p/79275000">https://zhuanlan.zhihu.com/p/79275000</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>go module</title>
      <link href="2021/05/05/75fc4301d28ff2d0570143783f522ced/"/>
      <url>2021/05/05/75fc4301d28ff2d0570143783f522ced/</url>
      
        <content type="html"><![CDATA[<p><a href="https://github.com/golang/go/wiki/Modules">https://github.com/golang/go/wiki/Modules</a><br><a href="https://tonybai.com/2019/12/21/go-modules-minimal-version-selection/">https://tonybai.com/2019/12/21/go-modules-minimal-version-selection/</a><br><a href="https://segmentfault.com/a/1190000020522261">https://segmentfault.com/a/1190000020522261</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>幂等性相关</title>
      <link href="2021/05/04/294bd8083fee173847b98936427772d9/"/>
      <url>2021/05/04/294bd8083fee173847b98936427772d9/</url>
      
        <content type="html"><![CDATA[<p>幂等的侧重点是对后端的影响,并不关心返回的数据<br><a href="https://blog.csdn.net/zhangkaixuan456/article/details/106784931">https://blog.csdn.net/zhangkaixuan456/article/details/106784931</a><br><a href="https://zhuanlan.zhihu.com/p/52116177">https://zhuanlan.zhihu.com/p/52116177</a><br><a href="https://blog.csdn.net/java_weekly/article/details/107787920">https://blog.csdn.net/java_weekly/article/details/107787920</a><br><a href="https://mp.weixin.qq.com/s/jYLBCTkksOlEASlTaO7Ydw">https://mp.weixin.qq.com/s/jYLBCTkksOlEASlTaO7Ydw</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>DDD</title>
      <link href="2021/04/27/77963b7a931377ad4ab5ad6a9cd718aa/"/>
      <url>2021/04/27/77963b7a931377ad4ab5ad6a9cd718aa/</url>
      
        <content type="html"><![CDATA[<p><a href="https://space.bilibili.com/1281381784?from=search&amp;seid=17394253344251328192">https://space.bilibili.com/1281381784?from=search&amp;seid=17394253344251328192</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>goroutine切换背后那些事儿</title>
      <link href="2021/04/24/d296b02ebf63c7c88590ea3be0952164/"/>
      <url>2021/04/24/d296b02ebf63c7c88590ea3be0952164/</url>
      
        <content type="html"><![CDATA[<p><img src="/2021/04/24/d296b02ebf63c7c88590ea3be0952164/1619237818324.png"></p><p>本文基于于GoLang 1.13。</p><h2><span id="写在前面">写在前面</span></h2><p>Goroutine很轻量，从资源消耗方面来看，它只需要一个2Kb的内存栈就可以运行；从运行时来看，它的运行成本也很低，将一个goroutine切换到另一个goroutine并不需要很多操作。</p><p>在进行讲解golang的切换之前，我们先High Level的看一下goroutine切换的相关内容。</p><h2><span id="案例">案例</span></h2><p>golang会根据两种断点将goroutine调度到线程上：</p><ul><li>当一个goroutine阻塞了。如：系统调用，mutex，或者通道。被阻塞的goroutine会进入睡眠模式/队列，让Go调度并运行一个等待的goroutine。被阻塞的goroutine进入睡眠模式/队列，允许Go调度和运行一个等待的goroutine。</li><li>在函数调用过程中，假如goroutine必须增长它的栈。这个断点允许Go调度另一个goroutine，避免正在运行的那个goroutine占用CPU。</li></ul><p>在这两种情况下，运行调度器的g0会用另一个准备运行的goroutine替换当前的goroutine。然后，被选中的goroutine取代g0，从而在线程上运行。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果您想了解更多关于g0的内容，请参考g0</span><br></pre></td></tr></tbody></table></figure><p>将一个运行中的goroutine切换到另一个运行中的goroutine涉及到两个切换。</p><ul><li>g-&gt;g0。<br><img src="/2021/04/24/d296b02ebf63c7c88590ea3be0952164/1619238027479.png"></li><li>g0-&gt; 另一个g。<br><img src="/2021/04/24/d296b02ebf63c7c88590ea3be0952164/1619238056509.png"></li></ul><p>在GoLang中，groutine真的非常轻量。为了保存，它只需要两个东西：</p><ul><li>goroutine是在哪一行停止的。即：在被调度前，goroutine是在哪一行停止的，当前要运行的指令被记录在程序计数器（PC）中。goroutine稍后将在同一点恢复。</li><li>存放goroutine的堆栈。这个堆栈的目的是为了方便再次运行时恢复其局部变量。</li></ul><p>下面我们深入看一下。</p><h2><span id="pc程序记数器">PC（程序记数器）</span></h2><p>为了便于举例，我将使用一个通过channel进行通信的goroutine来说明，这两个goroutine中，一个可以产生数据的，其它的用于消费数据。代码如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">"fmt"</span><br><span class="line">"sync"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">const COUNT = 100</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">var wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line">c := make(chan int, 10)</span><br><span class="line"></span><br><span class="line">wg.Add(1)</span><br><span class="line"></span><br><span class="line">// 生产数据</span><br><span class="line">go func() {</span><br><span class="line">for i := 0; i &lt; COUNT; i++ {</span><br><span class="line">c &lt;- i</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">close(c)</span><br><span class="line">wg.Done()</span><br><span class="line">}()</span><br><span class="line"></span><br><span class="line">// 消费数据</span><br><span class="line">for i := 0; i &lt; 3; i++ {</span><br><span class="line">wg.Add(1)</span><br><span class="line"></span><br><span class="line">go func() {</span><br><span class="line">for v := range c {</span><br><span class="line">if v%2 == 0 {</span><br><span class="line">fmt.Println(v)</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">wg.Wait()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>消费者基本上会打印0到99的偶数，我们将重点关注第一个goroutine–生产者–向缓冲区添加数字。当缓冲区满了，它将在发送消息时阻塞。此时，Go要切换到g0，调度另一个goroutine。</p><p>如前所述，Go首先需要保存当前指令，以便在同一指令处恢复goroutine。程序计数器(PC)保存在goroutine的内部结构中。</p><p>上面的代码可以使用以下图来简单说明：<br><img src="/2021/04/24/d296b02ebf63c7c88590ea3be0952164/1619238121499.png"><br>指令和它们的地址可以通过命令获取：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜  hello go tool compile -N -l main.go</span><br><span class="line">➜  hello ls | grep main.o</span><br><span class="line">main.o</span><br></pre></td></tr></tbody></table></figure><p>下面是生产者的一个示例：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  hello go tool objdump main.o</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p><img src="/2021/04/24/d296b02ebf63c7c88590ea3be0952164/1619238157779.png"></p><p>在函数runtime.chansend1上阻塞通道前，程序逐条指令执行。Go将当前的程序计数器保存到当前goroutine的内部属性中。在我们的例子中，Go保存程序计数器的地址是0x4268d0，这个地址是在runtime和方法runtime.chansend1内部的。<br><img src="/2021/04/24/d296b02ebf63c7c88590ea3be0952164/1619238174386.png"><br>然后，当g0唤醒goroutine时，它将在同一指令处恢复，对数值进行循环并推入通道。</p><p>下面我们来谈谈goroutine切换过程中的栈管理。</p><h2><span id="栈stack">栈(stack)</span></h2><p>在被阻塞之前，正在运行的goroutine有它的原始栈。这个堆栈包含临时内存，比如变量i:</p><p><img src="/2021/04/24/d296b02ebf63c7c88590ea3be0952164/1619238196686.png"><br>然后，当它在通道上阻塞时，goroutine将和它的堆栈一起切换到g0，这个goroutine将会有一个更大的栈。</p><p><img src="/2021/04/24/d296b02ebf63c7c88590ea3be0952164/1619238209264.png"><br>在切换之前，堆栈将被保存，以便在goroutine再次运行时恢复。</p><p><img src="/2021/04/24/d296b02ebf63c7c88590ea3be0952164/1619238225275.png"></p><p>我们现在已经完整地了解了goroutine切换中涉及的不同操作。现在让我们看看它是如何影响性能的。</p><p>我们应该注意到，一些架构(比如arm)需要多保存一个寄存器LR(链接寄存器)。</p><h2><span id="操作">操作</span></h2><p>为了测量goroutine切换可能需要的时间，我们将使用前面写的程序。然而，它并不能给出一个完美的性能视图，因为它可能取决于找到下一个要调度的goroutine所需的时间。这样goroutine的切换也会影响性能，从函数prolog的切换比从通道上阻塞的goroutine切换要做的操作更多。</p><p>我们来总结一下我们要测量的操作：</p><ul><li>当前的g在通道上阻塞并切换到g0:<ul><li>PC和堆栈指针一起被保存在一个内部结构中</li><li>g0被设置为正在运行的goroutine。</li><li>g0的堆栈取代了当前的堆栈。</li></ul></li><li>g0正在寻找一个新的goroutine来运行。</li><li>g0必须与所选的goroutine进行切换。<ul><li>PC和堆栈指针被从内部结构中提取出来。</li><li>程序跳转到获取的PC地址。</li></ul></li></ul><p>如下图：<br><img src="/2021/04/24/d296b02ebf63c7c88590ea3be0952164/1619238316027.png"></p><p>从g到g0或g0到g的切换是最快的阶段。它们包含少量固定的指令，这一点与调度器检查许多源以寻找下一个要运行的goroutine的情况相反。根据运行程序的情况，这个阶段甚至可能需要更多的时间。</p><p>需要说明的一点是，对于以上测试的结果会因机器架构的不同而不同</p>]]></content>
      
      
      
        <tags>
            
            <tag> go底层 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>g0</title>
      <link href="2021/04/24/8ac829e3bb8338d74cfb45ebe834d8e1/"/>
      <url>2021/04/24/8ac829e3bb8338d74cfb45ebe834d8e1/</url>
      
        <content type="html"><![CDATA[<p><img src="/2021/04/24/8ac829e3bb8338d74cfb45ebe834d8e1/1619247839044.png"></p><h2><span id="写在前面">写在前面</span></h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">本文基于golang 1.13</span><br></pre></td></tr></tbody></table></figure><p>在Go中创建的所有goroutine都在内部调度器的管理之下。Go调度器试图给所有goroutine提供运行时间，并在当前goroutine被阻塞或终止时，让所有CPU开始运行其它goroutine。它实际上是作为一个特殊的goroutine来运行的。</p><h2><span id="调度goroutine">调度goroutine</span></h2><p>Go通过GOMAXPROCS变量限制了OS线程同时运行的数量。这意味着Go必须在每个运行的线程上调度和管理goroutine。这个角色被委托给一个特殊的goroutine，称为g0，它是为每个OS线程创建的第一个goroutine。<br><img src="/2021/04/24/8ac829e3bb8338d74cfb45ebe834d8e1/1619232368154.png"><br>从上图中可以看出，它将会让那些处于ready状态的协程在相应的线程上执行。</p><p>为了更好地理解g0上调度的工作原理，我们来回顾一下channel的用法。下面这个代码是当一个goroutine在channel上被阻塞发送时的例子：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ch := make(chan int)</span><br><span class="line">...</span><br><span class="line">ch &lt;- v</span><br></pre></td></tr></tbody></table></figure><p>当在通道上阻塞时，当前的goroutine将被停放，即处于等待模式，并且不会被加载到其它任何goroutine队列中。<br><img src="/2021/04/24/8ac829e3bb8338d74cfb45ebe834d8e1/1619232384566.png"><br>g0将会替换这个goroutine，开始调度其它的goroutine。<br><img src="/2021/04/24/8ac829e3bb8338d74cfb45ebe834d8e1/1619232408658.png"><br>goroutine的本地队列是一个优先级队列，所以G2goroutine将会被调度执行。<br><img src="/2021/04/24/8ac829e3bb8338d74cfb45ebe834d8e1/1619232425968.png"><br>对于G7，如果有其它接收器能从channel中读取数据，那么G7这个goroutine将会处于unblock状态。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v := &lt;-ch</span><br></pre></td></tr></tbody></table></figure><p>当goroutine收到消息后，它又会切换到g0goroutine，同时解锁那些处于阻塞状态的goroutine并将它们放到本地队列中。<br><img src="/2021/04/24/8ac829e3bb8338d74cfb45ebe834d8e1/1619232458979.png"><br>虽然g0goroutine是管理调度，但这并不是它唯一的工作，它做得更多。</p><h2><span id="职责">职责</span></h2><p>与常规的goroutine相反，g0有一个固定的、更大的栈。这使得Go可以在那些需要更大堆栈但堆栈最不好要增长的场景下可以做更多的事情。</p><p>g0的主要职责有以下几个：</p><h3><span id="创建goroutine">创建goroutine</span></h3><p>当我们使用代码go func() {}或go myFunc()时，Go会将函数的创建委托给g0，然后再将其放在本地队列中。</p><p><img src="/2021/04/24/8ac829e3bb8338d74cfb45ebe834d8e1/1619232512959.png"><br>新创建的goroutine以优先级运行，并被置于本地队列的顶部。</p><h3><span id="推迟函数分配">推迟函数分配</span></h3><h3><span id="垃圾回收">垃圾回收</span></h3><p>如: STW（Stop the World），扫描goroutine的栈，标记清除等</p><h3><span id="栈增长">栈增长</span></h3><p>当需要时，Go会增加goroutines的大小。这个操作由prolog函数中的g0完成。<br>涉及到很多其他的操作（如：大内存分配，cgo等），这个特殊的goroutine g0使我们的程序更有效的管理需要更大的栈的操作，以保持我们的程序以更高效的低内存打印。</p>]]></content>
      
      
      
        <tags>
            
            <tag> go底层 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>有趣的ast</title>
      <link href="2021/04/24/2f73952214ae84d6d40c50d834debe22/"/>
      <url>2021/04/24/2f73952214ae84d6d40c50d834debe22/</url>
      
        <content type="html"><![CDATA[<p>相信你已经想到了，我可以按照自己制定的字段命名规范去检查出所有不符合规范的变量、函数名。但是我们发现，这件事情似乎已经有人帮我们做了。。。golint。</p><p>那么还有 Doc 和 Comment，如果我们按照规范来组织这些信息，可以直接给我们的 golang 程序生成文档！然后发现这件事情官方已经做了。。。godoc</p><p>必要性<br>1.提高效率<br>2.避免线上问题: 1.panic 2. for循环<br>3.规则引擎<br>4.structtag</p><p>今天只是开拓一下思路，抽象语法树的用途还有很多，这里只是简单了列了几点。后续大家可以进行相关探索。</p><p>1.wire<br>2.规则引擎: <a href="https://github.com/jinhailang/gre">https://github.com/jinhailang/gre</a>  java:drools<br><a href="https://github.com/skyhackvip/risk_engine">https://github.com/skyhackvip/risk_engine</a><br>3.语法翻译<br>4.k8s <a href="https://github.com/kubernetes/code-generator">https://github.com/kubernetes/code-generator</a><br>5.structtag: github.com/fatih/gomodifytags<br>6.google.golang.org/protobuf </p><p>规则引擎：</p><p>规则引擎应用非常广泛，在用户操作比较复杂的场景，经常被用到。例如：风控系统，Waf 系统等安全类系统，游戏引擎，数据库等通用技术框架。</p><p>规则引擎应用于较为复杂的业务场景，增强了系统的扩展性，降低系统耦合，很大程度的提高了开发人员的工作效率，满足用户多种需求，使开发者和用户都得到解放。</p><p>语法树层级较深，嵌套关系复杂，如果不能完全掌握node之间的关系和嵌套规则，我们很难自己写出正确的遍历方法。不过好在ast包已经为我们提供了遍历方法：</p><p>func Walk(v Visitor, node Node)<br>type Visitor interface {<br>    Visit(node Node) (w Visitor)<br>}</p><p><a href="https://cloud.tencent.com/developer/section/1142075">https://cloud.tencent.com/developer/section/1142075</a><br><a href="https://www.cnblogs.com/double12gzh/p/13632267.html">https://www.cnblogs.com/double12gzh/p/13632267.html</a><br><a href="https://zhuanlan.zhihu.com/p/28516587">https://zhuanlan.zhihu.com/p/28516587</a><br>github.com/dave/dst<br><a href="https://github.com/dave/jennifer">https://github.com/dave/jennifer</a><br><a href="https://github.com/yuroyoro/goast-viewer">https://github.com/yuroyoro/goast-viewer</a><br>修正注释bug: github.com/dave/dst</p><p>go语法树入门： <a href="https://github.com/chai2010/go-ast-book">https://github.com/chai2010/go-ast-book</a></p><p>来了一个临时需求，把项目里面所有的接口都加一个context，那么你则可以用工具生成。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">许多自动化代码生成工具都离不开语法树分析，例如goimport，gomock，wire等项目都离不开语法树分析。基于语法树分析，可以实现许多有趣实用的工具。本篇将结合示例，展示如何基于ast标准包操作语法树。</span><br></pre></td></tr></tbody></table></figure><p>来看整个内容详情:</p><p>1.普通Node,不是特定语法结构,属于某个语法结构的一部分.</p><ul><li>Comment 表示一行注释 // 或者 / /</li><li>CommentGroup 表示多行注释</li><li>Field 表示结构体中的一个定义或者变量,或者函数签名当中的参数或者返回值</li><li>FieldList 表示以”{}”或者”()”包围的Filed列表</li></ul><p>2.Expression &amp; Types (都划分成Expr接口)</p><ul><li>BadExpr 用来表示错误表达式的占位符</li><li>Ident 比如报名,函数名,变量名</li><li>Ellipsis 省略号表达式,比如参数列表的最后一个可以写成arg…</li><li>BasicLit 基本字面值,数字或者字符串</li><li>FuncLit 函数定义</li><li>CompositeLit 构造类型,比如{1,2,3,4}</li><li>ParenExpr 括号表达式,被括号包裹的表达式</li><li>SelectorExpr 选择结构,类似于a.b的结构</li><li>IndexExpr 下标结构,类似这样的结构 expr[expr]</li><li>SliceExpr 切片表达式,类似这样 expr[low:mid:high]</li><li>TypeAssertExpr 类型断言类似于 X.(type)</li><li>CallExpr 调用类型,类似于 expr()</li><li>StarExpr 表达式,类似于 X</li><li>UnaryExpr 一元表达式</li><li>BinaryExpr 二元表达式</li><li>KeyValueExp 键值表达式 key:value</li><li>ArrayType 数组类型</li><li>StructType 结构体类型</li><li>FuncType 函数类型</li><li>InterfaceType 接口类型</li><li>MapType map类型</li><li>ChanType 管道类型</li></ul><p>3.Statements</p><ul><li>BadStmt 错误的语句</li><li>DeclStmt 在语句列表里的申明</li><li>EmptyStmt 空语句</li><li>LabeledStmt 标签语句类似于 indent:stmt</li><li>ExprStmt 包含单独的表达式语句</li><li>SendStmt chan发送语句</li><li>IncDecStmt 自增或者自减语句</li><li>AssignStmt 赋值语句</li><li>GoStmt Go语句</li><li>DeferStmt 延迟语句</li><li>ReturnStmt return 语句</li><li>BranchStmt 分支语句 例如break continue</li><li>BlockStmt 块语句 {} 包裹</li><li>IfStmt If 语句</li><li>CaseClause case 语句</li><li>SwitchStmt switch 语句</li><li>TypeSwitchStmt 类型switch 语句 switch x:=y.(type)</li><li>CommClause 发送或者接受的case语句,类似于 case x &lt;-:</li><li>SelectStmt select 语句</li><li>ForStmt for 语句</li><li>RangeStmt range 语句</li></ul><p>4.Declarations</p><ul><li>Spec type<ul><li>Import Spec</li><li>Value Spec</li><li>Type Spec</li></ul></li><li>BadDecl 错误申明</li><li>GenDecl 一般申明(和Spec相关,比如 import “a”,var a,type a)</li><li>FuncDecl 函数申明</li></ul><p>5.Files and Packages</p><ul><li>File 代表一个源文件节点,包含了顶级元素.</li><li>Package 代表一个包,包含了很多文件.</li></ul><p>一些坑与不足<br>至此我们已经完成了语法树的解析，遍历，修改以及输出。但细心的小伙伴可能已经发现：示例中的文件并没有出现一行注释。这的确是有意为之，如果我们加上注释，会发现最终生成文件的注释就像迷途的羔羊，完全找不到自己的位置。比如这样：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//修改前</span><br><span class="line">type Foo interface {</span><br><span class="line">    FooA(i int)</span><br><span class="line">    // FooB</span><br><span class="line">    FooB(j int)</span><br><span class="line">    FooC(ctx context.Context)</span><br><span class="line">}</span><br><span class="line">// 修改后</span><br><span class="line">type Foo interface {</span><br><span class="line">    FooA(ctx context.</span><br><span class="line">            // FooB</span><br><span class="line">            Context, i int)</span><br><span class="line">    FooB(ctx context.Context, j int)</span><br><span class="line">    FooC(ctx context.Context)</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>导致这种现象的原因在于：ast包生成的语法树中的注释是”free-floating”的。还记得每个node都有Pos()和End()方法来标识其位置吗？对于非注释节点，语法树能够正确的调整他们的位置，但却不能自动调整注释节点的位置。如果我们想要让注释出现在正确的位置上，我们必须手动设置节点Pos和End。源码注释中提到了这个问题：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Whether and how a comment is associated with a node depends on the interpretation of the syntax tree by the manipulating program: Except for Doc and Comment comments directly associated with nodes, the remaining comments are “free-floating” (see also issues #18593, #20744).</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>issue中有具体的讨论，官方承认这是一个设计缺陷，但还是迟迟未能改进。其中有位迫不及待的小哥提供了自己的方案：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">github.com/dave/dst</span><br></pre></td></tr></tbody></table></figure><p>如果实在是要对有注释的语法树进行修改，可以尝试一下。 虽然语法树的确存在修改困难问题，但其还是能满足大部分基于语法树分析的代码生成工作了(gomock,wire等等)。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>iptables</title>
      <link href="2021/04/19/83090a9f3b90125d95e92dec20df9817/"/>
      <url>2021/04/19/83090a9f3b90125d95e92dec20df9817/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.zsythink.net/archives/1199">https://www.zsythink.net/archives/1199</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>dapr教程一</title>
      <link href="2021/04/16/9594eb3f71286e59c6ba0a1d20ae0d81/"/>
      <url>2021/04/16/9594eb3f71286e59c6ba0a1d20ae0d81/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/Zhang-Xiang/p/13936442.html">https://www.cnblogs.com/Zhang-Xiang/p/13936442.html</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> dapr </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mongodb索引</title>
      <link href="2021/04/11/e2d10866229005f119ae93e9e32962fc/"/>
      <url>2021/04/11/e2d10866229005f119ae93e9e32962fc/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/wyy1234/p/11032163.html">https://www.cnblogs.com/wyy1234/p/11032163.html</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> mongodb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql 联合索引</title>
      <link href="2021/04/06/8769b1a43a00b76ef09df8db7f07559b/"/>
      <url>2021/04/06/8769b1a43a00b76ef09df8db7f07559b/</url>
      
        <content type="html"><![CDATA[<p><a href="https://zhuanlan.zhihu.com/p/115778804">https://zhuanlan.zhihu.com/p/115778804</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL的MaxIdleConns不合理，会变成短连接</title>
      <link href="2021/03/26/12c9f0cbfcf059ac0ac85b4c102f0825/"/>
      <url>2021/03/26/12c9f0cbfcf059ac0ac85b4c102f0825/</url>
      
        <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/RA681t58CJxsgCkJ31/article/details/113152984">https://blog.csdn.net/RA681t58CJxsgCkJ31/article/details/113152984</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzA4ODg0NDkzOA==&amp;mid=2247489194&amp;idx=1&amp;sn=a897828ce7b6b7565e86016730643895&amp;chksm=9022a94fa755205924704d86c1d0e888cd5b693723d1c9f65a8de43ec9746470dc96af23ec00&amp;mpshare=1&amp;scene=1&amp;srcid=04060wt72Ry3aVMKuWRXGFW4&amp;sharer_sharetime=1617719631335&amp;sharer_shareid=2060268453ecf45de4742c8de6452f64&amp;version=3.0.28.2286&amp;platform=mac#rd">https://mp.weixin.qq.com/s?__biz=MzA4ODg0NDkzOA==&amp;mid=2247489194&amp;idx=1&amp;sn=a897828ce7b6b7565e86016730643895&amp;chksm=9022a94fa755205924704d86c1d0e888cd5b693723d1c9f65a8de43ec9746470dc96af23ec00&amp;mpshare=1&amp;scene=1&amp;srcid=04060wt72Ry3aVMKuWRXGFW4&amp;sharer_sharetime=1617719631335&amp;sharer_shareid=2060268453ecf45de4742c8de6452f64&amp;version=3.0.28.2286&amp;platform=mac#rd</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>rabbitmq事务</title>
      <link href="2021/03/22/04ba3a85ca1e3da658ce592b5aad6267/"/>
      <url>2021/03/22/04ba3a85ca1e3da658ce592b5aad6267/</url>
      
        <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/u013256816/article/details/55515234/">https://blog.csdn.net/u013256816/article/details/55515234/</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>mysql分库分表方案</title>
      <link href="2021/03/21/c29ad5fab4ba4f024f93b907efb93f3d/"/>
      <url>2021/03/21/c29ad5fab4ba4f024f93b907efb93f3d/</url>
      
        <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/suifeng629/article/details/102928937">https://blog.csdn.net/suifeng629/article/details/102928937</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>temporal文档</title>
      <link href="2021/03/21/ada9e5033a7960a21c3cce117afca77a/"/>
      <url>2021/03/21/ada9e5033a7960a21c3cce117afca77a/</url>
      
        <content type="html"><![CDATA[<p><a href="https://docs.temporal.io/docs/go-run-your-first-app/">https://docs.temporal.io/docs/go-run-your-first-app/</a><br><a href="https://github.com/linvon/temporal-doc-CN">https://github.com/linvon/temporal-doc-CN</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>分布式架构</title>
      <link href="2021/03/19/3f274bac0c7ea1e83ed30bd6e166a20f/"/>
      <url>2021/03/19/3f274bac0c7ea1e83ed30bd6e166a20f/</url>
      
        <content type="html"><![CDATA[<p><a href="https://my.oschina.net/u/133079/blog/4413070">https://my.oschina.net/u/133079/blog/4413070</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>wire</title>
      <link href="2021/03/19/b891b62ab9be7813b9c97aec94a62fff/"/>
      <url>2021/03/19/b891b62ab9be7813b9c97aec94a62fff/</url>
      
        <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/uisoul/article/details/108776073">https://blog.csdn.net/uisoul/article/details/108776073</a><br><a href="https://github.com/DrmagicE/wire-examples">https://github.com/DrmagicE/wire-examples</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>细说redis分布式锁</title>
      <link href="2021/03/13/d8dd60e83db8cc59d91145ef696a90ef/"/>
      <url>2021/03/13/d8dd60e83db8cc59d91145ef696a90ef/</url>
      
        <content type="html"><![CDATA[<p><a href="https://juejin.cn/post/6844904082860146695">https://juejin.cn/post/6844904082860146695</a><br><a href="https://juejin.cn/post/6936956908007850014">https://juejin.cn/post/6936956908007850014</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>微服务API设计的实践与思考总结</title>
      <link href="2021/03/08/0964af71beda76b5d7361fcd07ac0fea/"/>
      <url>2021/03/08/0964af71beda76b5d7361fcd07ac0fea/</url>
      
        <content type="html"><![CDATA[<p>API先行<br>在敏捷开发的大浪潮下，产品上通常要求快速迭代，面对一个新的需求，如果需要开发新的接口，通常在表结构完成设计后，开发人员就需要完成API设计并交付消费方（即服务的调用方或者依赖方，文中其余部分均表示此含义），在技术联调前，消费方可以Mock接口来完成调试。所以通常来说，API先与服务交付，之后再完成编码，测试，调试等工作。当然，由于可能在需求细节，技术实现方面可能在实现过程中发现需求需要调整，或者API接口的调整，最初版本的API可能是不成熟的，导致我们经常在API调整或者演化过程中在API维护方面存在很多遗漏，所以API最初交付后的维护是持续性的工作。</p><p>API设计常见问题<br>在我们设计API过程中由于存在经验的缺失，或者由于多次交接，或者由于经历多次需求的变更，导致服务的API慢慢腐化，带来以下常见的问题。<br>• 被遗忘的注释，注释通常描述了API的功能以及参数说明，以及如何接入，甚至给出简单示例，过于详细的注释会带来一定的反作用，例如因为新需求带来了内部逻辑的调整，但是由于未及时对API的注释进行更新，会给新接入的调用方带来潜在的风险。所以不仅仅需要为API提供完整清晰的注释，当内部逻辑变更时，作为开发人员通常也需要评估API层面的变更，包括注释。<br>• 接口数量持续膨胀，有很多原因带来接口数量的膨胀，可能是接口升级，但是旧接口无法直接下线，所以会提供一个功能类似的新接口；可能是新接管一个服务由于对业务不了解，面对新需求直接开发新接口；可能是接口分类划分不合理，或者数据模型混乱导致API划分混乱，出现API功能重复，最后导致一个场景多个API接口都可以满足，这样很明显是应该避免的。解决这些问题都需要建立在对业务充分理解的基础上，下文的设计原则会针对这类问题给出解决方案。<br>• 缺乏有效测试，很多开发人员往往忽略对于接口的测试，无论是内部逻辑细节的单元测试，还是接口层面的测试，都是服务健壮性的一个有效保证，如果无法对接口进行有效测试，不仅是不负责任的提现，而且还会经常被线上bug困扰。</p><p>API设计的原则<br>良好的注释<br>• 注释应该包含哪些；接口的使用场景，参数的说明，在接口类说明中可以给出接口文档链接地址，方便调用方查看<br>• 参数的说明；包含参数代表的含义，参数的类型按照Javadoc link规范，参数是否为空，特殊值说明<br>• 过期说明；如果接口已经过期，需要给出过期说明，对于 Java 来时就是@Deprecated注解，并给出切换接口说明，如果条件允许可以推动调用方进行接口迁移，后续对旧接口下线<br>扩展性<br>唯一不变的是变化，接口也会一直演化，我们不提倡过度提前设计，但是在演化过程中要始终保持接口的可扩展性。<br>• 多参数结构与单一参数类结构 通常来说，如果一个接口的参数小于三个，那么建议使用多参数接口，这样做到直观简洁 如果一个接口的参数较多而且后续可能经常出现变动，为了便于扩展和兼容，会将参数封装到一个类结构中，记得同样对每个字段给出完整的注释说明。<br>• 类复用噩梦 在单一参数类结构下，我经常看到多个存在明显功能差异的接口频繁复用一个结构体，甚至接口参数和返回值都复用一个DTO，为了保证兼容，又不得不在同一个DTO内不断加字段，久而久之维护成本持续增高，这是一种不合理的类设计，如果遵守专注原则，这个问题很多时候可以避免。<br>兼容性<br>• 接口逻辑或者参数变更时，需要对旧的接口保持兼容，这个是API变更时一定要遵守的原则之一，而且要通过接口测试来验证兼容性。<br>• 是否要新增接口，当面对一个新的需求时，为了避免对旧接口直接修改，有的开发人员会统一提供新的接口，如果并非逻辑上发生较大的变更，这样做会提高API的维护成本，后续如果不对API进行重构，新增加的维护成本将远大于最开始节省的开发成本，例如需要对某个参数增加有效校验，那么我们需要对两个接口的API实现都做修改，而且是重复性的代码，而且我们的影响范围已经成了两个接口，这样影响范围的扩大也带来了更多的潜在风险。当然在某些场景例如接口逻辑出现大的调整，API重构等情况下，更好的方法是提供新的接口，并推动服务消费者使用新的API，最后慢慢下线旧的API，这样才能遵循简单和专注的原则。<br>完善的测试<br>• 单元测试，完善的单元测试能保证代码的健壮性，提前在编码阶段发现并解决潜在的bug，单元测试是一个开发人员的必备能力。<br>• 接口和场景测试，接口测试包含内部逻辑验证，异常输入，并发等场景下对单一接口的验证，如果要对API进行完整的逻辑验证，需要开发人员构造完整的测试数据（通常包含scheme.sql和data.sql文件），尤其是对于基础服务，需要对某些复杂业务场景下联合多个接口完成某个场景的测试，并对中间的数据和输出进行Assert确认，这样也会代码一定的测试代码维护成本，需要开发人员进行利弊权衡。<br>重视文档<br>良好的注释和文档能减少大部分和服务消费者的沟通工作，也避免了一些错误的接口调用。没有人希望每次都需要在IM工具上浪费大量口水或者需要当面询问才知道如何正确使用API，也没有开发者愿意每天重复回答如何调用提供的接口。对于接口文档，可以是采用Javadoc这样简单的方式，也可以是通过wiki来集中管理，可以是markdown文档，也有很多的开源系系统例如Swagger，yapi，eolinker等；微服务的架构极大的加强了沟通的成本，这也是微服务架构的一个弊端，但是合理的利用 工具 可以减少不必要的沟通。<br>善用工具<br>理论肯定是基本功，但是合理使用API工具能提高工作效率相信大多数人都不会反对，国外的Postman，Swagger，国内的Eolinker，都是现在蛮多同行在用的API工具。</p><p>总结<br>作为微服务之间的桥梁，API设计和维护是微服务架构中很重要的一个环节，每个开发人员不仅仅需要良好的代码规范，也需要建立并遵守API设计规范。API设计能力在微服务架构中作为软实力的一个部分，需要开发人员有一定的设计经验的积累，同时，只有不断的思考和总结才能更加深入的理解。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>AVL树(二叉平衡树)详解与实现</title>
      <link href="2021/03/07/ebfb21bbb2c67f32d750cbde9770e409/"/>
      <url>2021/03/07/ebfb21bbb2c67f32d750cbde9770e409/</url>
      
        <content type="html"><![CDATA[<h2><span id="avl树概念">AVL树概念</span></h2><ul><li>AVL树是带有平衡条件的二叉查找树。这个平衡条件必须要容易保持。而且要保证它的深度是O(logN).</li><li>AVL的条件是左右树的高度差（平衡因子）不大于1；并且它的每个子树也都是平衡二叉树。</li></ul><h2><span id="红黑树与avl树的区别">红黑树与AVL树的区别</span></h2><p><strong>AVL树</strong></p><p>1）和红黑树相比，AVL树是严格的平衡二叉树，平衡条件必须满足（所有节点的左右子树高度差不超过1）。 不管是执行插入还是删除操作，只要不满足上面的条件，就要通过旋转来保持平衡，而旋转是非常耗时的，由此我们可以知道AVL树适合用于<font color="#FF0000">插入与删除次数比较少</font>，但<font color="#FF0000">查找多</font>的情况。<br>2）AVL树追求绝对平衡，条件比较苛刻，实现起来比较麻烦，每次插入新节点之后需要旋转的次数不能预知。<br>3）由于维护这种高度平衡所付出的代价比从中获得的效率收益还大，故而实际的应用不多，更多的地方是用追求局部而不是非常严格整体平衡的红黑树。当然，如果应用场景中对插入、删除不频繁，只是对查找要求较高，那么AVL还是较优于红黑树。<br>4）相较红黑树AVL树查找性能更快</p><p><strong>红黑树</strong><br>1）红黑树放弃了追求完全平衡，而是追求大致平衡，在与AVL树的时间复杂度相差不大的情况下，保证每次插入最多只需要三次旋转就能达到平衡，维持平衡的时间消耗较少，实现起来也更为简单。<br>2）相对于要求严格平衡的AVL树来说，它的旋转次数少，对于<font color="#FF0000">插入、删除操作较多</font>的情况下，选择红黑树。<br>3）红黑树的查询性能略微逊色于AVL树，因为其比AVL树会稍微不平衡最多一层，也就是说红黑树的查询性能只比相同内容的AVL树最多多一次比较，但是，红黑树在插入和删除上优于AVL树，AVL树每次插入删除会进行大量的平衡度计算，而红黑树为了维持红黑性质所做的红黑变换和旋转的开销，相较于AVL树为了维持平衡的开销要小得多。</p><p>对于平衡二叉树的最小个数，n0=0;n1=1;nk=n(k-1)+n(k-2)+1;(求法可以类比斐波那契！)<br>难点：AVL是一颗二叉排序树，用什么样的规则或者规律让它能够在复杂度不太高的情况下实现动态平衡呢？</p><h2><span id="不平衡概况">不平衡概况</span></h2><p><img src="/2021/03/07/ebfb21bbb2c67f32d750cbde9770e409/1615107098072.png"><br>如果简单的以单节点看，大致有上面四种情形，并且他们的最后结果也是有的有所相近。只是：上下会变动。该在左面的还在左面，改在右面的还在右面。</p><p><img src="/2021/03/07/ebfb21bbb2c67f32d750cbde9770e409/1615107110785.png"><br>这只是针对在底部，对于可能出现的平衡要首先搞清楚：<br><img src="/2021/03/07/ebfb21bbb2c67f32d750cbde9770e409/1615107127819.png"><br>所以针对四种不平衡，可能出现在底部，也可能出现在头，也可能出现在某个中间节点导致不平衡。 而我们只需要研究其首次不平衡点，解决之后整棵树即继续平衡。当然，在实际解决肯定会带上递归的思想解决问题。</p><h2><span id="四种平衡旋转方式">四种平衡旋转方式</span></h2><h3><span id="rr平衡旋转左单旋转">RR平衡旋转(左单旋转)</span></h3><p><img src="/2021/03/07/ebfb21bbb2c67f32d750cbde9770e409/1615107156271.png"><br>出现这种情况的原因是节点的右侧的右侧较深这时候不平衡节点需要左旋。再细看过程。</p><ul><li>再左旋的过程中，root(oldroot)节点下沉，中间节点(newroot)上浮.而其中中间节点(newroot)的右侧依然不变。</li><li>它上浮左侧所以需要指向根节点(oldroot)(毕竟一棵树)。但是这样newroot原来左侧节点H空缺。而我们需要仍然让整个树完整并且满足二叉排序树的规则。<br>而刚好本来oldroot右侧指向newroot变成oldroot被newroot左侧指向。所以oldroot右侧空缺，刚好这个位置满足在oldroot的右侧。在newroot的左侧。.所以我们将H插入在这个位置。</li><li>其中H可能为NULL。不过不影响操作！<br><img src="/2021/03/07/ebfb21bbb2c67f32d750cbde9770e409/1615107211166.png"></li></ul><h3><span id="ll平衡旋转右单旋转">LL平衡旋转(右单旋转)</span></h3><p>而右旋和左旋相反，但是思路相同，根据上述进行替换即可！</p><p><img src="/2021/03/07/ebfb21bbb2c67f32d750cbde9770e409/1615107235871.png"></p><h3><span id="rl平衡旋转先右后左双旋转">RL平衡旋转(先右后左双旋转)</span></h3><p>产生不平衡的条件原因是：</p><ul><li>root节点右侧左侧节点的深度高些，使得与左侧的差大于1.这个与我们前面看到的左旋右旋不同的是因为它的结构不能直接变一下就可以完成。</li><li>因为对于右左结构，中间的最大，两侧的最小。但是下面的比上面大(下面在上面右侧)所以如果平衡的话，那么右左的R.L应该在中间，而R应该在右侧。原来的root在左侧。</li><li>所以节点的变化浮动比较大，而且需要妥善处理各个子节点的移动使其满足二叉排序树的性质！</li><li>期间考虑树高度变化即可！<br>这种双旋转其实也很简单。不要被外表唬住。基于前面的单旋转，双旋转有两种具体逻辑思路。</li></ul><p><strong>思路1：两次旋转RR,LL</strong><br><img src="/2021/03/07/ebfb21bbb2c67f32d750cbde9770e409/1615107283247.png"><br>根据上图所圈的，先对底部使得底部的大小关系变化，使其在满足二叉平衡树的条件下还满足RR结构的二叉树。所以只需要对右节点R先进行右旋,再对ROOT进行左旋即可。</p><p><strong>思路2：直接分析</strong></p><p>根据初始和结果的状态，然后分析各个节点变化顺序。手动操作这些节点即可！</p><ul><li>首先根据ROOT,R,R.L三个节点变化。R.L肯定要在最顶层。左右分别指向ROOT和R。那么这其中R.left，ROOT.right发生变化(原来分别是R,L和R)暂时为空。而刚好根据左右大小关系可以补上R.L的左右节点。</li><li>这样思考整棵树也可以完成平衡，但是要考虑树的高度变化。</li></ul><p><img src="/2021/03/07/ebfb21bbb2c67f32d750cbde9770e409/1615107321758.png"></p><h3><span id="lr平衡旋转先左后右单旋转">LR平衡旋转(先左后右单旋转)</span></h3><p>根据上述RL修改即可</p><p><img src="/2021/03/07/ebfb21bbb2c67f32d750cbde9770e409/1615107339411.png"></p><p><strong>代码如下：</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">"fmt"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// AVL树</span><br><span class="line">type AVLTree struct {</span><br><span class="line">Root *AVLTreeNode // 树根节点</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// AVL节点</span><br><span class="line">type AVLTreeNode struct {</span><br><span class="line">Value  int64        // 值</span><br><span class="line">Times  int64        // 值出现的次数</span><br><span class="line">Height int64        // 该节点作为树根节点，树的高度，方便计算平衡因子</span><br><span class="line">Left   *AVLTreeNode // 左子树</span><br><span class="line">Right  *AVLTreeNode // 右字树</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 初始化一个AVL树</span><br><span class="line">func NewAVLTree() *AVLTree {</span><br><span class="line">return new(AVLTree)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 更新节点的树高度</span><br><span class="line">func (node *AVLTreeNode) UpdateHeight() {</span><br><span class="line">if node == nil {</span><br><span class="line">return</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">var leftHeight, rightHeight int64 = 0, 0</span><br><span class="line">if node.Left != nil {</span><br><span class="line">leftHeight = node.Left.Height</span><br><span class="line">}</span><br><span class="line">if node.Right != nil {</span><br><span class="line">rightHeight = node.Right.Height</span><br><span class="line">}</span><br><span class="line">// 哪个子树高算哪棵的</span><br><span class="line">maxHeight := leftHeight</span><br><span class="line">if rightHeight &gt; maxHeight {</span><br><span class="line">maxHeight = rightHeight</span><br><span class="line">}</span><br><span class="line">// 高度加上自己那一层</span><br><span class="line">node.Height = maxHeight + 1</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 计算平衡因子</span><br><span class="line">func (node *AVLTreeNode) BalanceFactor() int64 {</span><br><span class="line">var leftHeight, rightHeight int64 = 0, 0</span><br><span class="line">if node.Left != nil {</span><br><span class="line">leftHeight = node.Left.Height</span><br><span class="line">}</span><br><span class="line">if node.Right != nil {</span><br><span class="line">rightHeight = node.Right.Height</span><br><span class="line">}</span><br><span class="line">return leftHeight - rightHeight</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 单右旋操作，看图说话</span><br><span class="line">func RightRotation(Root *AVLTreeNode) *AVLTreeNode {</span><br><span class="line">// 只有Pivot和B，Root位置变了</span><br><span class="line">Pivot := Root.Left</span><br><span class="line">B := Pivot.Right</span><br><span class="line">Pivot.Right = Root</span><br><span class="line">Root.Left = B</span><br><span class="line"></span><br><span class="line">// 只有Root和Pivot变化了高度</span><br><span class="line">Root.UpdateHeight()</span><br><span class="line">Pivot.UpdateHeight()</span><br><span class="line">return Pivot</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 单左旋操作，看图说话</span><br><span class="line">func LeftRotation(Root *AVLTreeNode) *AVLTreeNode {</span><br><span class="line">// 只有Pivot和B，Root位置变了</span><br><span class="line">Pivot := Root.Right</span><br><span class="line">B := Pivot.Left</span><br><span class="line">Pivot.Left = Root</span><br><span class="line">Root.Right = B</span><br><span class="line"></span><br><span class="line">// 只有Root和Pivot变化了高度</span><br><span class="line">Root.UpdateHeight()</span><br><span class="line">Pivot.UpdateHeight()</span><br><span class="line">return Pivot</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 先左后右旋操作，看图说话</span><br><span class="line">func LeftRightRotation(node *AVLTreeNode) *AVLTreeNode {</span><br><span class="line">node.Left = LeftRotation(node.Left)</span><br><span class="line">return RightRotation(node)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 先右后左旋操作，看图说话</span><br><span class="line">func RightLeftRotation(node *AVLTreeNode) *AVLTreeNode {</span><br><span class="line">node.Right = RightRotation(node.Right)</span><br><span class="line">return LeftRotation(node)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 添加元素</span><br><span class="line">func (tree *AVLTree) Add(value int64) {</span><br><span class="line">// 往树根添加元素，会返回新的树根</span><br><span class="line">tree.Root = tree.Root.Add(value)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func (node *AVLTreeNode) Add(value int64) *AVLTreeNode {</span><br><span class="line">// 添加值到根节点node，如果node为空，那么让值成为新的根节点，树的高度为1</span><br><span class="line">if node == nil {</span><br><span class="line">return &amp;AVLTreeNode{Value: value, Height: 1}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 如果值重复，什么都不用做，直接更新次数</span><br><span class="line">if node.Value == value {</span><br><span class="line">node.Times = node.Times + 1</span><br><span class="line">return node</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 辅助变量</span><br><span class="line">var newTreeNode *AVLTreeNode</span><br><span class="line"></span><br><span class="line">if value &gt; node.Value {</span><br><span class="line">// 插入的值大于节点值，要从右子树继续插入</span><br><span class="line">node.Right = node.Right.Add(value)</span><br><span class="line">// 平衡因子，插入右子树后，要确保树根左子树的高度不能比右子树低一层。</span><br><span class="line">factor := node.BalanceFactor()</span><br><span class="line">// 右子树的高度变高了，导致左子树-右子树的高度从-1变成了-2。</span><br><span class="line">if factor == -2 {</span><br><span class="line">if value &gt; node.Right.Value {</span><br><span class="line">// 表示在右子树上插上右儿子导致失衡，需要单左旋：</span><br><span class="line">newTreeNode = LeftRotation(node)</span><br><span class="line">} else {</span><br><span class="line">//表示在右子树上插上左儿子导致失衡，先右后左旋：</span><br><span class="line">newTreeNode = RightLeftRotation(node)</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">} else {</span><br><span class="line">// 插入的值小于节点值，要从左子树继续插入</span><br><span class="line">node.Left = node.Left.Add(value)</span><br><span class="line">// 平衡因子，插入左子树后，要确保树根左子树的高度不能比右子树高一层。</span><br><span class="line">factor := node.BalanceFactor()</span><br><span class="line">// 左子树的高度变高了，导致左子树-右子树的高度从1变成了2。</span><br><span class="line">if factor == 2 {</span><br><span class="line">if value &lt; node.Left.Value {</span><br><span class="line">// 表示在左子树上插上左儿子导致失衡，需要单右旋：</span><br><span class="line">newTreeNode = RightRotation(node)</span><br><span class="line">} else {</span><br><span class="line">//表示在左子树上插上右儿子导致失衡，先左后右旋：</span><br><span class="line">newTreeNode = LeftRightRotation(node)</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">if newTreeNode == nil {</span><br><span class="line">// 表示什么旋转都没有，根节点没变，直接刷新树高度</span><br><span class="line">node.UpdateHeight()</span><br><span class="line">return node</span><br><span class="line">} else {</span><br><span class="line">// 旋转了，树根节点变了，需要刷新新的树根高度</span><br><span class="line">newTreeNode.UpdateHeight()</span><br><span class="line">return newTreeNode</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 找出最小值的节点</span><br><span class="line">func (tree *AVLTree) FindMinValue() *AVLTreeNode {</span><br><span class="line">if tree.Root == nil {</span><br><span class="line">// 如果是空树，返回空</span><br><span class="line">return nil</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">return tree.Root.FindMinValue()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func (node *AVLTreeNode) FindMinValue() *AVLTreeNode {</span><br><span class="line">// 左子树为空，表面已经是最左的节点了，该值就是最小值</span><br><span class="line">if node.Left == nil {</span><br><span class="line">return node</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 一直左子树递归</span><br><span class="line">return node.Left.FindMinValue()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 找出最大值的节点</span><br><span class="line">func (tree *AVLTree) FindMaxValue() *AVLTreeNode {</span><br><span class="line">if tree.Root == nil {</span><br><span class="line">// 如果是空树，返回空</span><br><span class="line">return nil</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">return tree.Root.FindMaxValue()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func (node *AVLTreeNode) FindMaxValue() *AVLTreeNode {</span><br><span class="line">// 右子树为空，表面已经是最右的节点了，该值就是最大值</span><br><span class="line">if node.Right == nil {</span><br><span class="line">return node</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 一直右子树递归</span><br><span class="line">return node.Right.FindMaxValue()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 查找指定节点</span><br><span class="line">func (tree *AVLTree) Find(value int64) *AVLTreeNode {</span><br><span class="line">if tree.Root == nil {</span><br><span class="line">// 如果是空树，返回空</span><br><span class="line">return nil</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">return tree.Root.Find(value)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func (node *AVLTreeNode) Find(value int64) *AVLTreeNode {</span><br><span class="line">if value == node.Value {</span><br><span class="line">// 如果该节点刚刚等于该值，那么返回该节点</span><br><span class="line">return node</span><br><span class="line">} else if value &lt; node.Value {</span><br><span class="line">// 如果查找的值小于节点值，从节点的左子树开始找</span><br><span class="line">if node.Left == nil {</span><br><span class="line">// 左子树为空，表示找不到该值了，返回nil</span><br><span class="line">return nil</span><br><span class="line">}</span><br><span class="line">return node.Left.Find(value)</span><br><span class="line">} else {</span><br><span class="line">// 如果查找的值大于节点值，从节点的右子树开始找</span><br><span class="line">if node.Right == nil {</span><br><span class="line">// 右子树为空，表示找不到该值了，返回nil</span><br><span class="line">return nil</span><br><span class="line">}</span><br><span class="line">return node.Right.Find(value)</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 删除指定的元素</span><br><span class="line">func (tree *AVLTree) Delete(value int64) {</span><br><span class="line">if tree.Root == nil {</span><br><span class="line">// 如果是空树，直接返回</span><br><span class="line">return</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">tree.Root = tree.Root.Delete(value)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func (node *AVLTreeNode) Delete(value int64) *AVLTreeNode {</span><br><span class="line">if node == nil {</span><br><span class="line">// 如果是空树，直接返回</span><br><span class="line">return nil</span><br><span class="line">}</span><br><span class="line">if value &lt; node.Value {</span><br><span class="line">// 从左子树开始删除</span><br><span class="line">node.Left = node.Left.Delete(value)</span><br><span class="line">// 删除后要更新该子树高度</span><br><span class="line">node.Left.UpdateHeight()</span><br><span class="line">} else if value &gt; node.Value {</span><br><span class="line">// 从右子树开始删除</span><br><span class="line">node.Right = node.Right.Delete(value)</span><br><span class="line">// 删除后要更新该子树高度</span><br><span class="line">node.Right.UpdateHeight()</span><br><span class="line">} else {</span><br><span class="line">// 找到该值对应的节点</span><br><span class="line">// 该节点没有左右子树</span><br><span class="line">// 第一种情况，删除的节点没有儿子，直接删除即可。</span><br><span class="line">if node.Left == nil &amp;&amp; node.Right == nil {</span><br><span class="line">return nil // 直接返回nil，表示直接该值删除</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 该节点有两棵子树，选择更高的哪个来替换</span><br><span class="line">// 第二种情况，删除的节点下有两个子树，选择高度更高的子树下的节点来替换被删除的节点，如果左子树更高，选择左子树中最大的节点，也就是左子树最右边的叶子节点，如果右子树更高，选择右子树中最小的节点，也就是右子树最左边的叶子节点。最后，删除这个叶子节点。</span><br><span class="line">if node.Left != nil &amp;&amp; node.Right != nil {</span><br><span class="line">// 左子树更高，拿左子树中最大值的节点替换</span><br><span class="line">if node.Left.Height &gt; node.Right.Height {</span><br><span class="line">maxNode := node.Left</span><br><span class="line">for maxNode.Right != nil {</span><br><span class="line">maxNode = maxNode.Right</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 最大值的节点替换被删除节点</span><br><span class="line">node.Value = maxNode.Value</span><br><span class="line">node.Times = maxNode.Times</span><br><span class="line"></span><br><span class="line">// 把最大的节点删掉</span><br><span class="line">node.Left = node.Left.Delete(maxNode.Value)</span><br><span class="line">// 删除后要更新该子树高度</span><br><span class="line">node.Left.UpdateHeight()</span><br><span class="line">} else {</span><br><span class="line">// 右子树更高，拿右子树中最小值的节点替换</span><br><span class="line">minNode := node.Right</span><br><span class="line">for minNode.Left != nil {</span><br><span class="line">minNode = minNode.Left</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 最小值的节点替换被删除节点</span><br><span class="line">node.Value = minNode.Value</span><br><span class="line">node.Times = minNode.Times</span><br><span class="line"></span><br><span class="line">// 把最小的节点删掉</span><br><span class="line">node.Right = node.Right.Delete(minNode.Value)</span><br><span class="line">// 删除后要更新该子树高度</span><br><span class="line">node.Right.UpdateHeight()</span><br><span class="line">}</span><br><span class="line">} else {</span><br><span class="line">// 只有左子树或只有右子树</span><br><span class="line">// 只有一个子树，该子树也只是一个节点，将该节点替换被删除的节点，然后置子树为空</span><br><span class="line">if node.Left != nil {</span><br><span class="line">//第三种情况，删除的节点只有左子树，因为树的特征，可以知道左子树其实就只有一个节点，它本身，否则高度差就等于2了。</span><br><span class="line">node.Value = node.Left.Value</span><br><span class="line">node.Times = node.Left.Times</span><br><span class="line">node.Height = 1</span><br><span class="line">node.Left = nil</span><br><span class="line">} else if node.Right != nil {</span><br><span class="line">//第四种情况，删除的节点只有右子树，因为树的特征，可以知道右子树其实就只有一个节点，它本身，否则高度差就等于2了。</span><br><span class="line">node.Value = node.Right.Value</span><br><span class="line">node.Times = node.Right.Times</span><br><span class="line">node.Height = 1</span><br><span class="line">node.Right = nil</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 找到值后，进行替换删除后，直接返回该节点</span><br><span class="line">return node</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 左右子树递归删除节点后需要平衡</span><br><span class="line">var newNode *AVLTreeNode</span><br><span class="line">// 相当删除了右子树的节点，左边比右边高了，不平衡</span><br><span class="line">if node.BalanceFactor() == 2 {</span><br><span class="line">if node.Left.BalanceFactor() == 1 {</span><br><span class="line">newNode = RightRotation(node)</span><br><span class="line">} else {</span><br><span class="line">newNode = LeftRightRotation(node)</span><br><span class="line">}</span><br><span class="line">//  相当删除了左子树的节点，右边比左边高了，不平衡</span><br><span class="line">} else if node.BalanceFactor() == -2 {</span><br><span class="line">if node.Right.BalanceFactor() == -1 {</span><br><span class="line">newNode = LeftRotation(node)</span><br><span class="line">} else {</span><br><span class="line">newNode = RightLeftRotation(node)</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">if newNode == nil {</span><br><span class="line">node.UpdateHeight()</span><br><span class="line">return node</span><br><span class="line">} else {</span><br><span class="line">newNode.UpdateHeight()</span><br><span class="line">return newNode</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 中序遍历</span><br><span class="line">func (tree *AVLTree) MidOrder() {</span><br><span class="line">tree.Root.MidOrder()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func (node *AVLTreeNode) MidOrder() {</span><br><span class="line">if node == nil {</span><br><span class="line">return</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 先打印左子树</span><br><span class="line">node.Left.MidOrder()</span><br><span class="line"></span><br><span class="line">// 按照次数打印根节点</span><br><span class="line">for i := 0; i &lt;= int(node.Times); i++ {</span><br><span class="line">fmt.Println("value:", node.Value, " tree height:", node.BalanceFactor())</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 打印右子树</span><br><span class="line">node.Right.MidOrder()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 验证是不是棵AVL树</span><br><span class="line">func (tree *AVLTree) IsAVLTree() bool {</span><br><span class="line">if tree == nil || tree.Root == nil {</span><br><span class="line">return true</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 判断节点是否符合 AVL 树的定义</span><br><span class="line">if tree.Root.IsRight() {</span><br><span class="line">return true</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">return false</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 判断节点是否符合 AVL 树的定义</span><br><span class="line">func (node *AVLTreeNode) IsRight() bool {</span><br><span class="line">if node == nil {</span><br><span class="line">return true</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 左右子树都为空，那么是叶子节点</span><br><span class="line">if node.Left == nil &amp;&amp; node.Right == nil {</span><br><span class="line">// 叶子节点高度应该为1</span><br><span class="line">if node.Height == 1 {</span><br><span class="line">return true</span><br><span class="line">} else {</span><br><span class="line">fmt.Println("leaf node height is ", node.Height)</span><br><span class="line">return false</span><br><span class="line">}</span><br><span class="line">} else if node.Left != nil &amp;&amp; node.Right != nil {</span><br><span class="line">// 左右子树都是满的</span><br><span class="line">// 左儿子必须比父亲小，右儿子必须比父亲大</span><br><span class="line">if node.Left.Value &lt; node.Value &amp;&amp; node.Right.Value &gt; node.Value {</span><br><span class="line">} else {</span><br><span class="line">// 不符合 AVL 树定义</span><br><span class="line">fmt.Printf("father is %v lchild is %v, rchild is %v\n", node.Value, node.Left.Value, node.Right.Value)</span><br><span class="line">return false</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">bal := node.Left.Height - node.Right.Height</span><br><span class="line">if bal &lt; 0 {</span><br><span class="line">bal = -bal</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 子树高度差不能大于1</span><br><span class="line">if bal &gt; 1 {</span><br><span class="line">fmt.Println("sub tree height bal is ", bal)</span><br><span class="line">return false</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 如果左子树比右子树高，那么父亲的高度等于左子树+1</span><br><span class="line">if node.Left.Height &gt; node.Right.Height {</span><br><span class="line">if node.Height == node.Left.Height+1 {</span><br><span class="line">} else {</span><br><span class="line">fmt.Printf("%#v height:%v,left sub tree height: %v,right sub tree height:%v\n", node, node.Height, node.Left.Height, node.Right.Height)</span><br><span class="line">return false</span><br><span class="line">}</span><br><span class="line">} else {</span><br><span class="line">// 如果右子树比左子树高，那么父亲的高度等于右子树+1</span><br><span class="line">if node.Height == node.Right.Height+1 {</span><br><span class="line">} else {</span><br><span class="line">fmt.Printf("%#v height:%v,left sub tree height: %v,right sub tree height:%v\n", node, node.Height, node.Left.Height, node.Right.Height)</span><br><span class="line">return false</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 递归判断子树</span><br><span class="line">if !node.Left.IsRight() {</span><br><span class="line">return false</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 递归判断子树</span><br><span class="line">if !node.Right.IsRight() {</span><br><span class="line">return false</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">} else {</span><br><span class="line">// 只存在一棵子树</span><br><span class="line">if node.Right != nil {</span><br><span class="line">// 子树高度只能是1</span><br><span class="line">if node.Right.Height == 1 &amp;&amp; node.Right.Left == nil &amp;&amp; node.Right.Right == nil {</span><br><span class="line">if node.Right.Value &gt; node.Value {</span><br><span class="line">// 右节点必须比父亲大</span><br><span class="line">} else {</span><br><span class="line">fmt.Printf("%v,(%#v,%#v) child", node.Value, node.Right, node.Left)</span><br><span class="line">return false</span><br><span class="line">}</span><br><span class="line">} else {</span><br><span class="line">fmt.Printf("%v,(%#v,%#v) child", node.Value, node.Right, node.Left)</span><br><span class="line">return false</span><br><span class="line">}</span><br><span class="line">} else {</span><br><span class="line">if node.Left.Height == 1 &amp;&amp; node.Left.Left == nil &amp;&amp; node.Left.Right == nil {</span><br><span class="line">if node.Left.Value &lt; node.Value {</span><br><span class="line">// 左节点必须比父亲小</span><br><span class="line">} else {</span><br><span class="line">fmt.Printf("%v,(%#v,%#v) child", node.Value, node.Right, node.Left)</span><br><span class="line">return false</span><br><span class="line">}</span><br><span class="line">} else {</span><br><span class="line">fmt.Printf("%v,(%#v,%#v) child", node.Value, node.Right, node.Left)</span><br><span class="line">return false</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">return true</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">values := []int64{2, 3, 7, 10, 10, 10, 10, 23, 9, 102, 109, 111, 112, 113}</span><br><span class="line"></span><br><span class="line">// 初始化二叉查找树并添加元素</span><br><span class="line">tree := NewAVLTree()</span><br><span class="line">for _, v := range values {</span><br><span class="line">tree.Add(v)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 找到最大值或最小值的节点</span><br><span class="line">fmt.Printf("find min value: %+v\n", tree.FindMinValue())</span><br><span class="line">fmt.Printf("find max value: %+v\n", tree.FindMaxValue())</span><br><span class="line"></span><br><span class="line">// 查找不存在的99</span><br><span class="line">node := tree.Find(99)</span><br><span class="line">if node != nil {</span><br><span class="line">fmt.Println("find it 99!")</span><br><span class="line">} else {</span><br><span class="line">fmt.Println("not find it 99!")</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 查找存在的9</span><br><span class="line">node = tree.Find(9)</span><br><span class="line">if node != nil {</span><br><span class="line">fmt.Println("find it 9!")</span><br><span class="line">} else {</span><br><span class="line">fmt.Println("not find it 9!")</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 删除存在的9后，再查找9</span><br><span class="line">tree.Delete(9)</span><br><span class="line">tree.Delete(10)</span><br><span class="line">tree.Delete(2)</span><br><span class="line">tree.Delete(3)</span><br><span class="line">tree.Add(4)</span><br><span class="line">tree.Add(3)</span><br><span class="line">tree.Add(10)</span><br><span class="line">tree.Delete(111)</span><br><span class="line">node = tree.Find(9)</span><br><span class="line">if node != nil {</span><br><span class="line">fmt.Println("find it 9!")</span><br><span class="line">} else {</span><br><span class="line">fmt.Println("not find it 9!")</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 中序遍历，实现排序</span><br><span class="line">tree.MidOrder()</span><br><span class="line"></span><br><span class="line">if tree.IsAVLTree() {</span><br><span class="line">fmt.Println("is a avl tree")</span><br><span class="line">} else {</span><br><span class="line">fmt.Println("is not avl tree")</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>第一次有人把“分布式事务”讲的这么简单明了</title>
      <link href="2021/03/07/a60edbd9d3938850b99a37f0c095d99b/"/>
      <url>2021/03/07/a60edbd9d3938850b99a37f0c095d99b/</url>
      
        <content type="html"><![CDATA[<p>又或者在网上购物明明已经扣款，但是却告诉我没有发生交易。这一系列情况都是因为没有事务导致的。这说明了事务在生活中的一些重要性。</p><p>有了事务，你去小卖铺买东西，那就是一手交钱一手交货。有了事务，你去网上购物，扣款即产生订单交易。</p><h3><span id="事务的具体定义">事务的具体定义</span></h3><p>事务提供一种机制将一个活动涉及的所有操作纳入到一个不可分割的执行单元，组成事务的所有操作只有在所有操作均能正常执行的情况下方能提交，只要其中任一操作执行失败，都将导致整个事务的回滚。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">简单地说，事务提供一种“要么什么都不做，要么做全套（All or Nothing）”机制。</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h3><span id="数据库本地事务">数据库本地事务</span></h3><h4><span id="acid">ACID</span></h4><p>说到数据库事务就不得不说，数据库事务中的四大特性 ACID：<br>A：原子性(Atomicity)，一个事务(transaction)中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。</p><p>事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。</p><p>就像你买东西要么交钱收货一起都执行，要么发不出货，就退钱。</p><p>C：一致性(Consistency)，事务的一致性指的是在一个事务执行之前和执行之后数据库都必须处于一致性状态。</p><p>如果事务成功地完成，那么系统中所有变化将正确地应用，系统处于有效状态。</p><p>如果在事务中出现错误，那么系统中的所有变化将自动地回滚，系统返回到原始状态。</p><p>I：隔离性(Isolation)，指的是在并发环境中，当不同的事务同时操纵相同的数据时，每个事务都有各自的完整数据空间。</p><p>由并发事务所做的修改必须与任何其他并发事务所做的修改隔离。事务查看数据更新时，数据所处的状态要么是另一事务修改它之前的状态，要么是另一事务修改它之后的状态，事务不会查看到中间状态的数据。</p><p>打个比方，你买东西这个事情，是不影响其他人的。</p><p>D：持久性(Durability)，指的是只要事务成功结束，它对数据库所做的更新就必须永久保存下来。</p><p>即使发生系统崩溃，重新启动数据库系统后，数据库还能恢复到事务成功结束时的状态。</p><p>打个比方，你买东西的时候需要记录在账本上，即使老板忘记了那也有据可查。</p><h4><span id="innodb-实现原理">InnoDB 实现原理</span></h4><p>InnoDB 是 MySQL 的一个存储引擎，大部分人对 MySQL 都比较熟悉，这里简单介绍一下数据库事务实现的一些基本原理。<br>在本地事务中，服务和资源在事务的包裹下可以看做是一体的，如下图：</p><p><img src="/2021/03/07/a60edbd9d3938850b99a37f0c095d99b/1615076606681.png"><br>我们的本地事务由资源管理器进行管理：</p><p><img src="/2021/03/07/a60edbd9d3938850b99a37f0c095d99b/1615076625450.jpg"><br>而事务的 ACID 是通过 InnoDB 日志和锁来保证。事务的隔离性是通过数据库锁的机制实现的，持久性通过 Redo Log（重做日志）来实现，原子性和一致性通过 Undo Log 来实现。</p><p>Undo Log 的原理很简单，为了满足事务的原子性，在操作任何数据之前，首先将数据备份到一个地方（这个存储数据备份的地方称为 Undo Log）。然后进行数据的修改。</p><p>如果出现了错误或者用户执行了 Rollback 语句，系统可以利用 Undo Log 中的备份将数据恢复到事务开始之前的状态。 </p><p>和 Undo Log 相反，Redo Log 记录的是新数据的备份。在事务提交前，只要将 Redo Log 持久化即可，不需要将数据持久化。</p><p>当系统崩溃时，虽然数据没有持久化，但是 Redo Log 已经持久化。系统可以根据 Redo Log 的内容，将所有数据恢复到最新的状态。对具体实现过程有兴趣的同学可以去自行搜索扩展。</p><h3><span id="分布式事务">分布式事务</span></h3><h4><span id="什么是分布式事务">什么是分布式事务</span></h4><p>分布式事务指事务的参与者、支持事务的服务器、资源服务器以及事务管理器分别位于不同的分布式系统的不同节点之上。</p><p>简单的说，就是一次大的操作由不同的小操作组成，这些小的操作分布在不同的服务器上，且属于不同的应用，分布式事务需要保证这些小操作要么全部成功，要么全部失败。</p><p>本质上来说，分布式事务就是为了保证不同数据库的数据一致性。</p><ul><li>分布式事务产生的原因</li></ul><p>从上面本地事务来看，我们可以分为两块：</p><ul><li>Service 产生多个节点</li><li>Resource 产生多个节点Service 多个节点<br>随着互联网快速发展，微服务，SOA 等服务架构模式正在被大规模的使用。</li></ul><p>举个简单的例子，一个公司之内，用户的资产可能分为好多个部分，比如余额，积分，优惠券等等。</p><p>在公司内部有可能积分功能由一个微服务团队维护，优惠券又是另外的团队维护。<br><img src="/2021/03/07/a60edbd9d3938850b99a37f0c095d99b/1615076691970.jpg"></p><p>这样的话就无法保证积分扣减了之后，优惠券能否扣减成功。</p><p>Resource多个节点</p><p>同样的，互联网发展得太快了，我们的 MySQL 一般来说装千万级的数据就得进行分库分表。</p><p>对于一个支付宝的转账业务来说，你给朋友转钱，有可能你的数据库是在北京，而你的朋友的钱是存在上海，所以我们依然无法保证他们能同时成功。<br><img src="/2021/03/07/a60edbd9d3938850b99a37f0c095d99b/1615076713991.png"></p><h3><span id="分布式事务的基础">分布式事务的基础</span></h3><p>从上面来看分布式事务是随着互联网高速发展应运而生的，这是一个必然。</p><p>我们之前说过数据库的 ACID 四大特性，已经无法满足我们分布式事务，这个时候又有一些新的大佬提出一些新的理论。</p><p>CAP</p><p>CAP 定理，又被叫作布鲁尔定理。对于设计分布式系统(不仅仅是分布式事务)的架构师来说，CAP 就是你的入门理论。</p><p>C (一致性)：对某个指定的客户端来说，读操作能返回最新的写操作。</p><p>对于数据分布在不同节点上的数据来说，如果在某个节点更新了数据，那么在其他节点如果都能读取到这个最新的数据，那么就称为强一致，如果有某个节点没有读取到，那就是分布式不一致。</p><p>A (可用性)：非故障的节点在合理的时间内返回合理的响应(不是错误和超时的响应)。可用性的两个关键一个是合理的时间，一个是合理的响应。</p><p>合理的时间指的是请求不能无限被阻塞，应该在合理的时间给出返回。合理的响应指的是系统应该明确返回结果并且结果是正确的，这里的正确指的是比如应该返回 50，而不是返回 40。</p><p>P (分区容错性)：当出现网络分区后，系统能够继续工作。打个比方，这里集群有多台机器，有台机器网络出现了问题，但是这个集群仍然可以正常工作。</p><p>熟悉 CAP 的人都知道，三者不能共有，如果感兴趣可以搜索 CAP 的证明，在分布式系统中，网络无法 100% 可靠，分区其实是一个必然现象。</p><p>如果我们选择了 CA 而放弃了 P，那么当发生分区现象时，为了保证一致性，这个时候必须拒绝请求，但是 A 又不允许，所以分布式系统理论上不可能选择 CA 架构，只能选择 CP 或者 AP 架构。</p><p>对于 CP 来说，放弃可用性，追求一致性和分区容错性，我们的 ZooKeeper 其实就是追求的强一致。</p><p>对于 AP 来说，放弃一致性(这里说的一致性是强一致性)，追求分区容错性和可用性，这是很多分布式系统设计时的选择，后面的 BASE 也是根据 AP 来扩展。</p><p>顺便一提，CAP 理论中是忽略网络延迟，也就是当事务提交时，从节点 A 复制到节点 B 没有延迟，但是在现实中这个是明显不可能的，所以总会有一定的时间是不一致。</p><p>同时 CAP 中选择两个，比如你选择了 CP，并不是叫你放弃 A。因为 P 出现的概率实在是太小了，大部分的时间你仍然需要保证 CA。</p><p>就算分区出现了你也要为后来的 A 做准备，比如通过一些日志的手段，是其他机器回复至可用。</p><p>BASE</p><p>BASE 是 Basically Available(基本可用)、Soft state(软状态)和 Eventually consistent (最终一致性)三个短语的缩写，是对 CAP 中 AP 的一个扩展。</p><p>基本可用：分布式系统在出现故障时，允许损失部分可用功能，保证核心功能可用。</p><p>软状态：允许系统中存在中间状态，这个状态不影响系统可用性，这里指的是 CAP 中的不一致。</p><p>最终一致：最终一致是指经过一段时间后，所有节点数据都将会达到一致。</p><p>BASE 解决了 CAP 中理论没有网络延迟，在 BASE 中用软状态和最终一致，保证了延迟后的一致性。</p><p>BASE 和 ACID 是相反的，它完全不同于 ACID 的强一致性模型，而是通过牺牲强一致性来获得可用性，并允许数据在一段时间内是不一致的，但最终达到一致状态。</p><h3><span id="分布式事务解决方案">分布式事务解决方案</span></h3><p>有了上面的理论基础后，这里开始介绍几种常见的分布式事务的解决方案。</p><h4><span id="是否真的要分布式事务">是否真的要分布式事务</span></h4><p>  在说方案之前，首先你一定要明确你是否真的需要分布式事务？<br>上面说过出现分布式事务的两个原因，其中有个原因是因为微服务过多。我见过太多团队一个人维护几个微服务，太多团队过度设计，搞得所有人疲劳不堪。</p><p>而微服务过多就会引出分布式事务，这个时候我不会建议你去采用下面任何一种方案，而是请把需要事务的微服务聚合成一个单机服务，使用数据库的本地事务。</p><p>因为不论任何一种方案都会增加你系统的复杂度，这样的成本实在是太高了，千万不要因为追求某些设计，而引入不必要的成本和复杂度。</p><p>如果你确定需要引入分布式事务可以看看下面几种常见的方案。</p><ul><li>2PC<br>说到 2PC 就不得不聊数据库分布式事务中的 XA Transactions。<br><img src="/2021/03/07/a60edbd9d3938850b99a37f0c095d99b/1615076842932.jpg"></li></ul><p>在 XA 协议中分为两阶段：<br>事务管理器要求每个涉及到事务的数据库预提交(precommit)此操作，并反映是否可以提交。<br>事务协调器要求每个数据库提交数据，或者回滚数据。</p><p>优点：<br>尽量保证了数据的强一致，实现成本较低，在各大主流数据库都有自己实现，对于 MySQL 是从 5.5 开始支持。</p><p>缺点：<br>单点问题：事务管理器在整个流程中扮演的角色很关键，如果其宕机，比如在第一阶段已经完成，在第二阶段正准备提交的时候事务管理器宕机，资源管理器就会一直阻塞，导致数据库无法使用。<br>同步阻塞：在准备就绪之后，资源管理器中的资源一直处于阻塞，直到提交完成，释放资源。<br>数据不一致：两阶段提交协议虽然为分布式数据强一致性所设计，但仍然存在数据不一致性的可能。<br>比如在第二阶段中，假设协调者发出了事务 Commit 的通知，但是因为网络问题该通知仅被一部分参与者所收到并执行了 Commit 操作，其余的参与者则因为没有收到通知一直处于阻塞状态，这时候就产生了数据的不一致性。</p><p>总的来说，XA 协议比较简单，成本较低，但是其单点问题，以及不能支持高并发(由于同步阻塞)依然是其最大的弱点。</p><ul><li>TCC<br>关于 TCC（Try-Confirm-Cancel）的概念，最早是由 Pat Helland 于 2007 年发表的一篇名为《Life beyond Distributed Transactions：an Apostate’s Opinion》的论文提出。 </li></ul><p>TCC 事务机制相比于上面介绍的 XA，解决了如下几个缺点：<br>解决了协调者单点，由主业务方发起并完成这个业务活动。业务活动管理器也变成多点，引入集群。<br>同步阻塞：引入超时，超时后进行补偿，并且不会锁定整个资源，将资源转换为业务逻辑形式，粒度变小。<br>数据一致性，有了补偿机制之后，由业务活动管理器控制一致性。</p><p>对于 TCC 的解释：<br>Try 阶段：尝试执行，完成所有业务检查（一致性），预留必需业务资源（准隔离性）。<br>Confirm 阶段：确认真正执行业务，不作任何业务检查，只使用 Try 阶段预留的业务资源，Confirm 操作满足幂等性。要求具备幂等设计，Confirm 失败后需要进行重试。<br>Cancel 阶段：取消执行，释放 Try 阶段预留的业务资源，Cancel 操作满足幂等性。Cancel 阶段的异常和 Confirm 阶段异常处理方案基本上一致。<br><img src="/2021/03/07/a60edbd9d3938850b99a37f0c095d99b/1615076877134.jpg"><br>举个简单的例子：如果你用 100 元买了一瓶水， Try 阶段：你需要向你的钱包检查是否够 100 元并锁住这 100 元，水也是一样的。</p><p>如果有一个失败，则进行 Cancel(释放这 100 元和这一瓶水)，如果 Cancel 失败不论什么失败都进行重试 Cancel，所以需要保持幂等。</p><p>如果都成功，则进行 Confirm，确认这 100 元被扣，和这一瓶水被卖，如果 Confirm 失败无论什么失败则重试(会依靠活动日志进行重试)。</p><p>对于 TCC 来说适合一些：<br>强隔离性，严格一致性要求的活动业务。<br>执行时间较短的业务。</p><p>实现参考：<a href="https://github.com/liuyangming/ByteTCC/%E3%80%82">https://github.com/liuyangming/ByteTCC/。</a></p><ul><li>本地消息表</li></ul><p>本地消息表这个方案最初是 eBay 提出的，eBay 的完整方案 <a href="https://queue.acm.org/detail.cfm?id=1394128%E3%80%82">https://queue.acm.org/detail.cfm?id=1394128。</a></p><p>此方案的核心是将需要分布式处理的任务通过消息日志的方式来异步执行。消息日志可以存储到本地文本、数据库或消息队列，再通过业务规则自动或人工发起重试。</p><p>人工重试更多的是应用于支付场景，通过对账系统对事后问题的处理。<br><img src="/2021/03/07/a60edbd9d3938850b99a37f0c095d99b/1615076898251.jpg"><br>对于本地消息队列来说核心是把大事务转变为小事务。还是举上面用 100 元去买一瓶水的例子。</p><ol><li><p>当你扣钱的时候，你需要在你扣钱的服务器上新增加一个本地消息表，你需要把你扣钱和减去水的库存写入到本地消息表，放入同一个事务(依靠数据库本地事务保证一致性）。</p></li><li><p>这个时候有个定时任务去轮询这个本地事务表，把没有发送的消息，扔给商品库存服务器，叫它减去水的库存，到达商品服务器之后，这时得先写入这个服务器的事务表，然后进行扣减，扣减成功后，更新事务表中的状态。</p></li><li><p>商品服务器通过定时任务扫描消息表或者直接通知扣钱服务器，扣钱服务器在本地消息表进行状态更新。</p></li><li><p>针对一些异常情况，定时扫描未成功处理的消息，进行重新发送，在商品服务器接到消息之后，首先判断是否是重复的。</p></li></ol><p>如果已经接收，再判断是否执行，如果执行在马上又进行通知事务；如果未执行，需要重新执行由业务保证幂等，也就是不会多扣一瓶水。</p><p>本地消息队列是 BASE 理论，是最终一致模型，适用于对一致性要求不高的情况。实现这个模型时需要注意重试的幂等。</p><ul><li>MQ 事务</li></ul><p>在 RocketMQ 中实现了分布式事务，实际上是对本地消息表的一个封装，将本地消息表移动到了 MQ 内部。</p><p>下面简单介绍一下MQ事务，如果想对其详细了解可以参考：<a href="https://www.jianshu.com/p/453c6e7ff81c%E3%80%82">https://www.jianshu.com/p/453c6e7ff81c。</a><br><img src="/2021/03/07/a60edbd9d3938850b99a37f0c095d99b/1615076941115.jpg"></p><p>基本流程如下：<br>第一阶段 Prepared 消息，会拿到消息的地址。<br>第二阶段执行本地事务。<br>第三阶段通过第一阶段拿到的地址去访问消息，并修改状态。消息接受者就能使用这个消息。</p><p>如果确认消息失败，在 RocketMQ Broker 中提供了定时扫描没有更新状态的消息。</p><p>如果有消息没有得到确认，会向消息发送者发送消息，来判断是否提交，在 RocketMQ 中是以 Listener 的形式给发送者，用来处理。 </p><p><img src="/2021/03/07/a60edbd9d3938850b99a37f0c095d99b/1615076947158.jpg"></p><p>如果消费超时，则需要一直重试，消息接收端需要保证幂等。如果消息消费失败，这时就需要人工进行处理，因为这个概率较低，如果为了这种小概率时间而设计这个复杂的流程反而得不偿失。</p><ul><li>Saga 事务</li></ul><p>Saga 是 30 年前一篇数据库伦理提到的一个概念。其核心思想是将长事务拆分为多个本地短事务，由 Saga 事务协调器协调，如果正常结束那就正常完成，如果某个步骤失败，则根据相反顺序一次调用补偿操作。</p><p>Saga 的组成：每个 Saga 由一系列 sub-transaction Ti 组成，每个 Ti 都有对应的补偿动作 Ci，补偿动作用于撤销 Ti 造成的结果。这里的每个 T，都是一个本地事务。</p><p>可以看到，和 TCC 相比，Saga 没有“预留 try”动作，它的 Ti 就是直接提交到库。</p><p>Saga 的执行顺序有两种：<br>T1，T2，T3，…，Tn。<br>T1，T2，…，Tj，Cj，…，C2，C1，其中 0 &lt; j &lt; n 。</p><p>Saga 定义了两种恢复策略：<br>向后恢复，即上面提到的第二种执行顺序，其中 j 是发生错误的 sub-transaction，这种做法的效果是撤销掉之前所有成功的 sub-transation，使得整个 Saga 的执行结果撤销。<br>向前恢复，适用于必须要成功的场景，执行顺序是类似于这样的：T1，T2，…，Tj(失败)，Tj(重试)，…，Tn，其中 j 是发生错误的 sub-transaction。该情况下不需要 Ci。</p><p>这里要注意的是，在 Saga 模式中不能保证隔离性，因为没有锁住资源，其他事务依然可以覆盖或者影响当前事务。</p><p>还是拿 100 元买一瓶水的例子来说，这里定义：<br>T1 = 扣 100 元，T2 = 给用户加一瓶水，T3 = 减库存一瓶水。<br>C1 = 加100元，C2 = 给用户减一瓶水，C3 = 给库存加一瓶水。</p><p>我们一次进行 T1，T2，T3 如果发生问题，就执行发生问题的 C 操作的反向。</p><p>上面说到的隔离性的问题会出现在，如果执行到 T3 这个时候需要执行回滚，但是这个用户已经把水喝了(另外一个事务)，回滚的时候就会发现，无法给用户减一瓶水了。</p><p>这就是事务之间没有隔离性的问题。可以看见 Saga 模式没有隔离性的影响还是较大，可以参照华为的解决方案：从业务层面入手加入一 Session 以及锁的机制来保证能够串行化操作资源。</p><p>也可以在业务层面通过预先冻结资金的方式隔离这部分资源， 最后在业务操作的过程中可以通过及时读取当前状态的方式获取到最新的更新。（具体实例：可以参考华为的 Service Comb）</p><h3><span id="最后">最后</span></h3><p>还是那句话，能不用分布式事务就不用，如果非得使用的话，结合自己的业务分析，看看自己的业务比较适合哪一种，是在乎强一致，还是最终一致即可。</p><p>最后在总结一些问题，大家可以下来自己从文章找寻答案：<br>ACID 和 CAP 的 CA 是一样的吗？<br>分布式事务常用的解决方案的优缺点是什么？适用于什么场景？<br>分布式事务出现的原因？用来解决什么痛点？</p>]]></content>
      
      
      
        <tags>
            
            <tag> 分布式事务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>事务性发件箱模式(outbox pattern)</title>
      <link href="2021/03/07/daf4af28cde06af0a37065cd2877ffa8/"/>
      <url>2021/03/07/daf4af28cde06af0a37065cd2877ffa8/</url>
      
        <content type="html"><![CDATA[<h3><span id="1">1</span></h3><p>基于微服务架构模式（当然不限于）的应用系统，常常会利用消息中间件（kafka,rabbitmq等）来实现各个微服务之间的通信。对于用户的某个操作，一个微服务可能需要执行“存数据库”和“发送event”两个步骤。</p><p>举个例子，用户创建一个订单，订单服务需要存数据库和发送订单created event，如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">begin transactionsave(order) to dbsend(order_created_event) to kafkacommit/rollback</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>对于上面这个例子，由于牵扯到两个系统，数据库事务和kafka事务并不能保证整个操作的事务性（ACID），至多能保证各个子系统的事务性，最终可能导致出现如下数据不一致的情况：</p><p>1.发送event成功，然后commit到数据库失败（原因可能是数据库不available，或者是违反数据库表的constraints）。<br>2.发送event成功到commit到数据库之间有一定延迟，如果consumer消费到event，接着call订单服务查找这个order，结果就可能会查不到。<br>有同学会说，可以把发送event放在存数据库transaction后面，如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">begin transactionsave(order) to dbcommit/rollbacksend(order_created_event) to kafka</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>即使这样，又会出现另外一种不一致的情况，即：存数据库成功，发event失败，比如由于kafka临时不available。这直接导致用户的操作失败，必须要重新提交请求，在某些场景下对用户来说可能是不可接受的；并且数据库里面还有一条脏数据存在。</p><p>那么，如何保证存数据库和发event是一个transaction呢？</p><p>其实，抽象这个问题，其本质就是一个分布式事务问题，如何实现分布式事务，网上有很多文章介绍，可能最常被提到的就是两阶段提交2PC（2 phase commit），但其需要各个子系统都支持两阶段提交协议（比如XA），很多数据库都有支持，但是很多消息中间件都不支持，所以2PC不适用这里的场景，并且由于2PC的一些缺点（参见我的另外一篇文章：关于分布式系统数据一致性的那些事(二)），它并不是实现分布式事务的常规选择。</p><p>基于此，这里介绍的发件箱模式可以有效地解决这个问题。</p><h3><span id="2">2</span></h3><p>发件箱模式，简单讲就是在数据库里面额外增加一个outbox表用于存储需要发送的event，把直接发送event的步骤换成先把event存储到数据库outbox表；另外，程序启动一个scheduler job不断去抓取outbox表里面的记录，发送给Kafka，最后删除发送成功的记录。如下：</p><p>主逻辑：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">begin transactionsave(order) to dbsave(order_created_event) to db outboxcommit/rollback</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>scheduler job:</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">begin transactionget(order_created_event) from db outboxsend(order_created_event) to kafkadelete(order_created_event) to db outboxcommit/rollback</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>基于这样的实现，存order和event就可以通过数据库的transaction来保障，这样即使是Kafka不available，也不影响用户的行为，只是说后续处理可能会有一些延迟而已；此外，如果scheduler job删除event失败，最坏的行为也就是重新再发一次这个event，即是重发消息的问题，这就需要消费端实现幂等性处理。</p><h3><span id="3">3</span></h3><p>发件箱模式主要有两种实现方式：</p><ul><li>Transaction log tailing</li><li> Polling publisher<br>Transaction log tailing，又称CDC（change data capture），就是依赖于数据库的transaction log，一般数据库在成功执行完一条语句之后就会记录一条log，那么这个方式就是不断地增量抓取数据库log，然后发送到消息系统。目前，已经有一些支持这种方式的open source可以直接使用，比如：Debezium。另外，采用这种方式，可能需要数据库装相关的插件以支持CDC。</li></ul><p>Polling publisher，其实就是自己实现一个轮询的sheduler job，不断抓取outbox表里面的event，然后发送到消息系统，最后删除event。在实现层面，可能需要注意下面几点：</p><p>1.一般来说，为了保证event的顺序，在抓取event的时候，需要把event按时间排序。<br>2.如果是分布式的环境，为了保证scheduler job同时只在一个instance上run，需要实现分布式锁；或者借助于成熟的scheduling的library，比如：quartz。</p><p><strong>相关阅读</strong><br><a href="https://cloud.tencent.com/developer/article/1717136">https://cloud.tencent.com/developer/article/1717136</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构-红黑树</title>
      <link href="2021/03/06/b2b003c3fefd870558871e2ed5df6371/"/>
      <url>2021/03/06/b2b003c3fefd870558871e2ed5df6371/</url>
      
        <content type="html"><![CDATA[<h3><span id="红黑树">红黑树</span></h3><p><strong>1.</strong> 红黑树本质上是一种二叉查找树，但它在二叉查找树的基础上额外添加了一个标记（颜色），同时具有一定的规则。**这些规则使红黑树保证了一种平衡，插入、删除、查找的最坏时间复杂度都为 O(logn)。<br><strong>2.</strong> 从根节点到叶节点的路径上黑色节点的个数，叫做树的黑色高度。<br>每个节点要么是红色，要么是黑色；<br>根节点永远是黑色的；<br>所有的叶节点都是是黑色的（注意这里说叶子节点其实是上图中的 NIL 节点）；<br>每个红色节点的两个子节点一定都是黑色；<br>从任一节点到其子树中每个叶子节点的路径都包含相同数量的黑色节点；<br><strong>3.</strong> 各种操作的时间复杂度，能保证在最坏情况下，基本的动态几何操作的时间均为O（lgn）<br>相对于BST和AVL树，红黑树是牺牲了严格的高度平衡的优越条件为代价，能够以O(log2n)的时间复杂度进行搜索、插入、删除操作。最坏情况下，查找（O(lgn)）比二叉排序树快O(n)。较于AVL树，红黑树在数据较乱时查找要更快。<br><strong>4.</strong> 与哈希表对比，哈希的内存需求更大，map查找log(n)级别。当数据是静态的时候使用哈希，数据需要动态维护则使用红黑树比较好。比如Linux内核系统使用红黑树维护内存块</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>nc常用命令</title>
      <link href="2021/03/02/52b4e462c1ebf539d53e74fbae013ca1/"/>
      <url>2021/03/02/52b4e462c1ebf539d53e74fbae013ca1/</url>
      
        <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/u014774781/article/details/52151038">https://blog.csdn.net/u014774781/article/details/52151038</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>tcpdump</title>
      <link href="2021/03/02/a22db6b9984d48fcdf4adcc9ff16c659/"/>
      <url>2021/03/02/a22db6b9984d48fcdf4adcc9ff16c659/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.jianshu.com/p/a57a5b0e58f0">https://www.jianshu.com/p/a57a5b0e58f0</a><br><a href="https://blog.csdn.net/nanyun2010/article/details/23445223">https://blog.csdn.net/nanyun2010/article/details/23445223</a><br><a href="https://wenku.baidu.com/view/fc8342ddce2f0066f5332283.html">https://wenku.baidu.com/view/fc8342ddce2f0066f5332283.html</a><br><a href="https://www.cnblogs.com/kuikuitage/p/13270264.html">https://www.cnblogs.com/kuikuitage/p/13270264.html</a><br><a href="https://www.jianshu.com/p/3cca9a74927c">https://www.jianshu.com/p/3cca9a74927c</a></p><h3><span id="tcpdump安装">tcpdump安装</span></h3><p>在mac上</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install tcpdump</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>wireshark</title>
      <link href="2021/03/02/ec7553e42cad6f1007645ba062f7e8ee/"/>
      <url>2021/03/02/ec7553e42cad6f1007645ba062f7e8ee/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/mq0036/p/11187138.html">https://www.cnblogs.com/mq0036/p/11187138.html</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>GoReleaser使用</title>
      <link href="2021/03/01/991f0158209ad541ac82dc152b72e721/"/>
      <url>2021/03/01/991f0158209ad541ac82dc152b72e721/</url>
      
        <content type="html"><![CDATA[<p>如果还在手动发布 release ，那么就又掉 low 了。使用 GoReleaser 一行命令来发布一个漂亮的 release吧。<br>由于使用的的 MacOS ，这里使用 brew 来安装：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install goreleaser</span><br></pre></td></tr></tbody></table></figure><p>在项目根目录生成 .goreleaser.yml 配置：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">goreleaser init</span><br></pre></td></tr></tbody></table></figure><p>配置好了以后要记得往 .gitignore 加上 dist，因为 goreleaser 会默认把编译编译好的文件输出到 dist 目录中。<br>注意： 首次使用 goreleaser 要配置 GITHUB_TOKEN ，可以在这里申请，申请好之后运行下面的命令配置 GITHUB_TOKEN</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">获取 Github Token：访问 Settings / Developer Settings / Personal access tokens，点击 Generate new token 按钮，生成一个新的 Token。</span><br><span class="line">export GITHUB_TOKEN=&lt;YOUR_TOKEN&gt;</span><br></pre></td></tr></tbody></table></figure><p>确保没有问题，那么就可以操作 git 和 goreleaser 来发布 release 了。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m "add goreleaser"</span><br><span class="line">git tag -a v0.0.1 -m "First release"</span><br><span class="line">git push origin master</span><br><span class="line">git push origin v0.0.1</span><br></pre></td></tr></tbody></table></figure><p>全部搞定后，一行命令起飞：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">如果项目目录没有 dist 目录，可以不加 --rm-dist 参数，执行完成后将生成如下文件结构</span><br><span class="line">goreleaser或者 goreleaser --rm-dis </span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>当看到 release succeeded after 12.93s 时说明以及发布成功了，现在可以访问你的项目查看是否发布成功了。</p><p><img src="/2021/03/01/991f0158209ad541ac82dc152b72e721/1614598202924.png"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>leetcode-4</title>
      <link href="2021/02/27/5553066b36a726fbc88d19e6f718dfb9/"/>
      <url>2021/02/27/5553066b36a726fbc88d19e6f718dfb9/</url>
      
        <content type="html"><![CDATA[<h2><span id="4-median-of-two-sorted-arrays">4. Median of Two Sorted Arrays</span></h2><h3><span id="题目大意">题目大意</span></h3><p>给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。<br>请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。<br>你可以假设 nums1 和 nums2 不会同时为空。</p><h3><span id="解题思路">解题思路</span></h3><p>1.给出两个有序数组，要求找出这两个数组合并以后的有序数组中的中位数。要求时间复杂度为 O(log (m+n))。<br>2.这一题最容易想到的办法是把两个数组合并，然后取出中位数。但是合并有序数组的操作是 O(max(n,m)) 的，不符合题意。看到题目给的 log 的时间复杂度，很容易联想到二分搜索。<br>3.由于要找到最终合并以后数组的中位数，两个数组的总大小也知道，所以中间这个位置也是知道的。只需要二分搜索一个数组中切分的位置，另一个数组中切分的位置也能得到。为了使得时间复杂度最小，所以二分搜索两个数组中长度较小的那个数组。<br>4.关键的问题是如何切分数组 1 和数组 2 。其实就是如何切分数组 1 。先随便二分产生一个 midA，切分的线何时算满足了中位数的条件呢？即，线左边的数都小于右边的数，即，nums1[midA-1] ≤ nums2[midB] &amp;&amp; nums2[midB-1] ≤ nums1[midA] 。如果这些条件都不满足，切分线就需要调整。如果 nums1[midA] &lt; nums2[midB-1]，说明 midA 这条线划分出来左边的数小了，切分线应该右移；如果 nums1[midA-1] &gt; nums2[midB]，说明 midA 这条线划分出来左边的数大了，切分线应该左移。经过多次调整以后，切分线总能找到满足条件的解。<br>5.假设现在找到了切分的两条线了，数组 1 在切分线两边的下标分别是 midA - 1 和 midA。数组 2 在切分线两边的下标分别是 midB - 1 和 midB。最终合并成最终数组，如果数组长度是奇数，那么中位数就是 max(nums1[midA-1], nums2[midB-1])。如果数组长度是偶数，那么中间位置的两个数依次是：max(nums1[midA-1], nums2[midB-1]) 和 min(nums1[midA], nums2[midB])，那么中位数就是 (max(nums1[midA-1], nums2[midB-1]) + min(nums1[midA], nums2[midB])) / 2。图示见下图：</p><h3><span id="解法2-二分法找第k个数">解法2: 二分法（找第k个数）</span></h3><p><img src="/2021/02/27/5553066b36a726fbc88d19e6f718dfb9/1614501186077.png"><br><img src="/2021/02/27/5553066b36a726fbc88d19e6f718dfb9/1614501191914.png"><br><img src="/2021/02/27/5553066b36a726fbc88d19e6f718dfb9/1614501205875.png"><br><img src="/2021/02/27/5553066b36a726fbc88d19e6f718dfb9/1614501214191.png"><br>时间复杂度，尾递归，无需堆栈，空间复杂度</p><h3><span id="代码">代码</span></h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import "log"</span><br><span class="line"></span><br><span class="line">//二分法</span><br><span class="line">//log(m+n)</span><br><span class="line">func findMedianSortedArrays0(nums1 []int, nums2 []int) float64 {</span><br><span class="line">n1 := len(nums1)</span><br><span class="line">n2 := len(nums2)</span><br><span class="line">var length, kth int</span><br><span class="line">length = n1 + n2</span><br><span class="line">kth = (length + 1) / 2</span><br><span class="line">if length%2 != 0 {</span><br><span class="line">return float64(findTopK(nums1, 0, n1-1, nums2, 0, n2-1, kth))</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line">return float64(findTopK(nums1, 0, n1-1, nums2, 0, n2-1, kth)+findTopK(nums1, 0, n1-1, nums2, 0, n2-1, kth+1)) / 2.0</span><br><span class="line">}</span><br><span class="line">func findTopK(nums1 []int, s1, e1 int, nums2 []int, s2, e2 int, topK int) int {</span><br><span class="line">len1 := e1 - s1 + 1</span><br><span class="line">len2 := e2 - s2 + 1</span><br><span class="line">if len1 &gt; len2 {</span><br><span class="line">return findTopK(nums2, s2, e2, nums1, s1, e1, topK)</span><br><span class="line">}</span><br><span class="line">if len1 == 0 {</span><br><span class="line">return nums2[s2+topK-1]</span><br><span class="line">}</span><br><span class="line">if topK == 1 {</span><br><span class="line">return min(nums1[s1], nums2[s2])</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line">i := s1 + min(len1, topK/2) - 1 //min使得指针不会越界</span><br><span class="line">j := s2 + min(len2, topK/2) - 1</span><br><span class="line">if nums1[i] &gt; nums2[j] { //舍去nums2前面的</span><br><span class="line">return findTopK(nums1, s1, e1, nums2, j+1, e2, topK-(j-s2+1))</span><br><span class="line">}</span><br><span class="line">//舍去nums1前面的</span><br><span class="line">return findTopK(nums1, i+1, e1, nums2, s2, e2, topK-(i-s1+1))</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">//log(m+n)</span><br><span class="line">func findMedianSortedArrays(nums1 []int, nums2 []int) float64 {</span><br><span class="line">// 假设 nums1 的长度小</span><br><span class="line">if len(nums1) &gt; len(nums2) {</span><br><span class="line">return findMedianSortedArrays(nums2, nums1)</span><br><span class="line">}</span><br><span class="line">low, high, k, nums1Mid, nums2Mid := 0, len(nums1), (len(nums1)+len(nums2)+1)&gt;&gt;1, 0, 0</span><br><span class="line">for low &lt;= high {</span><br><span class="line">// nums1:  ……………… nums1[nums1Mid-1] | nums1[nums1Mid] ……………………</span><br><span class="line">// nums2:  ……………… nums2[nums2Mid-1] | nums2[nums2Mid] ……………………</span><br><span class="line">nums1Mid = low + (high-low)&gt;&gt;1 // 分界限右侧是 mid，分界线左侧是 mid - 1</span><br><span class="line">nums2Mid = k - nums1Mid</span><br><span class="line">if nums1Mid &gt; 0 &amp;&amp; nums1[nums1Mid-1] &gt; nums2[nums2Mid] { // nums1 中的分界线划多了，要向左边移动</span><br><span class="line">high = nums1Mid - 1</span><br><span class="line">} else if nums1Mid != len(nums1) &amp;&amp; nums1[nums1Mid] &lt; nums2[nums2Mid-1] { // nums1 中的分界线划少了，要向右边移动</span><br><span class="line">low = nums1Mid + 1</span><br><span class="line">} else {</span><br><span class="line">// 找到合适的划分了，需要输出最终结果了</span><br><span class="line">// 分为奇数偶数 2 种情况</span><br><span class="line">break</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">midLeft, midRight := 0, 0</span><br><span class="line">if nums1Mid == 0 {</span><br><span class="line">midLeft = nums2[nums2Mid-1]</span><br><span class="line">} else if nums2Mid == 0 {</span><br><span class="line">midLeft = nums1[nums1Mid-1]</span><br><span class="line">} else {</span><br><span class="line">midLeft = max(nums1[nums1Mid-1], nums2[nums2Mid-1])</span><br><span class="line">}</span><br><span class="line">if (len(nums1)+len(nums2))&amp;1 == 1 {</span><br><span class="line">return float64(midLeft)</span><br><span class="line">}</span><br><span class="line">if nums1Mid == len(nums1) {</span><br><span class="line">midRight = nums2[nums2Mid]</span><br><span class="line">} else if nums2Mid == len(nums2) {</span><br><span class="line">midRight = nums1[nums1Mid]</span><br><span class="line">} else {</span><br><span class="line">midRight = min(nums1[nums1Mid], nums2[nums2Mid])</span><br><span class="line">}</span><br><span class="line">return float64(midLeft+midRight) / 2</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func min(n1, n2 int) int {</span><br><span class="line">if n1 &gt; n2 {</span><br><span class="line">return n2</span><br><span class="line">}</span><br><span class="line">return n1</span><br><span class="line">}</span><br><span class="line">func max(n1, n2 int) int {</span><br><span class="line">if n1 &gt; n2 {</span><br><span class="line">return n1</span><br><span class="line">}</span><br><span class="line">return n2</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">//O(m+n)</span><br><span class="line">//把问题转化成从2个数组里面找出第N小的数。</span><br><span class="line">//nums1，nums2按顺序对比</span><br><span class="line">//1.2个数组的index,k,j都从0开始。</span><br><span class="line">//2.nums1[j]，nums2[k]对比</span><br><span class="line">//3.小的一方index加一(k++或者j++)</span><br><span class="line">//4.如果k+j == 中间数字的index，且中位数就是一个数则则直接返回</span><br><span class="line">//5.重复2步骤</span><br><span class="line">func findMedianSortedArrays_(nums1 []int, nums2 []int) float64 {</span><br><span class="line">l := len(nums1) + len(nums2)</span><br><span class="line">j, k := 0, 0</span><br><span class="line">var (</span><br><span class="line">l1 int</span><br><span class="line">l2 int</span><br><span class="line">)</span><br><span class="line">value := make([]int, 0, 2)</span><br><span class="line">isSingle := l%2 != 0</span><br><span class="line">if l%2 != 0 {</span><br><span class="line">l1 = l/2 + 1</span><br><span class="line">l2 = l/2 + 1</span><br><span class="line">} else {</span><br><span class="line">l1 = l / 2</span><br><span class="line">l2 = l/2 + 1</span><br><span class="line">}</span><br><span class="line">if len(nums2) == 0 {</span><br><span class="line">return float64(nums1[l1]+nums1[l2]) / 2</span><br><span class="line">}</span><br><span class="line">if len(nums1) == 0 {</span><br><span class="line">return float64(nums2[l1]+nums2[l2]) / 2</span><br><span class="line">}</span><br><span class="line">for i := 0; i &lt; l; i++ {</span><br><span class="line">var v int</span><br><span class="line">if k == len(nums2) {</span><br><span class="line">v = nums1[j]</span><br><span class="line">j++</span><br><span class="line">} else if j == len(nums1) {</span><br><span class="line">v = nums2[k]</span><br><span class="line">k++</span><br><span class="line">} else if nums1[j] &gt; nums2[k] {</span><br><span class="line">v = nums2[k]</span><br><span class="line">k++</span><br><span class="line">} else {</span><br><span class="line">v = nums1[j]</span><br><span class="line">j++</span><br><span class="line">}</span><br><span class="line">if k+j == l1 || k+j == l2 {</span><br><span class="line">value = append(value, v)</span><br><span class="line">if isSingle {</span><br><span class="line">return float64(v)</span><br><span class="line">}</span><br><span class="line">if len(value) == 2 {</span><br><span class="line">return float64(value[0]+value[1]) / 2</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">return 0</span><br><span class="line">}</span><br><span class="line">func getSlice1() ([]int, []int) {</span><br><span class="line">a := make([]int, 0, 100)</span><br><span class="line">for i := 0; i &lt; 100; i++ {</span><br><span class="line">a = append(a, i+3)</span><br><span class="line">}</span><br><span class="line">b := make([]int, 0, 100)</span><br><span class="line">for i := 30; i &lt; 100; i++ {</span><br><span class="line">b = append(b, i+2)</span><br><span class="line">}</span><br><span class="line">return a, b</span><br><span class="line">}</span><br><span class="line">func main() {</span><br><span class="line">a, b := getSlice1()</span><br><span class="line">log.Println(findMedianSortedArrays(a, b))</span><br><span class="line">log.Println(findMedianSortedArrays_(a, b))</span><br><span class="line">log.Println(findMedianSortedArrays0(a, b))</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode-3</title>
      <link href="2021/02/27/74e6ac6c20c9e0aae3166a9742482b57/"/>
      <url>2021/02/27/74e6ac6c20c9e0aae3166a9742482b57/</url>
      
        <content type="html"><![CDATA[<h2><span id="3longest-substring-without-repeating-characters">3.Longest Substring Without Repeating Characters</span></h2><h3><span id="题目大意">题目大意</span></h3><p>在一个字符串重寻找没有重复字母的最长子串。</p><h3><span id="解题思路">解题思路</span></h3><p>这一题和第 438 题，第 3 题，第 76 题，第 567 题类似，用的思想都是”滑动窗口”。</p><p>滑动窗口的右边界不断的右移，只要没有重复的字符，就持续向右扩大窗口边界。一旦出现了重复字符，就需要缩小左边界，直到重复的字符移出了左边界，然后继续移动滑动窗口的右边界。以此类推，每次移动需要计算当前长度，并判断是否需要更新最大长度，最终最大的值就是题目中的所求。</p><h3><span id="代码">代码</span></h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">package leetcode</span><br><span class="line"></span><br><span class="line">// 解法一 位图</span><br><span class="line">func lengthOfLongestSubstring(s string) int {</span><br><span class="line">if len(s) == 0 {</span><br><span class="line">return 0</span><br><span class="line">}</span><br><span class="line">var bitSet [256]bool</span><br><span class="line">result, left, right := 0, 0, 0</span><br><span class="line">for left &lt; len(s) {</span><br><span class="line">// 右侧字符对应的 bitSet 被标记 true，说明此字符在 X 位置重复，需要左侧向前移动，直到将X标记为 false</span><br><span class="line">if bitSet[s[right]] {</span><br><span class="line">bitSet[s[left]] = false</span><br><span class="line">left++</span><br><span class="line">} else {</span><br><span class="line">bitSet[s[right]] = true</span><br><span class="line">right++</span><br><span class="line">}</span><br><span class="line">if result &lt; right-left {</span><br><span class="line">result = right - left</span><br><span class="line">}</span><br><span class="line">if left+result &gt;= len(s) || right &gt;= len(s) {</span><br><span class="line">break</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">return result</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 解法二 滑动窗口</span><br><span class="line">func lengthOfLongestSubstring_(s string) int {</span><br><span class="line">if len(s) == 0 {</span><br><span class="line">return 0</span><br><span class="line">}</span><br><span class="line">var freq [256]int</span><br><span class="line">result, left, right := 0, 0, -1</span><br><span class="line"></span><br><span class="line">for left &lt; len(s) {</span><br><span class="line">if right+1 &lt; len(s) &amp;&amp; freq[s[right+1]-'a'] == 0 {</span><br><span class="line">freq[s[right+1]-'a']++</span><br><span class="line">right++</span><br><span class="line">} else {</span><br><span class="line">freq[s[left]-'a']--</span><br><span class="line">left++</span><br><span class="line">}</span><br><span class="line">result = max(result, right-left+1)</span><br><span class="line">}</span><br><span class="line">return result</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func max(a int, b int) int {</span><br><span class="line">if a &gt; b {</span><br><span class="line">return a</span><br><span class="line">}</span><br><span class="line">return b</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>embed</title>
      <link href="2021/02/26/269605d45c104f12cbcdc8fb71434acc/"/>
      <url>2021/02/26/269605d45c104f12cbcdc8fb71434acc/</url>
      
        <content type="html"><![CDATA[<p>github.com/alecthomas/gobundle<br>github.com/GeertJohan/go.rice<br>github.com/go-playground/statics<br>github.com/gobuffalo/packr<br>github.com/knadh/stuffbin<br>github.com/mjibson/esc<br>github.com/omeid/go-resources<br>github.com/phogolabs/parcello<br>github.com/pyros2097/go-embed<br>github.com/rakyll/statik<br>github.com/shurcooL/vfsgen<br>github.com/UnnoTed/fileb0x<br>github.com/wlbr/templify<br>perkeep.org/pkg/fileembed</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>leetcode-2</title>
      <link href="2021/02/25/4015385173cdec709f7b29132a4aecb7/"/>
      <url>2021/02/25/4015385173cdec709f7b29132a4aecb7/</url>
      
        <content type="html"><![CDATA[<h2><span id="2-add-two-numbers">2. Add Two Numbers</span></h2><h3><span id="题目">题目</span></h3><p>You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.<br>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p><h3><span id="example">Example:</span></h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</span><br><span class="line">Output: 7 -&gt; 0 -&gt; 8</span><br><span class="line">Explanation: 342 + 465 = 807.</span><br></pre></td></tr></tbody></table></figure><h3><span id="题目大意">题目大意</span></h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2 个逆序的链表，要求从低位开始相加，得出结果也逆序输出，返回值是逆序结果链表的头结点。</span><br></pre></td></tr></tbody></table></figure><h3><span id="解题思路">解题思路</span></h3><p>需要注意的是各种进位问题。<br>极端情况，例如</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: (9 -&gt; 9 -&gt; 9 -&gt; 9 -&gt; 9) + (1 -&gt; )</span><br><span class="line">Output: 0 -&gt; 0 -&gt; 0 -&gt; 0 -&gt; 0 -&gt; 1</span><br></pre></td></tr></tbody></table></figure><p>为了处理方法统一，可以先建立一个虚拟头结点，这个虚拟头结点的 Next 指向真正的 head，这样 head 不需要单独处理，直接 while 循环即可。另外判断循环终止的条件不用是 p.Next ！= nil，这样最后一位还需要额外计算，循环终止条件应该是 p != nil。</p><h3><span id="代码">代码</span></h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">package leetcode</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * type ListNode struct {</span><br><span class="line"> *     Val int</span><br><span class="line"> *     Next *ListNode</span><br><span class="line"> * }</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode {</span><br><span class="line">head := &amp;ListNode{Val: 0}</span><br><span class="line">n1, n2, carry, current := 0, 0, 0, head</span><br><span class="line">for l1 != nil || l2 != nil || carry != 0 {</span><br><span class="line">if l1 == nil {</span><br><span class="line">n1 = 0</span><br><span class="line">} else {</span><br><span class="line">n1 = l1.Val</span><br><span class="line">l1 = l1.Next</span><br><span class="line">}</span><br><span class="line">if l2 == nil {</span><br><span class="line">n2 = 0</span><br><span class="line">} else {</span><br><span class="line">n2 = l2.Val</span><br><span class="line">l2 = l2.Next</span><br><span class="line">}</span><br><span class="line">current.Next = &amp;ListNode{Val: (n1 + n2 + carry) % 10}</span><br><span class="line">current = current.Next</span><br><span class="line">carry = (n1 + n2 + carry) / 10</span><br><span class="line">}</span><br><span class="line">return head.Next</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode-1</title>
      <link href="2021/02/25/5d84964ee06a5c1e0e57243575abf203/"/>
      <url>2021/02/25/5d84964ee06a5c1e0e57243575abf203/</url>
      
        <content type="html"><![CDATA[<h2><span id="1-two-sum">1. Two Sum</span></h2><h3><span id="题目">题目</span></h3><p>Given an array of integers, return indices of the two numbers such that they add up to a specific target.<br>You may assume that each input would have exactly one solution, and you may not use the same element twice.</p><h3><span id="example">Example:</span></h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Given nums = [2, 7, 11, 15], target = 9,</span><br><span class="line"></span><br><span class="line">Because nums[0] + nums[1] = 2 + 7 = 9,</span><br><span class="line">return [0, 1]</span><br></pre></td></tr></tbody></table></figure><h3><span id="题目大意">题目大意</span></h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在数组中找到 2 个数之和等于给定值的数字，结果返回 2 个数字在数组中的下标。</span><br></pre></td></tr></tbody></table></figure><h3><span id="解题思路">解题思路</span></h3><p>这道题最优的做法时间复杂度是 O(n)。</p><p>顺序扫描数组，对每一个元素，在 map 中找能组合给定值的另一半数字，如果找到了，直接返回 2 个数字的下标即可。如果找不到，就把这个数字存入 map 中，等待扫到“另一半”数字的时候，再取出来返回结果。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package leetcode</span><br><span class="line"></span><br><span class="line">func twoSum(nums []int, target int) []int {</span><br><span class="line">m := make(map[int]int)</span><br><span class="line">for i := 0; i &lt; len(nums); i++ {</span><br><span class="line">another := target - nums[i]</span><br><span class="line">if _, ok := m[another]; ok {</span><br><span class="line">return []int{m[another], i}</span><br><span class="line">}</span><br><span class="line">m[nums[i]] = i</span><br><span class="line">}</span><br><span class="line">return nil</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go-gc</title>
      <link href="2021/02/23/f8683bb1b6d48ad4d7c64f8e99773aa7/"/>
      <url>2021/02/23/f8683bb1b6d48ad4d7c64f8e99773aa7/</url>
      
        <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/qiya2007/article/details/107291497">https://blog.csdn.net/qiya2007/article/details/107291497</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>leetcode-go</title>
      <link href="2021/02/22/b6da184b7188d1c20ff0dff09fe076ac/"/>
      <url>2021/02/22/b6da184b7188d1c20ff0dff09fe076ac/</url>
      
        <content type="html"><![CDATA[<p><a href="https://github.com/halfrost/LeetCode-Go">https://github.com/halfrost/LeetCode-Go</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>k8s集群中docker内go程序优雅重启</title>
      <link href="2021/02/21/89dafdc07867c5811f9be7408b9a2247/"/>
      <url>2021/02/21/89dafdc07867c5811f9be7408b9a2247/</url>
      
        <content type="html"><![CDATA[<p><strong>原地升级功能在sidecar模式中十分有用。</strong><br>将endless稍微进行修改，main.go</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">"crypto/tls"</span><br><span class="line">"errors"</span><br><span class="line">"fmt"</span><br><span class="line">"log"</span><br><span class="line">"net"</span><br><span class="line">"net/http"</span><br><span class="line">"os"</span><br><span class="line">"os/exec"</span><br><span class="line">"os/signal"</span><br><span class="line">"runtime"</span><br><span class="line">"strings"</span><br><span class="line">"sync"</span><br><span class="line">"syscall"</span><br><span class="line">"time"</span><br><span class="line"></span><br><span class="line">"github.com/gin-gonic/gin"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func hello(ctx *gin.Context) {</span><br><span class="line">log.Println("hello")</span><br><span class="line">ctx.JSON(http.StatusOK, "ok")</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">router := gin.New()</span><br><span class="line">v1 := router.Group("/api/v1")</span><br><span class="line">v1.GET("/hello", hello)</span><br><span class="line">s := NewServer(":8080", router)</span><br><span class="line">err := s.ListenAndServe()</span><br><span class="line">if err != nil {</span><br><span class="line">log.Printf("server err: %v", err)</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">const (</span><br><span class="line">PRE_SIGNAL = iota</span><br><span class="line">POST_SIGNAL</span><br><span class="line"></span><br><span class="line">STATE_INIT</span><br><span class="line">STATE_RUNNING</span><br><span class="line">STATE_SHUTTING_DOWN</span><br><span class="line">STATE_TERMINATE</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">var (</span><br><span class="line">runningServerReg     sync.RWMutex</span><br><span class="line">runningServers       map[string]*endlessServer</span><br><span class="line">runningServersOrder  []string</span><br><span class="line">socketPtrOffsetMap   map[string]uint</span><br><span class="line">runningServersForked bool</span><br><span class="line"></span><br><span class="line">DefaultReadTimeOut    time.Duration</span><br><span class="line">DefaultWriteTimeOut   time.Duration</span><br><span class="line">DefaultMaxHeaderBytes int</span><br><span class="line">DefaultHammerTime     time.Duration</span><br><span class="line"></span><br><span class="line">isChild     bool</span><br><span class="line">socketOrder string</span><br><span class="line"></span><br><span class="line">hookableSignals []os.Signal</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func init() {</span><br><span class="line">runningServerReg = sync.RWMutex{}</span><br><span class="line">runningServers = make(map[string]*endlessServer)</span><br><span class="line">runningServersOrder = []string{}</span><br><span class="line">socketPtrOffsetMap = make(map[string]uint)</span><br><span class="line"></span><br><span class="line">DefaultMaxHeaderBytes = 0 // use http.DefaultMaxHeaderBytes - which currently is 1 &lt;&lt; 20 (1MB)</span><br><span class="line"></span><br><span class="line">// after a restart the parent will finish ongoing requests before</span><br><span class="line">// shutting down. set to a negative value to disable</span><br><span class="line">DefaultHammerTime = 60 * time.Second</span><br><span class="line"></span><br><span class="line">hookableSignals = []os.Signal{</span><br><span class="line">syscall.SIGHUP,</span><br><span class="line">syscall.SIGUSR1,</span><br><span class="line">syscall.SIGUSR2,</span><br><span class="line">syscall.SIGINT,</span><br><span class="line">syscall.SIGTERM,</span><br><span class="line">syscall.SIGTSTP,</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">type endlessServer struct {</span><br><span class="line">http.Server</span><br><span class="line">EndlessListener  net.Listener</span><br><span class="line">SignalHooks      map[int]map[os.Signal][]func()</span><br><span class="line">tlsInnerListener *endlessListener</span><br><span class="line">wg               sync.WaitGroup</span><br><span class="line">sigChan          chan os.Signal</span><br><span class="line">isChild          bool</span><br><span class="line">state            uint8</span><br><span class="line">lock             *sync.RWMutex</span><br><span class="line">BeforeBegin      func(add string)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">NewServer returns an intialized endlessServer Object. Calling Serve on it will</span><br><span class="line">actually "start" the server.</span><br><span class="line">*/</span><br><span class="line">func NewServer(addr string, handler http.Handler) (srv *endlessServer) {</span><br><span class="line">runningServerReg.Lock()</span><br><span class="line">defer runningServerReg.Unlock()</span><br><span class="line"></span><br><span class="line">socketOrder = os.Getenv("ENDLESS_SOCKET_ORDER")</span><br><span class="line">isChild = os.Getenv("ENDLESS_CONTINUE") != ""</span><br><span class="line"></span><br><span class="line">if len(socketOrder) &gt; 0 {</span><br><span class="line">for i, addr := range strings.Split(socketOrder, ",") {</span><br><span class="line">socketPtrOffsetMap[addr] = uint(i)</span><br><span class="line">}</span><br><span class="line">} else {</span><br><span class="line">socketPtrOffsetMap[addr] = uint(len(runningServersOrder))</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">srv = &amp;endlessServer{</span><br><span class="line">wg:      sync.WaitGroup{},</span><br><span class="line">sigChan: make(chan os.Signal),</span><br><span class="line">isChild: isChild,</span><br><span class="line">SignalHooks: map[int]map[os.Signal][]func(){</span><br><span class="line">PRE_SIGNAL: map[os.Signal][]func(){</span><br><span class="line">syscall.SIGHUP:  []func(){},</span><br><span class="line">syscall.SIGUSR1: []func(){},</span><br><span class="line">syscall.SIGUSR2: []func(){},</span><br><span class="line">syscall.SIGINT:  []func(){},</span><br><span class="line">syscall.SIGTERM: []func(){},</span><br><span class="line">syscall.SIGTSTP: []func(){},</span><br><span class="line">},</span><br><span class="line">POST_SIGNAL: map[os.Signal][]func(){</span><br><span class="line">syscall.SIGHUP:  []func(){},</span><br><span class="line">syscall.SIGUSR1: []func(){},</span><br><span class="line">syscall.SIGUSR2: []func(){},</span><br><span class="line">syscall.SIGINT:  []func(){},</span><br><span class="line">syscall.SIGTERM: []func(){},</span><br><span class="line">syscall.SIGTSTP: []func(){},</span><br><span class="line">},</span><br><span class="line">},</span><br><span class="line">state: STATE_INIT,</span><br><span class="line">lock:  &amp;sync.RWMutex{},</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">srv.Server.Addr = addr</span><br><span class="line">srv.Server.ReadTimeout = DefaultReadTimeOut</span><br><span class="line">srv.Server.WriteTimeout = DefaultWriteTimeOut</span><br><span class="line">srv.Server.MaxHeaderBytes = DefaultMaxHeaderBytes</span><br><span class="line">srv.Server.Handler = handler</span><br><span class="line"></span><br><span class="line">srv.BeforeBegin = func(addr string) {</span><br><span class="line">log.Println(syscall.Getpid(), addr)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">runningServersOrder = append(runningServersOrder, addr)</span><br><span class="line">runningServers[addr] = srv</span><br><span class="line"></span><br><span class="line">return</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">ListenAndServe listens on the TCP network address addr and then calls Serve</span><br><span class="line">with handler to handle requests on incoming connections. Handler is typically</span><br><span class="line">nil, in which case the DefaultServeMux is used.</span><br><span class="line">*/</span><br><span class="line">func ListenAndServe(addr string, handler http.Handler) error {</span><br><span class="line">server := NewServer(addr, handler)</span><br><span class="line">return server.ListenAndServe()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">ListenAndServeTLS acts identically to ListenAndServe, except that it expects</span><br><span class="line">HTTPS connections. Additionally, files containing a certificate and matching</span><br><span class="line">private key for the server must be provided. If the certificate is signed by a</span><br><span class="line">certificate authority, the certFile should be the concatenation of the server's</span><br><span class="line">certificate followed by the CA's certificate.</span><br><span class="line">*/</span><br><span class="line">func ListenAndServeTLS(addr string, certFile string, keyFile string, handler http.Handler) error {</span><br><span class="line">server := NewServer(addr, handler)</span><br><span class="line">return server.ListenAndServeTLS(certFile, keyFile)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func (srv *endlessServer) getState() uint8 {</span><br><span class="line">srv.lock.RLock()</span><br><span class="line">defer srv.lock.RUnlock()</span><br><span class="line"></span><br><span class="line">return srv.state</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func (srv *endlessServer) setState(st uint8) {</span><br><span class="line">srv.lock.Lock()</span><br><span class="line">defer srv.lock.Unlock()</span><br><span class="line"></span><br><span class="line">srv.state = st</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">Serve accepts incoming HTTP connections on the listener l, creating a new</span><br><span class="line">service goroutine for each. The service goroutines read requests and then call</span><br><span class="line">handler to reply to them. Handler is typically nil, in which case the</span><br><span class="line">DefaultServeMux is used.</span><br><span class="line"></span><br><span class="line">In addition to the stl Serve behaviour each connection is added to a</span><br><span class="line">sync.Waitgroup so that all outstanding connections can be served before shutting</span><br><span class="line">down the server.</span><br><span class="line">*/</span><br><span class="line">func (srv *endlessServer) Serve() (err error) {</span><br><span class="line">defer log.Println(syscall.Getpid(), "Serve() returning...")</span><br><span class="line">srv.setState(STATE_RUNNING)</span><br><span class="line">err = srv.Server.Serve(srv.EndlessListener)</span><br><span class="line">log.Println(syscall.Getpid(), "Waiting for connections to finish...")</span><br><span class="line">srv.wg.Wait()</span><br><span class="line">srv.setState(STATE_TERMINATE)</span><br><span class="line">return</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">ListenAndServe listens on the TCP network address srv.Addr and then calls Serve</span><br><span class="line">to handle requests on incoming connections. If srv.Addr is blank, ":http" is</span><br><span class="line">used.</span><br><span class="line">*/</span><br><span class="line">func (srv *endlessServer) ListenAndServe() (err error) {</span><br><span class="line">addr := srv.Addr</span><br><span class="line">if addr == "" {</span><br><span class="line">addr = ":http"</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">go srv.handleSignals()</span><br><span class="line"></span><br><span class="line">l, err := srv.getListener(addr)</span><br><span class="line">if err != nil {</span><br><span class="line">log.Println(err)</span><br><span class="line">return</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">srv.EndlessListener = newEndlessListener(l, srv)</span><br><span class="line"></span><br><span class="line">if srv.isChild {</span><br><span class="line">syscall.Kill(syscall.Getppid(), syscall.SIGTERM)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">srv.BeforeBegin(srv.Addr)</span><br><span class="line"></span><br><span class="line">return srv.Serve()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">ListenAndServeTLS listens on the TCP network address srv.Addr and then calls</span><br><span class="line">Serve to handle requests on incoming TLS connections.</span><br><span class="line"></span><br><span class="line">Filenames containing a certificate and matching private key for the server must</span><br><span class="line">be provided. If the certificate is signed by a certificate authority, the</span><br><span class="line">certFile should be the concatenation of the server's certificate followed by the</span><br><span class="line">CA's certificate.</span><br><span class="line"></span><br><span class="line">If srv.Addr is blank, ":https" is used.</span><br><span class="line">*/</span><br><span class="line">func (srv *endlessServer) ListenAndServeTLS(certFile, keyFile string) (err error) {</span><br><span class="line">addr := srv.Addr</span><br><span class="line">if addr == "" {</span><br><span class="line">addr = ":https"</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">config := &amp;tls.Config{}</span><br><span class="line">if srv.TLSConfig != nil {</span><br><span class="line">*config = *srv.TLSConfig</span><br><span class="line">}</span><br><span class="line">if config.NextProtos == nil {</span><br><span class="line">config.NextProtos = []string{"http/1.1"}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">config.Certificates = make([]tls.Certificate, 1)</span><br><span class="line">config.Certificates[0], err = tls.LoadX509KeyPair(certFile, keyFile)</span><br><span class="line">if err != nil {</span><br><span class="line">return</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">go srv.handleSignals()</span><br><span class="line"></span><br><span class="line">l, err := srv.getListener(addr)</span><br><span class="line">if err != nil {</span><br><span class="line">log.Println(err)</span><br><span class="line">return</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">srv.tlsInnerListener = newEndlessListener(l, srv)</span><br><span class="line">srv.EndlessListener = tls.NewListener(srv.tlsInnerListener, config)</span><br><span class="line"></span><br><span class="line">if srv.isChild {</span><br><span class="line">syscall.Kill(syscall.Getppid(), syscall.SIGHUP)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">log.Println(syscall.Getpid(), srv.Addr)</span><br><span class="line">return srv.Serve()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">getListener either opens a new socket to listen on, or takes the acceptor socket</span><br><span class="line">it got passed when restarted.</span><br><span class="line">*/</span><br><span class="line">func (srv *endlessServer) getListener(laddr string) (l net.Listener, err error) {</span><br><span class="line">if srv.isChild {</span><br><span class="line">var ptrOffset uint = 0</span><br><span class="line">runningServerReg.RLock()</span><br><span class="line">defer runningServerReg.RUnlock()</span><br><span class="line">if len(socketPtrOffsetMap) &gt; 0 {</span><br><span class="line">ptrOffset = socketPtrOffsetMap[laddr]</span><br><span class="line">// log.Println("laddr", laddr, "ptr offset", socketPtrOffsetMap[laddr])</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">f := os.NewFile(uintptr(3+ptrOffset), "")</span><br><span class="line">l, err = net.FileListener(f)</span><br><span class="line">if err != nil {</span><br><span class="line">err = fmt.Errorf("net.FileListener error: %v", err)</span><br><span class="line">return</span><br><span class="line">}</span><br><span class="line">} else {</span><br><span class="line">l, err = net.Listen("tcp", laddr)</span><br><span class="line">if err != nil {</span><br><span class="line">err = fmt.Errorf("net.Listen error: %v", err)</span><br><span class="line">return</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">return</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">handleSignals listens for os Signals and calls any hooked in function that the</span><br><span class="line">user had registered with the signal.</span><br><span class="line">*/</span><br><span class="line">func (srv *endlessServer) handleSignals() {</span><br><span class="line">var sig os.Signal</span><br><span class="line"></span><br><span class="line">signal.Notify(</span><br><span class="line">srv.sigChan,</span><br><span class="line">hookableSignals...,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">pid := syscall.Getpid()</span><br><span class="line">for {</span><br><span class="line">sig = &lt;-srv.sigChan</span><br><span class="line">srv.signalHooks(PRE_SIGNAL, sig)</span><br><span class="line">switch sig {</span><br><span class="line">case syscall.SIGHUP:</span><br><span class="line">log.Println(pid, "Received SIGHUP. forking.")</span><br><span class="line">srv.shutdown()</span><br><span class="line">//err := srv.fork()</span><br><span class="line">//if err != nil {</span><br><span class="line">//log.Println("Fork err:", err)</span><br><span class="line">//}</span><br><span class="line">case syscall.SIGUSR1:</span><br><span class="line">log.Println(pid, "Received SIGUSR1.")</span><br><span class="line">case syscall.SIGUSR2:</span><br><span class="line">log.Println(pid, "Received SIGUSR2.")</span><br><span class="line">srv.hammerTime(0 * time.Second)</span><br><span class="line">case syscall.SIGINT:</span><br><span class="line">log.Println(pid, "Received SIGINT.")</span><br><span class="line">srv.shutdown()</span><br><span class="line">case syscall.SIGTERM:</span><br><span class="line">log.Println(pid, "Received SIGTERM.")</span><br><span class="line">err := srv.fork()</span><br><span class="line">if err != nil {</span><br><span class="line">log.Println("Fork err:", err)</span><br><span class="line">}</span><br><span class="line">//srv.shutdown()</span><br><span class="line">case syscall.SIGTSTP:</span><br><span class="line">log.Println(pid, "Received SIGTSTP.")</span><br><span class="line">default:</span><br><span class="line">log.Printf("Received %v: nothing i care about...\n", sig)</span><br><span class="line">}</span><br><span class="line">srv.signalHooks(POST_SIGNAL, sig)</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func (srv *endlessServer) signalHooks(ppFlag int, sig os.Signal) {</span><br><span class="line">if _, notSet := srv.SignalHooks[ppFlag][sig]; !notSet {</span><br><span class="line">return</span><br><span class="line">}</span><br><span class="line">for _, f := range srv.SignalHooks[ppFlag][sig] {</span><br><span class="line">f()</span><br><span class="line">}</span><br><span class="line">return</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">shutdown closes the listener so that no new connections are accepted. it also</span><br><span class="line">starts a goroutine that will hammer (stop all running requests) the server</span><br><span class="line">after DefaultHammerTime.</span><br><span class="line">*/</span><br><span class="line">func (srv *endlessServer) shutdown() {</span><br><span class="line">if srv.getState() != STATE_RUNNING {</span><br><span class="line">return</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">srv.setState(STATE_SHUTTING_DOWN)</span><br><span class="line">if DefaultHammerTime &gt;= 0 {</span><br><span class="line">go srv.hammerTime(DefaultHammerTime)</span><br><span class="line">}</span><br><span class="line">// disable keep-alives on existing connections</span><br><span class="line">srv.SetKeepAlivesEnabled(false)</span><br><span class="line">err := srv.EndlessListener.Close()</span><br><span class="line">if err != nil {</span><br><span class="line">log.Println(syscall.Getpid(), "Listener.Close() error:", err)</span><br><span class="line">} else {</span><br><span class="line">log.Println(syscall.Getpid(), srv.EndlessListener.Addr(), "Listener closed.")</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">hammerTime forces the server to shutdown in a given timeout - whether it</span><br><span class="line">finished outstanding requests or not. if Read/WriteTimeout are not set or the</span><br><span class="line">max header size is very big a connection could hang...</span><br><span class="line"></span><br><span class="line">srv.Serve() will not return until all connections are served. this will</span><br><span class="line">unblock the srv.wg.Wait() in Serve() thus causing ListenAndServe(TLS) to</span><br><span class="line">return.</span><br><span class="line">*/</span><br><span class="line">func (srv *endlessServer) hammerTime(d time.Duration) {</span><br><span class="line">defer func() {</span><br><span class="line">// we are calling srv.wg.Done() until it panics which means we called</span><br><span class="line">// Done() when the counter was already at 0 and we're done.</span><br><span class="line">// (and thus Serve() will return and the parent will exit)</span><br><span class="line">if r := recover(); r != nil {</span><br><span class="line">log.Println("WaitGroup at 0", r)</span><br><span class="line">}</span><br><span class="line">}()</span><br><span class="line">if srv.getState() != STATE_SHUTTING_DOWN {</span><br><span class="line">return</span><br><span class="line">}</span><br><span class="line">time.Sleep(d)</span><br><span class="line">log.Println("[STOP - Hammer Time] Forcefully shutting down parent")</span><br><span class="line">for {</span><br><span class="line">if srv.getState() == STATE_TERMINATE {</span><br><span class="line">break</span><br><span class="line">}</span><br><span class="line">srv.wg.Done()</span><br><span class="line">runtime.Gosched()</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func (srv *endlessServer) fork() (err error) {</span><br><span class="line">runningServerReg.Lock()</span><br><span class="line">defer runningServerReg.Unlock()</span><br><span class="line"></span><br><span class="line">// only one server instance should fork!</span><br><span class="line">if runningServersForked {</span><br><span class="line">return errors.New("Another process already forked. Ignoring this one.")</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">runningServersForked = true</span><br><span class="line"></span><br><span class="line">var files = make([]*os.File, len(runningServers))</span><br><span class="line">var orderArgs = make([]string, len(runningServers))</span><br><span class="line">// get the accessor socket fds for _all_ server instances</span><br><span class="line">for _, srvPtr := range runningServers {</span><br><span class="line">// introspect.PrintTypeDump(srvPtr.EndlessListener)</span><br><span class="line">switch srvPtr.EndlessListener.(type) {</span><br><span class="line">case *endlessListener:</span><br><span class="line">// normal listener</span><br><span class="line">files[socketPtrOffsetMap[srvPtr.Server.Addr]] = srvPtr.EndlessListener.(*endlessListener).File()</span><br><span class="line">default:</span><br><span class="line">// tls listener</span><br><span class="line">files[socketPtrOffsetMap[srvPtr.Server.Addr]] = srvPtr.tlsInnerListener.File()</span><br><span class="line">}</span><br><span class="line">orderArgs[socketPtrOffsetMap[srvPtr.Server.Addr]] = srvPtr.Server.Addr</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">env := append(</span><br><span class="line">os.Environ(),</span><br><span class="line">"ENDLESS_CONTINUE=1",</span><br><span class="line">)</span><br><span class="line">if len(runningServers) &gt; 1 {</span><br><span class="line">env = append(env, fmt.Sprintf(`ENDLESS_SOCKET_ORDER=%s`, strings.Join(orderArgs, ",")))</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// log.Println(files)</span><br><span class="line">path := os.Args[0]</span><br><span class="line">var args []string</span><br><span class="line">if len(os.Args) &gt; 1 {</span><br><span class="line">args = os.Args[1:]</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">cmd := exec.Command(path, args...)</span><br><span class="line">cmd.Stdout = os.Stdout</span><br><span class="line">cmd.Stderr = os.Stderr</span><br><span class="line">cmd.ExtraFiles = files</span><br><span class="line">cmd.Env = env</span><br><span class="line"></span><br><span class="line">// cmd.SysProcAttr = &amp;syscall.SysProcAttr{</span><br><span class="line">// Setsid:  true,</span><br><span class="line">// Setctty: true,</span><br><span class="line">// Ctty:    ,</span><br><span class="line">// }</span><br><span class="line"></span><br><span class="line">err = cmd.Start()</span><br><span class="line">if err != nil {</span><br><span class="line">log.Fatalf("Restart: Failed to launch, error: %v", err)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">return</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">type endlessListener struct {</span><br><span class="line">net.Listener</span><br><span class="line">stopped bool</span><br><span class="line">server  *endlessServer</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func (el *endlessListener) Accept() (c net.Conn, err error) {</span><br><span class="line">tc, err := el.Listener.(*net.TCPListener).AcceptTCP()</span><br><span class="line">if err != nil {</span><br><span class="line">return</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">tc.SetKeepAlive(true)                  // see http.tcpKeepAliveListener</span><br><span class="line">tc.SetKeepAlivePeriod(3 * time.Minute) // see http.tcpKeepAliveListener</span><br><span class="line"></span><br><span class="line">c = endlessConn{</span><br><span class="line">Conn:   tc,</span><br><span class="line">server: el.server,</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">el.server.wg.Add(1)</span><br><span class="line">return</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func newEndlessListener(l net.Listener, srv *endlessServer) (el *endlessListener) {</span><br><span class="line">el = &amp;endlessListener{</span><br><span class="line">Listener: l,</span><br><span class="line">server:   srv,</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">return</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func (el *endlessListener) Close() error {</span><br><span class="line">if el.stopped {</span><br><span class="line">return syscall.EINVAL</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">el.stopped = true</span><br><span class="line">return el.Listener.Close()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func (el *endlessListener) File() *os.File {</span><br><span class="line">// returns a dup(2) - FD_CLOEXEC flag *not* set</span><br><span class="line">tl := el.Listener.(*net.TCPListener)</span><br><span class="line">fl, _ := tl.File()</span><br><span class="line">return fl</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">type endlessConn struct {</span><br><span class="line">net.Conn</span><br><span class="line">server *endlessServer</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func (w endlessConn) Close() error {</span><br><span class="line">err := w.Conn.Close()</span><br><span class="line">if err == nil {</span><br><span class="line">w.server.wg.Done()</span><br><span class="line">}</span><br><span class="line">return err</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">RegisterSignalHook registers a function to be run PRE_SIGNAL or POST_SIGNAL for</span><br><span class="line">a given signal. PRE or POST in this case means before or after the signal</span><br><span class="line">related code endless itself runs</span><br><span class="line">*/</span><br><span class="line">func (srv *endlessServer) RegisterSignalHook(prePost int, sig os.Signal, f func()) (err error) {</span><br><span class="line">if prePost != PRE_SIGNAL &amp;&amp; prePost != POST_SIGNAL {</span><br><span class="line">err = fmt.Errorf("Cannot use %v for prePost arg. Must be endless.PRE_SIGNAL or endless.POST_SIGNAL.", sig)</span><br><span class="line">return</span><br><span class="line">}</span><br><span class="line">for _, s := range hookableSignals {</span><br><span class="line">if s == sig {</span><br><span class="line">srv.SignalHooks[prePost][sig] = append(srv.SignalHooks[prePost][sig], f)</span><br><span class="line">return</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">err = fmt.Errorf("Signal %v is not supported.", sig)</span><br><span class="line">return</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>CloneSet.yaml如下</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">apiVersion: apps.kruise.io/v1alpha1</span><br><span class="line">kind: CloneSet</span><br><span class="line">metadata:</span><br><span class="line">  namespace: demo04</span><br><span class="line">  name: demo04-web</span><br><span class="line">spec:</span><br><span class="line">  replicas: 1</span><br><span class="line">  updateStrategy:</span><br><span class="line">    type: InPlaceIfPossible</span><br><span class="line">    inPlaceUpdateStrategy:</span><br><span class="line">      gracePeriodSeconds: 2</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: demo04-web</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: demo04-web</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">        - name: demo04-web</span><br><span class="line">          env:</span><br><span class="line">            - name: RUN_MODE</span><br><span class="line">              value: "test"</span><br><span class="line">          command: [</span><br><span class="line">              "/demo04-web",</span><br><span class="line">          ]</span><br><span class="line">          image: registry.cn-hangzhou.aliyuncs.com/demo04-web:latest</span><br><span class="line">          imagePullPolicy: Always</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>kubectl port-forward -n demo04  pod/demo04-web-w66sh  9098:8080进行端口转发<br>然后进行大批量请求：b -n 4000  -c 200 -r -T ‘application/json’ <a href="http://127.0.0.1:9098/api/v1/hello">http://127.0.0.1:9098/api/v1/hello</a><br>在大批量请求期间，将registry.cn-hangzhou.aliyuncs.com/demo04-web:latest换成registry.cn-hangzhou.aliyuncs.com/demo04-web:v1 执行 apply</p><p>请求结束结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Server Software:</span><br><span class="line">Server Hostname:        127.0.0.1</span><br><span class="line">Server Port:            9098</span><br><span class="line"></span><br><span class="line">Document Path:          /api/v1/hello</span><br><span class="line">Document Length:        4 bytes</span><br><span class="line"></span><br><span class="line">Concurrency Level:      200</span><br><span class="line">Time taken for tests:   39.210 seconds</span><br><span class="line">Complete requests:      4000</span><br><span class="line">Failed requests:        0</span><br><span class="line">Total transferred:      504000 bytes</span><br><span class="line">HTML transferred:       16000 bytes</span><br><span class="line">Requests per second:    102.01 [#/sec] (mean)</span><br><span class="line">Time per request:       1960.512 [ms] (mean)</span><br><span class="line">Time per request:       9.803 [ms] (mean, across all concurrent requests)</span><br><span class="line">Transfer rate:          12.55 [Kbytes/sec] received</span><br></pre></td></tr></tbody></table></figure><p>可以看出Failed requests  为0，则证明优雅重启期间没有失败的请求，所有请求都成功处理完并返回。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>通过双十一大考！基于 Golang 的 SOFAMosn 深度剖析</title>
      <link href="2021/02/21/62c3115dc01ac0fd9c7170e72017a419/"/>
      <url>2021/02/21/62c3115dc01ac0fd9c7170e72017a419/</url>
      
        <content type="html"><![CDATA[<p><a href="https://mp.weixin.qq.com/s?__biz=MzA4ODg0NDkzOA==&amp;mid=2247487075&amp;idx=1&amp;sn=87627a103a19eda1a3630ed3f6c3ca5e&amp;source=41#wechat_redirect">https://mp.weixin.qq.com/s?__biz=MzA4ODg0NDkzOA==&amp;mid=2247487075&amp;idx=1&amp;sn=87627a103a19eda1a3630ed3f6c3ca5e&amp;source=41#wechat_redirect</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Nginx vs Envoy vs Mosn 平滑升级原理解析-TCP 连接迁移</title>
      <link href="2021/02/21/063b7b23cb62ea7a913e656a26db80ab/"/>
      <url>2021/02/21/063b7b23cb62ea7a913e656a26db80ab/</url>
      
        <content type="html"><![CDATA[<p><a href="https://ms2008.github.io/2019/12/28/hot-upgrade/">https://ms2008.github.io/2019/12/28/hot-upgrade/</a><br><a href="https://zhuanlan.zhihu.com/p/97340154">https://zhuanlan.zhihu.com/p/97340154</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>dapr</title>
      <link href="2021/02/21/5901cc15fcf7e10863b0d8ed4c59baa4/"/>
      <url>2021/02/21/5901cc15fcf7e10863b0d8ed4c59baa4/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.zhihu.com/question/351298264/answer/1737380230">https://www.zhihu.com/question/351298264/answer/1737380230</a><br><a href="https://www.kubernetes.org.cn/5954.html">https://www.kubernetes.org.cn/5954.html</a><br><a href="https://www.cnblogs.com/thrillcattle/p/14186766.html">https://www.cnblogs.com/thrillcattle/p/14186766.html</a><br><a href="http://www.dockone.io/article/9336">http://www.dockone.io/article/9336</a><br><a href="https://www.servicemesher.com/blog/mecha/">https://www.servicemesher.com/blog/mecha/</a><br><a href="https://www.cnblogs.com/sheng-jie/p/how-much-you-know-about-dapr.html">https://www.cnblogs.com/sheng-jie/p/how-much-you-know-about-dapr.html</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> dapr </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>有意思的博客</title>
      <link href="2021/02/19/5bc5f8bc7777f3bd828ceee39a0a8946/"/>
      <url>2021/02/19/5bc5f8bc7777f3bd828ceee39a0a8946/</url>
      
        <content type="html"><![CDATA[<p>1.<a href="https://medium.com/a-journey-with-go">https://medium.com/a-journey-with-go</a><br><a href="https://github.com/timqian/chinese-independent-blogs">https://github.com/timqian/chinese-independent-blogs</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>共享内存机制</title>
      <link href="2021/02/19/93ee1255ceaab72e51d8317745a5c7c9/"/>
      <url>2021/02/19/93ee1255ceaab72e51d8317745a5c7c9/</url>
      
        <content type="html"><![CDATA[<p>进程间通信的只要方式有，管道，有名管道，消息队列，共享内存，socket等方式，共享内存是最高效的<br>进程间通信的方式，因为把同一块物理内存的地址空间映射到不同进程的地址空间当中，那么不同的进程之间<br>通信，通过直接修改地址空间当中的内存即可，该机制的实现只需要两次拷贝即可实现，不需要像其它的进程<br>通信机制那样将数据从用户空间拷贝到内核，然后在从内核拷贝到用户空间，实行四次拷贝操作，因此使用共<br>享内存通信比较高效。<br>　　使用共享内存的话，需要对共享的进程对共享内存的访问进行同步，防止访问对于共享数据的破坏。<br>　　共享内存的实现方式：<br>         一 基于物理内存实现的shm_get()实现的共享内存<br>　　1 shm_get()<br>　　　　使用该系统调用来申请一块共享内存，使用了该系统调用之后会返回一个共享内存的键值，进程可以<br>使用该key值来使用这块共享内存。shm_get()操作会返回一个和key值关联的shmid,其它的进程可以通过该<br>shmid将该贡献内存添加到进程的地址空间里面。<br>　　2 shmat(id,addr,flag)<br>　　使用该系统调用将使用shm_get()获得的共享内存挂载到当前进程的地址空间，addr参数可以选择连接的<br>地址位置，通常设置为0，让操作系统选择合适的连接位置，flag也是设置为默认值0。<br>　　3 shm_dt()<br>　　可以删除指定的共享内存，从当前的进程的地址空间当中删除。通过shmat()返回的挂载的地址，将加到进程<br>地址空间当中的内存删除。<br>　　4 shm_ctl()<br>　　对指定的共向内存空间进行操作。也是通过shm_get()返回的标识符来进行相关的操作。<br>　　二 基于文件映射实现的mmap实现的共享内存<br>　　进程通过将一个普通文件的内映射到每个进程的地址空间当中，对映射区的修改会被写回到文件当中，其他<br>进程可以共享这些修改。将文件映射到了进程的地址空间之后，可以直接对该段虚拟地址空间进行读写操作，不需<br>使用read,write等系统调用来进行读写。<br>　　mmap实现的共享内存，每个文件有自己的内存映射区，在munmap调用之后，会将修改的内容写回文件当中。<br>连接：<a href="https://www.cnblogs.com/wangkaia/p/13566966.html">https://www.cnblogs.com/wangkaia/p/13566966.html</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>cgo</title>
      <link href="2021/02/19/63e64fb7f6bfcedd6708e1b75126a6fb/"/>
      <url>2021/02/19/63e64fb7f6bfcedd6708e1b75126a6fb/</url>
      
        <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/u010853261/article/details/88312904">https://blog.csdn.net/u010853261/article/details/88312904</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>syscall-go</title>
      <link href="2021/02/19/6c89f76a308173b11c60574b48dbadd2/"/>
      <url>2021/02/19/6c89f76a308173b11c60574b48dbadd2/</url>
      
        <content type="html"><![CDATA[<p><a href="https://studygolang.com/articles/20854">https://studygolang.com/articles/20854</a><br><a href="https://blog.csdn.net/u010853261/article/details/88312904">https://blog.csdn.net/u010853261/article/details/88312904</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>go缓存库</title>
      <link href="2021/02/18/e2939ab094927e1f986d07f51e12a223/"/>
      <url>2021/02/18/e2939ab094927e1f986d07f51e12a223/</url>
      
        <content type="html"><![CDATA[<p>“github.com/dgraph-io/ristretto”<br>    “github.com/VictoriaMetrics/fastcache”<br>    “github.com/allegro/bigcache”<br>    “github.com/coocood/freecache”<br>    “github.com/golang/groupcache/lru”<br>    “github.com/patrickmn/go-cache”</p><p>groupcache 分布式缓存和缓存填充库，在许多情况下都可以用来替代内存缓存节点池，不支持 expire。<br>go-cache　 内存中键值存储/缓存库（类似于Memcached），适用于单机应用程序。<br>freecache  支持 expire，类似 cache2go。<br>ristretto　　未做好面向生产环境<br>golang-lru　固定尺寸大小的 线程安全的 LRU 缓存库，基于 Groupcache，比较简陋。<br>cache2go   支持 expire，并发安全的缓存库，api 简单。<br>gcache　　支持 expire，LFU, LRU and ARC 缓存库，Goroutine 安全。<br>fastcache  不支持 expire，据称比 freecache 更快。<br>以上可以都考察一下，go-cache 在使用上最简单粗暴。</p><p><a href="https://www.keeping365.com/2019/12/07/go%E5%B8%B8%E7%94%A8cache%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/">https://www.keeping365.com/2019/12/07/go%E5%B8%B8%E7%94%A8cache%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/</a><br>    <a href="https://www.5axxw.com/wiki/content/fzxtu6#17y9r3byrmb">https://www.5axxw.com/wiki/content/fzxtu6#17y9r3byrmb</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Pod容器应用&quot;优雅发布&quot; - 运维笔记</title>
      <link href="2021/02/10/dcb502b7ca641debd909152b6f570906/"/>
      <url>2021/02/10/dcb502b7ca641debd909152b6f570906/</url>
      
        <content type="html"><![CDATA[<p>K8S自身带有优雅终止Pod容器的机制，发送SIGTERM终止信号，在规定的terminationGracePeriodSeconds优雅时间内完成Pod优雅终止动作。</p><p>terminationGracePeriodSeconds默认是30秒，该时间是从Pod的Termination状态开始计算的，包括了Prestop钩子处理时间、SIGTERM信号发送即程序优雅处理时间。</p><p>Pod容器终止流程：<br>1）新Pod启动，通过Readiness就绪性探测，加入service的endpoint服务列表。</p><p>2）老pod进入Termination状态，从service的endpoint服务列表摘除，此时不会有新请求打到即将终止的老pod上。</p><p>3）如果设置了Prestop钩子，则优先执行Prestop里的优雅动作。如果在规定的terminationGracePeriodSeconds优雅时间内（默认30s）完成不了，则kubelet会发送SIGTERM终止信号，并等待2秒，如果2秒后还未终止pod容器，则发送SIGKILL信号强制终止。</p><p>4）如果没有设置Prestop钩子，则发送SIGTERM终止信号优雅关闭容器进程，如果在规定的terminationGracePeriodSeconds优雅时间内（默认30s）未能终止pod容器，则发送SIGKILL信号强制终止。</p><p>需要注意：</p><p>1）SIGTERM终止信号只能被那些pid为1的父进程捕捉到，并优雅关闭容器进程。对于那些pid不为1的子进程是捕捉不到SIGTERM终止信号的。</p><p>所以对于单个容器只有一个pid为1的进程来说，使用K8S默认的优雅机制就可以，只需要拉长terminationGracePeriodSeconds优雅时间，确保在规定时间内完成容器优雅终止。</p><p>2）对于那些单个容器里有多个进程，即除了pid为1的进程外，还有子进程。这种情况下就需要设置Prestop钩子函数，在prestop里提前优雅处理掉那些子进程，然后再通过SIGTERM正常终止掉pod容器。</p><p>注意设置好terminationGracePeriodSeconds优雅时间。</p><p>线上基于nacos注册中心的优雅上线</p><p>对于请求通过k8s的service层到达pod容器的情况，可以通过k8s优雅机制来确保pod容器在上线滚动更新期间，做到业务”无感知”。但是目前线上pod容器服务主动注册到nacos配置中心，业务方通过nacos网关调用pod容器服务，即调用请求绕过了k8s的service层。</p><p>这就出现了一个问题：pod容器更新期间，老pod已经优雅终止掉了，但是其ip和端口还在nacos的网关缓存里，调用请求会在nacos网关缓存未完全更新之前打到已经终止掉的pod地址，这就会出现连接超时，调用失败错误，从而造成业务流量损失。</p><p>正确的做法：</p><p>1）拉长terminationGracePeriodSeconds的优雅时间。</p><p>2）设置Prestop钩子，在Pod容器终止之前，在Prestop里通过nacos提供的API接口，主动摘除nacos注册。接着sleep 30秒时间，用于刷新nacos网关缓存，摘除下线的pod地址。</p><p>3）最后再执行pod容器的优雅终止。</p><p>容器优雅发布的配置记录：<br>这里以customer-services应用模块的pod容器优雅配置为例：</p><p>1）将nacos主动下线的脚本在镜像制作阶段推送到容器内部<br>编写customer-services主动下线nacos的脚本：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-storage01 ~]# ls /home/k8s_deploy/fin/online/deploy/customer-services/</span><br><span class="line">Dockerfile  service_offline_nacos.sh customer-services.jar</span><br><span class="line"> </span><br><span class="line">[root@k8s-storage01 ~]# cat /home/k8s_deploy/fin/online/deploy/customer-services/service_offline_nacos.sh</span><br><span class="line">#!/bin/bash</span><br><span class="line">  </span><br><span class="line">serviceName="customer-services"</span><br><span class="line">groupName="kevin-app"</span><br><span class="line">metadata="preserved.register.source=SPRING_CLOUD"</span><br><span class="line">namespaceId="online"</span><br><span class="line">port="9810"</span><br><span class="line">Token=$(curl -s --location --request POST 'http://nacos:8848/nacos/v1/auth/users/login' --form 'username=nacos' --form 'password=nacos'|awk -F"accessToken" '{print $2}'|awk -F":" '{print $2}'|awk -F'"' '{print $2}')</span><br><span class="line">  </span><br><span class="line"># 从nacos注册中心下线</span><br><span class="line">curl --location --request PUT "http://nacos:8848/nacos/v1/ns/instance?&amp;accessToken=${Token}" \</span><br><span class="line">--form "serviceName=${serviceName}" \</span><br><span class="line">--form "clusterName=DEFAULT" \</span><br><span class="line">--form "groupName=${groupName}" \</span><br><span class="line">--form "metadata=${metadata}" \</span><br><span class="line">--form "namespaceId=${namespaceId}" \</span><br><span class="line">--form "ip=${podip}" \</span><br><span class="line">--form "port=${port}" \</span><br><span class="line">--form "ephemeral=true" \</span><br><span class="line">--form "weight=1" \</span><br><span class="line">--form "enabled=false"</span><br><span class="line">  </span><br><span class="line"># 等待30s，刷新nacos网关缓存</span><br><span class="line">sleep 30</span><br></pre></td></tr></tbody></table></figure><p>制作finhub-customer-services服务的容器镜像</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-storage01 ~]# cat /home/k8s_deploy/fin/online/deploy/customer-services/Dockerfile</span><br><span class="line">FROM 172.16.60.196/kevin/jdk1.8.0_192</span><br><span class="line">RUN rm -f /etc/localtime \</span><br><span class="line">&amp;&amp; ln -sv /usr/share/zoneinfo/Asia/Shanghai /etc/localtime \</span><br><span class="line">&amp;&amp; echo "Asia/Shanghai" &gt; /etc/timezone</span><br><span class="line">  </span><br><span class="line">ENV LANG en_US.UTF-8</span><br><span class="line"> </span><br><span class="line">COPY customer-services.jar /usr/local/src</span><br><span class="line">COPY service_offline_nacos.sh /opt/</span><br><span class="line">WORKDIR /usr/local/src</span><br><span class="line">EXPOSE 9810</span><br><span class="line">CMD ["nohup","java","-jar","customer-ser</span><br></pre></td></tr></tbody></table></figure><p>制作和推送镜像</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-storage01 ~]# docker build -t 172.16.60.196/kevin/customer-services_v1 .</span><br><span class="line">[root@k8s-storage01 ~]# docker push 172.16.60.196/kevin/customer-services_v1</span><br></pre></td></tr></tbody></table></figure><p>2）配置pod的yml部署文件，添加env变量动态获取pod ip地址、拉长terminationGracePeriodSeconds优雅时间、设置prestop钩子</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-master01 customer-services]# pwd</span><br><span class="line">/opt/k8s/k8s-project/kevin/customer-services</span><br><span class="line">  </span><br><span class="line">[root@k8s-master01 customer-services]# cat customer-services.yml</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: customer-services</span><br><span class="line">  namespace: kevin</span><br><span class="line">  labels:</span><br><span class="line">    app: customer-services</span><br><span class="line">spec:</span><br><span class="line">  type: NodePort</span><br><span class="line">  selector:</span><br><span class="line">    app: customer-services</span><br><span class="line">  ports:</span><br><span class="line">  - name: http</span><br><span class="line">    port: 9810</span><br><span class="line">    targetPort: 9810</span><br><span class="line">    nodePort: 39810</span><br><span class="line">---</span><br><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: customer-services</span><br><span class="line">  namespace: kevin</span><br><span class="line">spec:</span><br><span class="line">  replicas: 2</span><br><span class="line">  minReadySeconds: 10</span><br><span class="line">  strategy:</span><br><span class="line">    rollingUpdate:</span><br><span class="line">      maxSurge: 1</span><br><span class="line">      maxUnavailable: 0</span><br><span class="line">    type: RollingUpdate</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: customer-services</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: customer-services</span><br><span class="line">    spec:</span><br><span class="line">      affinity:</span><br><span class="line">        podAntiAffinity:</span><br><span class="line">          requiredDuringSchedulingIgnoredDuringExecution:</span><br><span class="line">            - labelSelector:</span><br><span class="line">                matchExpressions:</span><br><span class="line">                  - key: "app"</span><br><span class="line">                    operator: In</span><br><span class="line">                    values:</span><br><span class="line">                      - customer-services</span><br><span class="line">              topologyKey: "kubernetes.io/hostname"</span><br><span class="line">      terminationGracePeriodSeconds: 60</span><br><span class="line">      containers:</span><br><span class="line">      - name: customer-services</span><br><span class="line">        image: 172.16.60.196/kevin/customer-services_v1</span><br><span class="line">        imagePullPolicy: Always</span><br><span class="line">        ports:</span><br><span class="line">        - name: customer-port</span><br><span class="line">          containerPort: 9810</span><br><span class="line">        env:</span><br><span class="line">        - name: podip</span><br><span class="line">          valueFrom:</span><br><span class="line">            fieldRef:</span><br><span class="line">              fieldPath: status.podIP</span><br><span class="line">        resources:</span><br><span class="line">          requests:</span><br><span class="line">            cpu: 950m</span><br><span class="line">            memory: 2048Mi</span><br><span class="line">          limits:</span><br><span class="line">            cpu: 1500m</span><br><span class="line">            memory: 4096Mi</span><br><span class="line">        lifecycle:</span><br><span class="line">          postStart:</span><br><span class="line">            exec:</span><br><span class="line">              command: ["/bin/sh","-c","touch /tmp/health"]</span><br><span class="line">          preStop:</span><br><span class="line">            exec:</span><br><span class="line">              command: ["/bin/sh","-c","sh /opt/service_offline_nacos.sh"]</span><br><span class="line">        livenessProbe:</span><br><span class="line">          exec:</span><br><span class="line">            command: ["test","-e","/tmp/health"]</span><br><span class="line">          initialDelaySeconds: 5</span><br><span class="line">          timeoutSeconds: 5</span><br><span class="line">          periodSeconds: 10</span><br><span class="line">        readinessProbe:</span><br><span class="line">          tcpSocket:</span><br><span class="line">            port: customer-port</span><br><span class="line">          initialDelaySeconds: 15</span><br><span class="line">          timeoutSeconds: 5</span><br><span class="line">          periodSeconds: 20</span><br><span class="line">        volumeMounts:</span><br><span class="line">        - name: customerlog</span><br><span class="line">          mountPath: /var/log/customer-services</span><br><span class="line">          readOnly: false</span><br><span class="line">      volumes:</span><br><span class="line">      - name: customerlog</span><br><span class="line">        hostPath:</span><br><span class="line">          path: /var/log/k8s_log/customer-services</span><br></pre></td></tr></tbody></table></figure><p>容器发布流程：<br><img src="/2021/02/10/dcb502b7ca641debd909152b6f570906/1612939899430.png"><br>生产环境通过Jenkins配置的Pod容器部署流程：即从Gitlab拉取代码、打包、制作镜像、上传镜像到Harbor仓库、更新pod等发布流程。完成如上配置，后续通过Jenkins进行”容器应用的优雅”发版了。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Zookeeper集群&quot;脑裂&quot;问题</title>
      <link href="2021/02/10/8af76ad83681cd9948d4af94b6a0c051/"/>
      <url>2021/02/10/8af76ad83681cd9948d4af94b6a0c051/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/kevingrace/p/12433503.html">https://www.cnblogs.com/kevingrace/p/12433503.html</a></p><p>关于集群中的”脑裂”问题，之前已经在这里详细介绍过，下面重点说下Zookeeper脑裂问题的处理办法。ooKeeper是用来协调（同步）分布式进程的服务，提供了一个简单高性能的协调内核，用户可以在此之上构建更多复杂的分布式协调功能。脑裂通常会出现在集群环境中，比如ElasticSearch、Zookeeper集群，而这些集群环境有一个统一的特点，就是它们有一个大脑，比如ElasticSearch集群中有Master节点，Zookeeper集群中有Leader节点。</p><p>一、 Zookeeper 集群节点为什么要部署成奇数<br>zookeeper容错指的是：当宕掉几个zookeeper节点服务器之后，剩下的个数必须大于宕掉的个数，也就是剩下的节点服务数必须大于n/2，这样zookeeper集群才可以继续使用，无论奇偶数都可以选举leader。例如5台zookeeper节点机器最多宕掉2台，还可以继续使用，因为剩下3台大于5/2。至于为什么最好为奇数个节点？这样是为了以最大容错服务器个数的条件下，能节省资源。比如，最大容错为2的情况下，对应的zookeeper服务数，奇数为5，而偶数为6，也就是6个zookeeper服务的情况下最多能宕掉2个服务，所以从节约资源的角度看，没必要部署6（偶数）个zookeeper服务节点。</p><p>zookeeper集群有这样一个特性：集群中只要有过半的机器是正常工作的，那么整个集群对外就是可用的。也就是说如果有2个zookeeper节点，那么只要有1个zookeeper节点死了，那么zookeeper服务就不能用了，因为1没有过半，所以2个zookeeper的死亡容忍度为0；同理，要是有3个zookeeper，一个死了，还剩下2个正常的，过半了，所以3个zookeeper的容忍度为1；同理也可以多列举几个：2-&gt;0; 3-&gt;1; 4-&gt;1; 5-&gt;2; 6-&gt;2 就会发现一个规律，2n和2n-1的容忍度是一样的，都是n-1，所以为了更加高效，何必增加那一个不必要的zookeeper呢。所以说，根据以上可以得出结论：从资源节省的角度来考虑，zookeeper集群的节点最好要部署成奇数个！</p><p>二、 Zookeeper 集群中的”脑裂”场景说明<br>对于一个集群，想要提高这个集群的可用性，通常会采用多机房部署，比如现在有一个由6台zkServer所组成的一个集群，部署在了两个机房：<br><img src="/2021/02/10/8af76ad83681cd9948d4af94b6a0c051/1612938455384.png"></p><p>正常情况下，此集群只会有一个Leader，那么如果机房之间的网络断了之后，两个机房内的zkServer还是可以相互通信的，如果不考虑过半机制，那么就会出现每个机房内部都将选出一个Leader。</p><p><img src="/2021/02/10/8af76ad83681cd9948d4af94b6a0c051/1612938475244.png"><br>这就相当于原本一个集群，被分成了两个集群，出现了两个”大脑”，这就是所谓的”脑裂”现象。对于这种情况，其实也可以看出来，原本应该是统一的一个集群对外提供服务的，现在变成了两个集群同时对外提供服务，如果过了一会，断了的网络突然联通了，那么此时就会出现问题了，两个集群刚刚都对外提供服务了，数据该怎么合并，数据冲突怎么解决等等问题。刚刚在说明脑裂场景时有一个前提条件就是没有考虑过半机制，所以实际上Zookeeper集群中是不会轻易出现脑裂问题的，原因在于过半机制。</p><p>zookeeper的过半机制：在领导者选举的过程中，如果某台zkServer获得了超过半数的选票，则此zkServer就可以成为Leader了。举个简单的例子：如果现在集群中有5台zkServer，那么half=5/2=2，那么也就是说，领导者选举的过程中至少要有三台zkServer投了同一个zkServer，才会符合过半机制，才能选出来一个Leader。</p><p>那么zookeeper选举的过程中为什么一定要有一个过半机制验证？<br>因为这样不需要等待所有zkServer都投了同一个zkServer就可以选举出来一个Leader了，这样比较快，所以叫快速领导者选举算法。</p><p>zookeeper过半机制中为什么是大于，而不是大于等于？这就是更脑裂问题有关系了，比如回到上文出现脑裂问题的场景 [如上图1]：当机房中间的网络断掉之后，机房1内的三台服务器会进行领导者选举，但是此时过半机制的条件是 “节点数 &gt; 3”，也就是说至少要4台zkServer才能选出来一个Leader，所以对于机房1来说它不能选出一个Leader，同样机房2也不能选出一个Leader，这种情况下整个集群当机房间的网络断掉后，整个集群将没有Leader。而如果过半机制的条件是 “节点数 &gt;= 3”，那么机房1和机房2都会选出一个Leader，这样就出现了脑裂。这就可以解释为什么过半机制中是大于而不是大于等于，目的就是为了防止脑裂。</p><p>如果假设我们现在只有5台机器，也部署在两个机房：<br><img src="/2021/02/10/8af76ad83681cd9948d4af94b6a0c051/1612938495380.png"><br>此时过半机制的条件是 “节点数 &gt; 2”，也就是至少要3台服务器才能选出一个Leader，此时机房件的网络断开了，对于机房1来说是没有影响的，Leader依然还是Leader，对于机房2来说是选不出来Leader的，此时整个集群中只有一个Leader。因此总结得出，有了过半机制，对于一个Zookeeper集群来说，要么没有Leader，要么只有1个Leader，这样zookeeper也就能避免了脑裂问题。</p><p>三、 Zookeeper 集群”脑裂”问题处理</p><ol><li> 什么是脑裂？<br>简单点来说，脑裂(Split-Brain) 就是比如当你的 cluster 里面有两个节点，它们都知道在这个 cluster 里需要选举出一个 master。那么当它们两个之间的通信完全没有问题的时候，就会达成共识，选出其中一个作为 master。但是如果它们之间的通信出了问题，那么两个结点都会觉得现在没有 master，所以每个都把自己选举成 master，于是 cluster 里面就会有两个 master。</li></ol><p>对于Zookeeper来说有一个很重要的问题，就是到底是根据一个什么样的情况来判断一个节点死亡down掉了？在分布式系统中这些都是有监控者来判断的，但是监控者也很难判定其他的节点的状态，唯一一个可靠的途径就是心跳，Zookeeper也是使用心跳来判断客户端是否仍然活着。</p><p>使用ZooKeeper来做Leader HA基本都是同样的方式：每个节点都尝试注册一个象征leader的临时节点，其他没有注册成功的则成为follower，并且通过watch机制 (这里有介绍) 监控着leader所创建的临时节点，Zookeeper通过内部心跳机制来确定leader的状态，一旦leader出现意外Zookeeper能很快获悉并且通知其他的follower，其他flower在之后作出相关反应，这样就完成了一个切换，这种模式也是比较通用的模式，基本大部分都是这样实现的。但是这里面有个很严重的问题，如果注意不到会导致短暂的时间内系统出现脑裂，因为心跳出现超时可能是leader挂了，但是也可能是zookeeper节点之间网络出现了问题，导致leader假死的情况，leader其实并未死掉，但是与ZooKeeper之间的网络出现问题导致Zookeeper认为其挂掉了然后通知其他节点进行切换，这样follower中就有一个成为了leader，但是原本的leader并未死掉，这时候client也获得leader切换的消息，但是仍然会有一些延时，zookeeper需要通讯需要一个一个通知，这时候整个系统就很混乱可能有一部分client已经通知到了连接到新的leader上去了，有的client仍然连接在老的leader上，如果同时有两个client需要对leader的同一个数据更新，并且刚好这两个client此刻分别连接在新老的leader上，就会出现很严重问题。</p><p>这里做下小总结：<br>假死：由于心跳超时（网络原因导致的）认为leader死了，但其实leader还存活着。<br>脑裂：由于假死会发起新的leader选举，选举出一个新的leader，但旧的leader网络又通了，导致出现了两个leader ，有的客户端连接到老的leader，而有的客户端则连接到新的leader。</p><ol start="2"><li><p> zookeeper脑裂是什么原因导致的？<br>主要原因是Zookeeper集群和Zookeeper client判断超时并不能做到完全同步，也就是说可能一前一后，如果是集群先于client发现，那就会出现上面的情况。同时，在发现并切换后通知各个客户端也有先后快慢。一般出现这种情况的几率很小，需要leader节点与Zookeeper集群网络断开，但是与其他集群角色之间的网络没有问题，还要满足上面那些情况，但是一旦出现就会引起很严重的后果，数据不一致。</p></li><li><p> zookeeper是如何解决”脑裂”问题的？<br>要解决Split-Brain脑裂的问题，一般有下面几种种方法：<br>Quorums (法定人数) 方式: 比如3个节点的集群，Quorums = 2, 也就是说集群可以容忍1个节点失效，这时候还能选举出1个lead，集群还可用。比如4个节点的集群，它的Quorums = 3，Quorums要超过3，相当于集群的容忍度还是1，如果2个节点失效，那么整个集群还是无效的。这是zookeeper防止”脑裂”默认采用的方法。<br>采用Redundant communications (冗余通信)方式：集群中采用多种通信方式，防止一种通信方式失效导致集群中的节点无法通信。<br>Fencing (共享资源) 方式：比如能看到共享资源就表示在集群中，能够获得共享资源的锁的就是Leader，看不到共享资源的，就不在集群中。<br>仲裁机制方式。<br>启动磁盘锁定方式。</p></li></ol><p>要想避免zookeeper”脑裂”情况其实也很简单，在follower节点切换的时候不在检查到老的leader节点出现问题后马上切换，而是在休眠一段足够的时间，确保老的leader已经获知变更并且做了相关的shutdown清理工作了然后再注册成为master就能避免这类问题了，这个休眠时间一般定义为与zookeeper定义的超时时间就够了，但是这段时间内系统可能是不可用的，但是相对于数据不一致的后果来说还是值得的。</p><p>1、zooKeeper默认采用了Quorums这种方式来防止”脑裂”现象。即只有集群中超过半数节点投票才能选举出Leader。这样的方式可以确保leader的唯一性,要么选出唯一的一个leader,要么选举失败。在zookeeper中Quorums作用如下：<br>1]  集群中最少的节点数用来选举leader保证集群可用。<br>2] 通知客户端数据已经安全保存前集群中最少数量的节点数已经保存了该数据。一旦这些节点保存了该数据，客户端将被通知已经安全保存了，可以继续其他任务。而集群中剩余的节点将会最终也保存了该数据。</p><p>假设某个leader假死，其余的followers选举出了一个新的leader。这时，旧的leader复活并且仍然认为自己是leader，这个时候它向其他followers发出写请求也是会被拒绝的。因为每当新leader产生时，会生成一个epoch标号(标识当前属于那个leader的统治时期)，这个epoch是递增的，followers如果确认了新的leader存在，知道其epoch，就会拒绝epoch小于现任leader epoch的所有请求。那有没有follower不知道新的leader存在呢，有可能，但肯定不是大多数，否则新leader无法产生。Zookeeper的写也遵循quorum机制，因此，得不到大多数支持的写是无效的，旧leader即使各种认为自己是leader，依然没有什么作用。</p><p>zookeeper除了可以采用上面默认的Quorums方式来避免出现”脑裂”，还可以可采用下面的预防措施：<br>2、添加冗余的心跳线，例如双线条线，尽量减少“裂脑”发生机会。<br>3、启用磁盘锁。正在服务一方锁住共享磁盘，”裂脑”发生时，让对方完全”抢不走”共享磁盘资源。但使用锁磁盘也会有一个不小的问题，如果占用共享盘的一方不主动”解锁”，另一方就永远得不到共享磁盘。现实中假如服务节点突然死机或崩溃，就不可能执行解锁命令。后备节点也就接管不了共享资源和应用服务。于是有人在HA中设计了”智能”锁。即正在服务的一方只在发现心跳线全部断开（察觉不到对端）时才启用磁盘锁。平时就不上锁了。<br>4、设置仲裁机制。例如设置参考IP（如网关IP），当心跳线完全断开时，2个节点都各自ping一下 参考IP，不通则表明断点就出在本端，不仅”心跳”、还兼对外”服务”的本端网络链路断了，即使启动（或继续）应用服务也没有用了，那就主动放弃竞争，让能够ping通参考IP的一端去起服务。更保险一些，ping不通参考IP的一方干脆就自我重启，以彻底释放有可能还占用着的那些共享资源。</p><p>过半机制：<br>1.解决脑裂问题（网络分区导致）<br>2.节约机器</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>go项目目录</title>
      <link href="2021/02/08/851c3db41d274a0d114c79dae5db2cf1/"/>
      <url>2021/02/08/851c3db41d274a0d114c79dae5db2cf1/</url>
      
        <content type="html"><![CDATA[<p><a href="https://github.com/golang-standards/project-layout/blob/master/README_zh.md">https://github.com/golang-standards/project-layout/blob/master/README_zh.md</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>readings</title>
      <link href="2021/02/07/24ce06bed20ba5337cf43074075d4008/"/>
      <url>2021/02/07/24ce06bed20ba5337cf43074075d4008/</url>
      
        <content type="html"><![CDATA[<p>1.架构</p><p style="text-indent:2em">&lt;&lt;架构简洁之道&gt;&gt;<!--架构简洁之道--></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>go算法与数据结构</title>
      <link href="2021/02/05/d5a6766bcfdbb83781db1d67bfb70781/"/>
      <url>2021/02/05/d5a6766bcfdbb83781db1d67bfb70781/</url>
      
        <content type="html"><![CDATA[<p>1.<a href="https://zhuanlan.zhihu.com/p/113038466">https://zhuanlan.zhihu.com/p/113038466</a><br>2.<a href="https://www.cnblogs.com/huay/p/12204573.html">https://www.cnblogs.com/huay/p/12204573.html</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>go查看代码调用关系</title>
      <link href="2021/02/03/82a7205ec40df43f211d4276f74f9c1e/"/>
      <url>2021/02/03/82a7205ec40df43f211d4276f74f9c1e/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/lanyangsh/p/10011093.html">https://www.cnblogs.com/lanyangsh/p/10011093.html</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>架构师内功修炼法则</title>
      <link href="2021/02/02/09249f893a83bd2f537cfd634cba87a9/"/>
      <url>2021/02/02/09249f893a83bd2f537cfd634cba87a9/</url>
      
        <content type="html"><![CDATA[<p><a href="https://segmentfault.com/a/1190000021817085?utm_source=sf-related">https://segmentfault.com/a/1190000021817085?utm_source=sf-related</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>go 编译器</title>
      <link href="2021/02/02/7220246f36f89859c92fe07d7dda8b6b/"/>
      <url>2021/02/02/7220246f36f89859c92fe07d7dda8b6b/</url>
      
        <content type="html"><![CDATA[<p><a href="https://xiaomi-info.github.io/2019/11/13/golang-compiler-principle/">https://xiaomi-info.github.io/2019/11/13/golang-compiler-principle/</a><br><a href="https://segmentfault.com/a/1190000016523685">https://segmentfault.com/a/1190000016523685</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>grpc timeout</title>
      <link href="2021/02/02/45cdd728eaedd297399cf9b394b7607b/"/>
      <url>2021/02/02/45cdd728eaedd297399cf9b394b7607b/</url>
      
        <content type="html"><![CDATA[<p><a href="https://xiaomi-info.github.io/2019/12/30/grpc-deadline/">https://xiaomi-info.github.io/2019/12/30/grpc-deadline/</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>go timeout</title>
      <link href="2021/02/02/42e7dd653cad93cfc770da2b9e87f45f/"/>
      <url>2021/02/02/42e7dd653cad93cfc770da2b9e87f45f/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/gaorong/p/11336834.html">golang timeoutHandler解析及kubernetes中的变种</a><br><a href="http://xiaorui.cc/archives/7131">go http server感应连接中断及超时控制</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>百万架构（二）</title>
      <link href="2021/01/31/9cfc52cc4680e44eb175794d6cf0d680/"/>
      <url>2021/01/31/9cfc52cc4680e44eb175794d6cf0d680/</url>
      
        <content type="html"><![CDATA[<p>1.高可用手段</p><blockquote><blockquote><p>冗余-&gt;无状态化<br>幂等性-&gt;负载均衡<br>超时机制-&gt;异步化设计<br>数据复制/缓存/sharding-&gt;服务熔断降级限流<br>架构拆分，服务治理</p></blockquote></blockquote><p>服务监控：日志-&gt;flume-&gt;kafka-&gt;spark</p><p>手段：<br>1.服务分级</p><p>2.高并发设计手段<br>性能优化目标</p><p>优化手段<br>1.空间换时间：时间是瓶颈时，利用缓存<br>2.时间换空间：数据大小是瓶颈，压缩、减少无效数据<br>3.找到系统的瓶颈：分析系统业务流程，找到关键路径并分解优化。<br>调用多少rpc，载入多少数据，使用什么算法，非核心流程是否可以异步化，没有数据依赖的逻辑是否可以并行化等等。</p><p>优化层次<br>1.架构设计层次：如何拆分使得整体负载低，较少系统内部开销等。<br>2.算法逻辑层次：算法是否高效，是否使用无锁数据结构等<br>3.代码优化层次：关注代码细节，代码实现是否合理，是否创建过多的对象，循环遍历是否高效，缓存是否利用合理，是否重用计算结果等。<br>从整体到细节，从全局到细节的视角进行优化</p><p>3.服务无状态化设计<br>4.服务负载均衡设计<br>5.服务幂等性设计<br>6.分布式锁设计<br>7.分布式事务<br>8.服务降级设计<br>9.服务限流/熔断设计<br>10.服务的灰度发布<br>11.服务全链路压测</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>百万架构（一）</title>
      <link href="2021/01/30/b84b095435272d5e437e8ed033e30dd1/"/>
      <url>2021/01/30/b84b095435272d5e437e8ed033e30dd1/</url>
      
        <content type="html"><![CDATA[<p>1.降本提效<br>2.快速完成迭代，快速交付<br>架构演进：单体-》水平(SOA面向服务)-&gt;微服务-》seviceMesh</p><p><strong>mq</strong><br>任何架构2个服务之间添加一个mq，则会变成异步架构<br><strong>想提升吞吐量</strong>，插入mq，越早插入越好。<br>不是所有场景都可以加mq。比如读请求，对数据一致性要求强的写请求。对一致性要求弱的请求可以用mq（如社交场景）。</p><p>1.push or pull ？<br>2.同步或者异步架构？</p><p>现在项目处于微服务阶段，下一个阶段才是serviceMesh，不能急。<br>公用包或者公用组件拆分后，下一步就是下层为公共服务了。</p><p>1.互联网发展的三个阶段<br>2.互联网架构演进之路<br>3.单体架构设计与实践<br>4.水分分层架构设计与实践<br>5.面向服务架构设计与实践<br>6微服务架构设计与实践<br>7.服务网格架构设计与实践<br>8.千亿级真实案例实践</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>go ast</title>
      <link href="2021/01/30/b6ce09d0d8d0ec287673a5f164344066/"/>
      <url>2021/01/30/b6ce09d0d8d0ec287673a5f164344066/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/double12gzh/p/13632267.html">1</a><br><a href="https://blog.csdn.net/weixin_33896726/article/details/93181205">2</a><br><a href="https://www.jianshu.com/p/e38786de29c7?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=seo_notes&amp;utm_source=recommendation">3 api说明</a><br><a href="https://yuroyoro.github.io/goast-viewer/index.html">https://yuroyoro.github.io/goast-viewer/index.html</a><br><a href="https://github.com/yuroyoro/goast-viewer">https://github.com/yuroyoro/goast-viewer</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> ast </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis、rabbitmq延迟队列对比</title>
      <link href="2021/01/28/26e0dc7d60f2c6f586d7f6341954fdd2/"/>
      <url>2021/01/28/26e0dc7d60f2c6f586d7f6341954fdd2/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/rainy-shurun/p/5394334.html">延迟队列对比</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>go reflect操作channel以及性能</title>
      <link href="2021/01/07/81ed51008e6a39f4f56c42ed59043ed4/"/>
      <url>2021/01/07/81ed51008e6a39f4f56c42ed59043ed4/</url>
      
        <content type="html"><![CDATA[<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">"reflect"</span><br><span class="line">"testing"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func createCase(cases ...chan int) []reflect.SelectCase {</span><br><span class="line">var se []reflect.SelectCase</span><br><span class="line"></span><br><span class="line">for i, send := range cases {</span><br><span class="line">v := reflect.ValueOf(i)</span><br><span class="line">se = append(se, reflect.SelectCase{</span><br><span class="line">Dir:  reflect.SelectSend,</span><br><span class="line">Chan: reflect.ValueOf(send),</span><br><span class="line">Send: v,</span><br><span class="line">})</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">for _, rev := range cases {</span><br><span class="line">se = append(se, reflect.SelectCase{</span><br><span class="line">Dir:  reflect.SelectRecv,</span><br><span class="line">Chan: reflect.ValueOf(rev),</span><br><span class="line">})</span><br><span class="line">}</span><br><span class="line">return se</span><br><span class="line">}</span><br><span class="line">func BenchmarkSelectTest(b *testing.B) {</span><br><span class="line">ch1 := make(chan int, 10)</span><br><span class="line">ch2 := make(chan int, 10)</span><br><span class="line">chs := createCase(ch1, ch2)</span><br><span class="line">b.ResetTimer()</span><br><span class="line">for i := 0; i &lt; b.N; i++ {</span><br><span class="line">reflect.Select(chs)</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">func BenchmarkNormalTest(b *testing.B) {</span><br><span class="line">ch1 := make(chan int, 10)</span><br><span class="line">ch2 := make(chan int, 10)</span><br><span class="line">b.ResetTimer()</span><br><span class="line">for i := 0; i &lt; b.N; i++ {</span><br><span class="line">select {</span><br><span class="line">case ch1 &lt;- 1:</span><br><span class="line">case ch2 &lt;- 2:</span><br><span class="line">case &lt;-ch1:</span><br><span class="line">case &lt;-ch2:</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>测试结果</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">goos: darwin</span><br><span class="line">goarch: amd64</span><br><span class="line">BenchmarkSelectTest</span><br><span class="line">BenchmarkSelectTest-8    2425524       421 ns/op</span><br><span class="line">BenchmarkNormalTest</span><br><span class="line">BenchmarkNormalTest-8   12175238        98.7 ns/op</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>go脚本阻塞问题排查</title>
      <link href="2021/01/06/dd652ea8745f91bc701414d3817a4a65/"/>
      <url>2021/01/06/dd652ea8745f91bc701414d3817a4a65/</url>
      
        <content type="html"><![CDATA[<h2><span id="前言">前言</span></h2><p style="text-indent:2em">有天一个同事突然找我说他的线上的定时脚本跑着跑着不退出了，这种情况也不是必现，不过出现的概率还是很高的。虽然这个脚本可以强制退出，但是它是定时任务，一直不退出，时间一长了，会耗尽k8s集群的资源，进而影响其他服务。于是他叫我帮忙排查下这个问题。当时我一听到故事背景，心里想这指不定是哪里堵塞了。在未看代码的情况下，按照以往经验，有可能是网络请求没设置超时时间、死循环、死锁、或者其他堵塞。已知排查这类问题的方法：1.查看代码或者打印日志，缩小范围(最无奈之举，兜底方案，有时候可能非常有效) 2.借助工具</p><h2><span id="准备">准备</span></h2><p>作为一名高级gopher，哪能没有点“才艺”？下面是常用“道具”。1）net/http/pprof (on-cpu) 2）github.com/felixge/fgprof (off-cpu)<br>正常一次性脚本，执行时间是短暂，应该用runtime/pprof来收集运行时数据分析。但是本次是一个堵塞的脚本，故可用net/http/pprof进行分析，而且可以远程访问。net/http/pprof针对线程花费在CPU上的时间进行分析即on-cpu。经常pprof都和fgprof配合使用，珠联璧合。<br>添加几行代码，重新编译，部署，执行脚本。 </p><p><img src="/2021/01/06/dd652ea8745f91bc701414d3817a4a65/1610165339001.png"></p><h2><span id="分析">分析</span></h2><p>由于k8s集群未将9091端口开放，故用常规命令kubectl port-forward进行端口转发，<br>然后在浏览器上进入<a href="http://127.0.0.1:9091/debug/pprof/%E7%95%8C%E9%9D%A2">http://127.0.0.1:9091/debug/pprof/界面</a> 。<br>先观察pprof ,界面如下：</p><p><img src="/2021/01/06/dd652ea8745f91bc701414d3817a4a65/1609946216480.png"></p><p>可以看到block 和mutext都正常。按照之前的猜想，肯定得看goroutine，那就直奔主题。一般协程泄漏或者堵塞都是看这的。进去看看每个协程这会都在干啥？如下图</p><p><img src="/2021/01/06/dd652ea8745f91bc701414d3817a4a65/1609946790604.png"></p><p>可以看出现在总共有55协程。其中12个协程是在执行/usr/local/go/src/database/sql/sql.go:1052 这行代码。刷新几次浏览器，发现所有协程仍然还是在执行这些代码。此时看了前面几十个协程在执行的代码都比较常规，并没有发现异常。  再往下看发现clickhouse相关代码，问了同事，其实脚本中并没有使用clickhouse，那估计是不小心被引入了。继续看，重头戏来了。</p><p><img src="/2021/01/06/dd652ea8745f91bc701414d3817a4a65/1609948850980.png"></p><p>这里明确的出现了业务代码，是amqp相关的代码(问了同事，说也是不小心引入的，其实脚本并不需要)，这就完全不能忽视了。对比了下源码位置，发现这是一段程序退出时释放资源(defer cleanup())的代码。这是一个很重要的信息。根据调用链，看到目前协程正在执行sync.runtime_SemacquireMutex 这行代码。runtime_SemacquireMutex是什么呢？之前看过sync.Mutex源码，知道这是利用信号量挂起一个协程的操作。再结合我们在退出程序资源释放是同步的，也就是说如果资源释放卡住的话，会导致程序卡住。所以说这很可能就是导致程序堵塞住的原因。有了这么个可疑点，当然不能放过，继续深究，看到底是释放哪个资源。仔细看上图，发现是下图的816行，如下图所示：</p><p><img src="/2021/01/06/dd652ea8745f91bc701414d3817a4a65/1609950118059.png"></p><p>session.Close()是在一个闭包函数内，为了让外面可以主动关闭amqp的连接。目前我们的用法是在主程序退出时执行，如下图：</p><p><img src="/2021/01/06/dd652ea8745f91bc701414d3817a4a65/1609950630371.png"></p><p>这么一想，runtime_SemacquireMutex导致主程序堵塞就更顺理成章了。加个日志，验证一波，防止误杀。</p><p><img src="/2021/01/06/dd652ea8745f91bc701414d3817a4a65/1610156304165.png"></p><p>看下pod日志</p><p><img src="/2021/01/06/dd652ea8745f91bc701414d3817a4a65/1609950812678.png"></p><p>至此知道罪魁祸首的是amqp释放资源堵塞住了，也经过验证了。本来这个脚本就不需要用到amqp，是因为不小引入的，所以代码稍做修改就能解决本脚本的问题了。( 不想看导致amqp释放资源堵塞的原因剖析的话，可以跳过直接看结论吧)</p><h2><span id="刨根问底">刨根问底</span></h2><p>为什么引入了amqp就会有这个问题呢？这个脚本中出现了这个问题，那么线上会不会也有这个问题？这个问题产生的真实原因是什么呢？需要解决问题，还是得复现，也就是知道触发场景。根据脚本的情况，很容易得出复现方案：启动amqp，但是不往amqp中发送消息，过几秒后关闭amqp连接即上面的session.Close()。写个demo，很容易就复现了。还是需要看这部分</p><p><img src="/2021/01/06/dd652ea8745f91bc701414d3817a4a65/1609951195653.png"></p><p>上面看得出来调用顺序： shutdown-&gt;sync.Once.Do 然后就被lock住了。Do执行的方法是</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">c.destructor.Do(func() {</span><br><span class="line">    c.m.Lock()</span><br><span class="line">    defer c.m.Unlock()</span><br><span class="line">    if err != nil {</span><br><span class="line">        for _, c := range c.closes {</span><br><span class="line">            c &lt;- err </span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    //省略无关代码</span><br><span class="line">    ...</span><br><span class="line">    c.channels = map[uint16]*Channel{}</span><br><span class="line">    c.allocator = newAllocator(1, c.Config.ChannelMax)</span><br><span class="line">    c.noNotify = true</span><br><span class="line">} </span><br></pre></td></tr></tbody></table></figure><p>都知道sync.Once的参数f是只能被执行一次的,但是sync.Once可以被执行多次。那么为什么这个地方会被锁住呢？只有一种可能性那就是：sync.Once至少被调用1次，前一次调用一直没有退出，导致下一次调用被lock了。经过调试发现395行堵塞了。关键性代码如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">393   if err != nil {</span><br><span class="line">394      for _, c := range c.closes {</span><br><span class="line">395          c &lt;- err  //出现堵塞</span><br><span class="line">396     }</span><br><span class="line">397  } </span><br></pre></td></tr></tbody></table></figure><p>熟悉channel的话，都知道以下几种情况会导致堵塞：1.有缓冲channel写满  2.无缓冲channel没有接受者。但是还是得详细定位，然后对c.closes一探究竟，看到了一个惊天大发现，如下：<br><img src="/2021/01/06/dd652ea8745f91bc701414d3817a4a65/1610163284654.png"><br>图中dataqsiz为0表示这是一个无缓冲channel, 继续往下看recvq是一个空的双向链表(recvq是等待接收的goroutine组成的双向链表)。那么意味着这个无缓冲channel没有接收者，而395行又往 channel里面放数据，所以必然导致堵塞。<br>图中的buf显示这个channel的类型是github.com/streadway/amqp.Error。那么在我们封装的amqp驱动里面搜索一下amqp.Error，就发现notifyChanClose和notifyConnClose这2个用于接收Connection closed和Channel closed通知的channel,以及他们的初始化：<br><img src="/2021/01/06/dd652ea8745f91bc701414d3817a4a65/1610164425886.png"><br>至此算是完全知道原因了，后续直接将2个channel改成缓冲为1的channel就解决问题了。</p><h2><span id="总结">总结</span></h2><ol><li>在写依赖注入时，需要明确本服务需要哪些驱动，尽量不引入没有用到的驱动。</li><li>pprof的goroutine可以很好的分析协程泄漏，进程堵塞这类问题。</li><li>在用channel时需要考虑清楚到底用有缓冲还是无缓冲的。</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>深度解密Go语言之unsafe</title>
      <link href="2021/01/05/be3809ec9b6e5427edb172170b8e194e/"/>
      <url>2021/01/05/be3809ec9b6e5427edb172170b8e194e/</url>
      
        <content type="html"><![CDATA[<p>转载：<a href="https://zhuanlan.zhihu.com/p/67852800">https://zhuanlan.zhihu.com/p/67852800</a><br> 如果你是一个高级gopher，那么你对于unsafe包肯定不陌生，unsafe.Pointer 位于 unsafe 包。如果你还只是初学go，那么你有必要学学unsafe，因为它比较强大，可以让你做不少操作内存的事。</p>]]></content>
      
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> go源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试题</title>
      <link href="2021/01/04/013d996a3c896c2cf4a00bad421c1298/"/>
      <url>2021/01/04/013d996a3c896c2cf4a00bad421c1298/</url>
      
        <content type="html"><![CDATA[<p><strong>选择题</strong></p><p>1.下面正确的是 ()<br>   </p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">func main() {</span><br><span class="line">var (</span><br><span class="line">a = 2</span><br><span class="line">f = func(x *int) {</span><br><span class="line">*x += *x</span><br><span class="line">var c int</span><br><span class="line">c = 1</span><br><span class="line">x = &amp;c</span><br><span class="line">}</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">f(&amp;a)</span><br><span class="line">fmt.Println(a)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br>A. a=2<br>B. a=4<br>C. a=1<br>D. 以上皆不是<p></p><p>参考答案：B<br>2.【多选】通过指针变量访问其成员变量，下面语法正确的是（）<br>A. (&amp;p).age<br>B. p.age<br>C. p-&gt;age<br>D. (*p).age</p><p>参考答案：BD<br>3.【多选】下面语法正确的是（）<br>A. ch := make(chan int)<br>B. &lt;- ch<br>C. ch &lt;-<br>D. var ch chan int</p><p>参考答案：ABD</p><p>4.【多选】下面的初始化，正确的是（）<br>A. s := […]int{1, 2, 3}<br>B. s := make([]int, 0)<br>C. s := make([]int, 5, 10)<br>D. s := []int{1, 2, 3, 4, 5}</p><p>参考答案：ABCD</p><p>5.【多选】下面属于关键字的是（）<br>A. defer<br>B. go<br>C. class<br>D. fallthrough</p><p>参考答案：ABD</p><p>6.【多选】下面关于匿名函数的说法正确的是（）<br>A. 匿名函数是不需要定义函数名的一种函数实现方式<br>B. defer后面可以直接接着匿名函数<br>C. 匿名函数可以直接执行<br>D. 匿名函数对参数与返回值有一定要求</p><p>参考答案：ABC</p><p>7.【多选】下面关于闭包的说法正确的是（）<br>A. 闭包会引用到函数外的变量<br>B. 闭包的实现确保只要闭包还在被使用，被闭包引用的变量就一直存在<br>C. 匿名函数可以直接执行<br>D. 匿名函数对参数与返回值有一定的要求</p><p>参考答案：ABC</p><p>8.【多选】关于switch语句，下面说法正确的有（）<br>A. 条件表达式必须为常量或者整数<br>B. 单个case中，可以出现多个结果选项<br>C. 需要用break来明确退出一个case<br>D. 在有default的情况下，当所有case都不满足时，则处理defalut逻辑</p><p>参考答案：BD</p><p>9.【多选】关于cap函数的适用类型，下面说法正确的是（）<br>A. array<br>B. slice<br>C. map<br>D. channel</p><p>参考答案：ABD</p><p>10.【多选】关于变量的自增和自减操作，下面语句正确的是（）<br>A.</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">i := 1</span><br><span class="line">i++</span><br></pre></td></tr></tbody></table></figure><p>B.</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">i := 1</span><br><span class="line">j = i++</span><br></pre></td></tr></tbody></table></figure><p>C.</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">i := 1</span><br><span class="line">++i</span><br></pre></td></tr></tbody></table></figure><p>D.</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">i := 1</span><br><span class="line">i--</span><br></pre></td></tr></tbody></table></figure><p>参考答案：AD</p><p>11.下面哪个是正确的（）</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">func f() (a int) {</span><br><span class="line">defer func() {</span><br><span class="line">a = 3</span><br><span class="line">}()</span><br><span class="line">defer func() {</span><br><span class="line">a = 4</span><br><span class="line">}()</span><br><span class="line">return 2</span><br><span class="line">}</span><br><span class="line">func main() {</span><br><span class="line">a := f()</span><br><span class="line">fmt.Println(a)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>A. a = 0<br>B. a = 2<br>C. a = 3<br>D. a = 4</p><p>参考答案：C</p><p>12.下面说法正确的是（）<br>A. 一个包中，可以包含多个init函数<br>B. 程序编译时，先执行依赖包的init函数，再执行main包内的init函数<br>C. main包中，不能有init函数<br>D. init函数可以被其他函数调用</p><p>13.下面这段代码输出什么？</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (  </span><br><span class="line">    "fmt"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {  </span><br><span class="line">    a := [4]int{1, 2, 3,4}</span><br><span class="line">    t := a[1:2:4]</span><br><span class="line">    fmt.Println(cap(t))</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>A. 1<br>B. 2<br>C. 3<br>C. 4</p><p>参考答案：C</p><ol start="14"><li>下面这段代码输出的结果是（）？<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">var a, b int</span><br><span class="line">f := func() (a int) {</span><br><span class="line">    if a &gt;= 1 {</span><br><span class="line">        a += 2</span><br><span class="line">    } else {</span><br><span class="line">        a += 1</span><br><span class="line">    }</span><br><span class="line">    return a</span><br><span class="line">}</span><br><span class="line">f1 := func() int {</span><br><span class="line">    if b &gt;= 1 {</span><br><span class="line">        b += 2</span><br><span class="line">    } else {</span><br><span class="line">        b += 1</span><br><span class="line">    }</span><br><span class="line">    return b</span><br><span class="line">}</span><br><span class="line">f()</span><br><span class="line">f()</span><br><span class="line">f1()</span><br><span class="line">f1()</span><br><span class="line">fmt.Println(a,",",b)</span><br></pre></td></tr></tbody></table></figure>A. 0,0<br>B. 3,3<br>C. 0,3<br>D. 3,0</li></ol><p>参考答案：C</p><ol start="15"><li>下面哪种定义变量方式是错的？（）<br>A. var a int = 1<br>B. var b int<br>C. var c int := 1<br>D. d := 1</li></ol><p>参考答案：C</p><p><strong>简答题</strong><br>1.说说进程，线程，协程之间的区别？<br>2.go语言中new和make的区别</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>go中子协程panic无法recover情况</title>
      <link href="2021/01/04/191db0f06bb6d999d53de0f32d46a98a/"/>
      <url>2021/01/04/191db0f06bb6d999d53de0f32d46a98a/</url>
      
        <content type="html"><![CDATA[<p><img src="/2021/01/04/191db0f06bb6d999d53de0f32d46a98a/1619318021095.jpg"></p><h2><span id="举例">举例</span></h2><p>1.并发读写map</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">m := make(map[int]int)</span><br><span class="line">for i := 0; i &lt; 10; i++ {</span><br><span class="line">v := i</span><br><span class="line">go func() {</span><br><span class="line">defer func() {</span><br><span class="line">if e := recover(); e != nil {</span><br><span class="line">log.Println(e)</span><br><span class="line">}</span><br><span class="line">}()</span><br><span class="line">m[1] = v</span><br><span class="line">}()</span><br><span class="line">}</span><br><span class="line">select{}</span><br></pre></td></tr></tbody></table></figure><p>2.sync.RWMutex,sync.Mutex unlock一个已经解锁或者未曾加锁的锁时</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">go func() {</span><br><span class="line">defer func() {</span><br><span class="line">if e := recover(); e != nil {</span><br><span class="line">log.Println(e)</span><br><span class="line">}</span><br><span class="line">}()</span><br><span class="line">//var l sync.Mutex</span><br><span class="line">var l sync.RWMutex</span><br><span class="line">//l.Lock()</span><br><span class="line">//l.Unlock()</span><br><span class="line">l.Unlock()</span><br><span class="line">}()</span><br><span class="line">select {}</span><br></pre></td></tr></tbody></table></figure><h2><span id="刨根问底">刨根问底</span></h2><p>查看源码发现都是调用了panic.go文件中throw方法</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//go:nosplit</span><br><span class="line">func throw(s string) {</span><br><span class="line">// Everything throw does should be recursively nosplit so it</span><br><span class="line">// can be called even when it's unsafe to grow the stack.</span><br><span class="line">systemstack(func() {</span><br><span class="line">print("fatal error: ", s, "\n")</span><br><span class="line">})</span><br><span class="line">gp := getg()</span><br><span class="line">if gp.m.throwing == 0 {</span><br><span class="line">gp.m.throwing = 1</span><br><span class="line">}</span><br><span class="line">fatalthrow()</span><br><span class="line">*(*int)(nil) = 0 // not reached</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>真正起作用的是fatalthrow</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//go:nosplit</span><br><span class="line">func fatalthrow() {</span><br><span class="line">pc := getcallerpc()</span><br><span class="line">sp := getcallersp()</span><br><span class="line">gp := getg()</span><br><span class="line">// Switch to the system stack to avoid any stack growth, which</span><br><span class="line">// may make things worse if the runtime is in a bad state.</span><br><span class="line">systemstack(func() {</span><br><span class="line">startpanic_m()</span><br><span class="line"></span><br><span class="line">if dopanic_m(gp, pc, sp) {</span><br><span class="line">// crash uses a decent amount of nosplit stack and we're already</span><br><span class="line">// low on stack in throw, so crash on the system stack (unlike</span><br><span class="line">// fatalpanic).</span><br><span class="line">crash()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">exit(2) //真正导致退出无法捕获的地方</span><br><span class="line">})</span><br><span class="line"></span><br><span class="line">*(*int)(nil) = 0 // not reached</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>至此知道了导致上述2中情况抛异常，但是无法捕获异常的真正原因了</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>大厂技术博客</title>
      <link href="2021/01/03/1fbd38bc7a42258dd060aab833aa0e7a/"/>
      <url>2021/01/03/1fbd38bc7a42258dd060aab833aa0e7a/</url>
      
        <content type="html"><![CDATA[<ul><li><a href="https://tech.meituan.com/">美团技术博客</a></li><li><a href="https://blogs.360.cn/">360技术博客</a></li><li><a href="https://xiaomi-info.github.io/">小米信息部技术团队博客</a></li><li><a href="http://ifeve.com/">并发编程网</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自动收集go程序性能</title>
      <link href="2021/01/03/918ad0ae9bc63713a009a5e95abc25b5/"/>
      <url>2021/01/03/918ad0ae9bc63713a009a5e95abc25b5/</url>
      
        <content type="html"><![CDATA[<p>Go 项目做的比较大(主要说代码多，参与人多)之后，可能会遇到类似下面这样的问题：</p><ul><li>程序老是半夜崩，崩了以后就重启了，我也醒不来，现场早就丢了，不知道怎么定位</li><li>这压测开压之后，随机出问题，可能两小时，也可能五小时以后才出问题，这我蹲点蹲出痔疮都不一定能等到崩溃的那个时间点啊</li><li>有些级联失败，最后留下现场并不能帮助我们准确地判断问题的根因，我们需要出问题时第一时间的现场Go 内置的 pprof 虽然是问题定位的神器，但是没有办法让你恰好在出问题的那个时间点，把相应的现场保存下来进行分析。特别是一些随机出现的内存泄露、CPU 抖动，等你发现有泄露的时候，可能程序已经 OOM 被 kill 掉了。而 CPU 抖动，你可以蹲了一星期都不一定蹲得到。<br>这个问题最好的解决办法是 continuous profiling。那么我们就可以在这个点自动地去做一些事情，比如：</li><li>把当前的 goroutine 栈 dump 下来</li><li>把当前的 cpu profile dump 下来</li><li>把当前的 off-cpu profile dump 下来</li><li>不怕死的话，也可以 dump 几秒的 trace<br>物理机中的数据采集，可以使用 <a href="https://github.com/shirou/gopsutil">gopsutil</a>，docker 中的数据采集，可以参考少量 <a href="https://github.com/containerd/cgroups">cgroups</a>中的实现。<br>文件保存下来，再慢慢分析。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> 性能 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单元测试如何mock time.Now()</title>
      <link href="2021/01/03/572b8e78a3d8eccade241d04c335b8c9/"/>
      <url>2021/01/03/572b8e78a3d8eccade241d04c335b8c9/</url>
      
        <content type="html"><![CDATA[<h2><span id="前言">前言</span></h2><p>在测试功能的过程中需要对时间进行调整，比如开发一个活动，需要改时间，让活动开始或者结束。碰到这类需求其实有几种方案：</p><ul><li>改变系统时钟。虽然很直接简单，但是并非是个好主意。作者对这种方式的坏处详细进行了解释（之前尝试过改docker时间，但是最后影响了其他容器，被运维发现了(尴尬的一批)）</li><li>传递当前时间。即修改方法签名，接受时间参数，以便在单元测试的时候传入所期望的时间。虽然有效，但是不够灵活</li><li>创建一个时钟服务。基于上面的方法，定义一个时钟服务接口，正常运行就注入一个系统时钟，单元测试就Mock一个（使用NSubstitute作为mock框架）期望时间进</li><li>通过mock时间函数来完成：最优雅，影响最小。</li></ul><p>下面介绍如果通过mock时间函数来达到调时间的效果。<br>直接上代码</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">"log"</span><br><span class="line">"time"</span><br><span class="line"></span><br><span class="line">"bou.ke/monkey"</span><br><span class="line">)</span><br><span class="line">func main() {</span><br><span class="line">loc, _ := time.LoadLocation("Asia/Shanghai")</span><br><span class="line">    //假的时间，自己定义的时间起点</span><br><span class="line">fakeNow, _ := time.ParseInLocation("2006-01-02 15:04:05", "2020-01-03 12:00:00", loc)</span><br><span class="line">timestamp := fakeNow.Unix()</span><br><span class="line">    //起一个协程，模拟时钟运转，每隔一秒对时间戳+1</span><br><span class="line">go func() {</span><br><span class="line">t1 := time.NewTicker(time.Second)</span><br><span class="line">for {</span><br><span class="line">select {</span><br><span class="line">case &lt;-t1.C:</span><br><span class="line">timestamp += 1</span><br><span class="line">default:</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}()</span><br><span class="line">    //mock time.Now函数</span><br><span class="line">timenowPatcher := monkey.Patch(time.Now, func() time.Time {</span><br><span class="line">return time.Unix(timestamp, 0)</span><br><span class="line">})</span><br><span class="line">defer timenowPatcher.Unpatch()</span><br><span class="line">for {</span><br><span class="line">log.Printf("%v\n", time.Now().Format("2006-01-02 15:04:05"))</span><br><span class="line">time.Sleep(time.Second * 2)</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2><span id="输出">输出</span></h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">2020/01/03 12:00:02 2020-01-03 12:00:02</span><br><span class="line">2020/01/03 12:00:04 2020-01-03 12:00:04</span><br><span class="line">2020/01/03 12:00:06 2020-01-03 12:00:06</span><br><span class="line">2020/01/03 12:00:08 2020-01-03 12:00:08</span><br><span class="line">2020/01/03 12:00:10 2020-01-03 12:00:10</span><br><span class="line">2020/01/03 12:00:12 2020-01-03 12:00:12</span><br></pre></td></tr></tbody></table></figure><h2><span id="总结">总结</span></h2><p>可以封装成一个库或者一个方法，后续传入时间起点参数即可，然后就对调用者无感知了，岂不是很happy?</p>]]></content>
      
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> mock </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>待看列表</title>
      <link href="2021/01/03/fdc5edab1548e574e943a3173212a48b/"/>
      <url>2021/01/03/fdc5edab1548e574e943a3173212a48b/</url>
      
        <content type="html"><![CDATA[<p><a href="https://blog.kelu.org/category/tech.html">https://blog.kelu.org/category/tech.html</a><br><a href="https://double12gzh.github.io/archives/">https://double12gzh.github.io/archives/</a><br><a href="https://www.cnblogs.com/double12gzh/p/13661777.html">https://www.cnblogs.com/double12gzh/p/13661777.html</a><br><a href="https://blog.csdn.net/ilini/article/details/112465391">https://blog.csdn.net/ilini/article/details/112465391</a><br><a href="https://louyuting.blog.csdn.net/category_8361413.html">https://louyuting.blog.csdn.net/category_8361413.html</a><br><a href="https://github.com/overnote/over-golang">https://github.com/overnote/over-golang</a><br><a href="https://segmentfault.com/u/iolygg/articles">写代码</a></p><ul><li><a href="https://github.com/generals-space/note/tree/a9b63e9f46f28b86df409a8febd25a675cd21f38/%E8%AF%AD%E8%A8%80%E5%92%8C%E6%A1%86%E6%9E%B6/go">golan知识点</a></li><li><a href="https://github.com/liov/hoper">大杂烩式的项目</a></li><li><a href="https://dongshao.blog.csdn.net/article/details/110681373?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.control&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.control">很多go标准库(涉猎广)</a></li><li><a href="https://www.cnblogs.com/qcrao-2018/tag/Golang/">go深度解密篇</a></li></ul><p>【Russ Cox 优化过程，并附上代码】<a href="https://blog.golang.org/profiling-go-programs">https://blog.golang.org/profiling-go-programs</a></p><p>【google pprof】<a href="https://github.com/google/pprof">https://github.com/google/pprof</a></p><p>【使用 pprof 和火焰图调试 golang 应用】<a href="https://cizixs.com/2017/09/11/profiling-golang-program/">https://cizixs.com/2017/09/11/profiling-golang-program/</a></p><p>【资源合集】<a href="https://jvns.ca/blog/2017/09/24/profiling-go-with-pprof/">https://jvns.ca/blog/2017/09/24/profiling-go-with-pprof/</a></p><p>【Profiling your Golang app in 3 steps】<a href="https://coder.today/tech/2018-11-10_profiling-your-golang-app-in-3-steps/">https://coder.today/tech/2018-11-10_profiling-your-golang-app-in-3-steps/</a></p><p>【案例，压测 Golang remote profiling and flamegraphs】<a href="https://matoski.com/article/golang-profiling-flamegraphs/">https://matoski.com/article/golang-profiling-flamegraphs/</a></p><p>【煎鱼 pprof】<a href="https://segmentfault.com/a/1190000016412013">https://segmentfault.com/a/1190000016412013</a></p><p>【鸟窝 pprof】<a href="https://colobu.com/2017/03/02/a-short-survey-of-golang-pprof/">https://colobu.com/2017/03/02/a-short-survey-of-golang-pprof/</a></p><p>【关于 Go 的 7 种性能分析方法】<a href="https://blog.lab99.org/post/golang-2017-10-20-video-seven-ways-to-profile-go-apps.html">https://blog.lab99.org/post/golang-2017-10-20-video-seven-ways-to-profile-go-apps.html</a></p><p>【pprof 比较全】<a href="https://juejin.im/entry/5ac9cf3a518825556534c76e">https://juejin.im/entry/5ac9cf3a518825556534c76e</a></p><p>【通过实例来讲解分析、优化过程】<a href="https://artem.krylysov.com/blog/2017/03/13/profiling-and-optimizing-go-web-applications/">https://artem.krylysov.com/blog/2017/03/13/profiling-and-optimizing-go-web-applications/</a></p><p>【Go 作者 Dmitry Vyukov】<a href="https://github.com/golang/go/wiki/Performance">https://github.com/golang/go/wiki/Performance</a></p><p>【wolfogre 非常精彩的实战文章】<a href="https://blog.wolfogre.com/posts/go-ppof-practice/">https://blog.wolfogre.com/posts/go-ppof-practice/</a></p><p>【dave.cheney】<a href="https://dave.cheney.net/high-performance-go-workshop/dotgo-paris.html">https://dave.cheney.net/high-performance-go-workshop/dotgo-paris.html</a></p><p>【实战案例】<a href="https://www.cnblogs.com/sunsky303/p/11058808.html">https://www.cnblogs.com/sunsky303/p/11058808.html</a></p><p>【大彬 实战内存泄露】<a href="https://segmentfault.com/a/1190000019222661">https://segmentfault.com/a/1190000019222661</a></p><p>【查找内存泄露】<a href="https://www.freecodecamp.org/news/how-i-investigated-memory-leaks-in-go-using-pprof-on-a-large-codebase-4bec4325e192/">https://www.freecodecamp.org/news/how-i-investigated-memory-leaks-in-go-using-pprof-on-a-large-codebase-4bec4325e192/</a></p><p>【雷神 3 性能优化】<a href="https://diducoder.com/sotry-about-sqrt.html">https://diducoder.com/sotry-about-sqrt.html</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>go利用monkey框架的动态代理实现AOP</title>
      <link href="2021/01/03/a62f89307e84c21a952ca86ad65df11d/"/>
      <url>2021/01/03/a62f89307e84c21a952ca86ad65df11d/</url>
      
        <content type="html"><![CDATA[<h3><span id="前言">前言</span></h3><p>一直在寻找动态代理的实现方案，几经波折，终于找到了位牛人写的框架monkey，简单喵了下其源码，貌似是通过替换底层函数字节码来达到动态替换效果，后续再仔细拜读。这里我利用monkey框架实现了一个简单的AOP框架<br>monkey项目地址：<a href="https://github.com/bouk/monkey">https://github.com/bouk/monkey</a><br>aop码云地址：<a href="https://gitee.com/sqxwww/aop">https://gitee.com/sqxwww/aop</a></p><h2><span id="aop框架">AOP框架</span></h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line">package aop</span><br><span class="line"> </span><br><span class="line">import (</span><br><span class="line">"bou.ke/monkey"</span><br><span class="line">"fmt"</span><br><span class="line">"reflect"</span><br><span class="line">"regexp"</span><br><span class="line">)</span><br><span class="line"> </span><br><span class="line">//连接点</span><br><span class="line">type JoinPoint struct {</span><br><span class="line">Receiver interface{}</span><br><span class="line">Method   reflect.Method</span><br><span class="line">Params   []reflect.Value</span><br><span class="line">Result   []reflect.Value</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line">func NewJoinPoint(receiver interface{}, params []reflect.Value, method reflect.Method) *JoinPoint {</span><br><span class="line">point := &amp;JoinPoint{</span><br><span class="line">Receiver: receiver,</span><br><span class="line">Params: params,</span><br><span class="line">Method: method,</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line">fn := method.Func</span><br><span class="line">fnType := fn.Type()</span><br><span class="line">nout := fnType.NumOut()</span><br><span class="line">point.Result = make([]reflect.Value, nout)</span><br><span class="line">for i := 0; i &lt; nout; i++ {</span><br><span class="line">//默认返回空值</span><br><span class="line">point.Result[i] = reflect.Zero(fnType.Out(i))</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line">return point</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line">//切面接口</span><br><span class="line">type AspectInterface interface {</span><br><span class="line">Before(point *JoinPoint) bool</span><br><span class="line">After(point *JoinPoint)</span><br><span class="line">Finally(point *JoinPoint)</span><br><span class="line">GetAspectExpress() string</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line">//切面列表</span><br><span class="line">var aspectList = make([]AspectInterface, 0)</span><br><span class="line"> </span><br><span class="line">//注册切点</span><br><span class="line">func RegisterPoint(pointType reflect.Type) {</span><br><span class="line">pkgPth := pointType.PkgPath()</span><br><span class="line">receiverName := pointType.Name()</span><br><span class="line">if pointType.Kind() == reflect.Ptr {</span><br><span class="line">pkgPth = pointType.Elem().PkgPath()</span><br><span class="line">receiverName = pointType.Elem().Name()</span><br><span class="line">}</span><br><span class="line">for i := 0; i &lt; pointType.NumMethod(); i++ {</span><br><span class="line">method := pointType.Method(i)</span><br><span class="line">//方法位置字符串"包名.接收者.方法名"，用于匹配代理</span><br><span class="line">methodLocation := fmt.Sprintf("%s.%s.%s", pkgPth, receiverName, method.Name)</span><br><span class="line">var guard *monkey.PatchGuard</span><br><span class="line">var proxy = func(in []reflect.Value) []reflect.Value {</span><br><span class="line">guard.Unpatch()</span><br><span class="line">defer guard.Restore()</span><br><span class="line">receiver := in[0]</span><br><span class="line">point := NewJoinPoint(receiver, in[1:], method)</span><br><span class="line">defer finallyProcessed(point, methodLocation)</span><br><span class="line">if !beforeProcessed(point, methodLocation) {</span><br><span class="line">return point.Result</span><br><span class="line">}</span><br><span class="line">point.Result = receiver.MethodByName(method.Name).Call(in[1:])</span><br><span class="line">afterProcessed(point, methodLocation)</span><br><span class="line">return point.Result</span><br><span class="line">}</span><br><span class="line">//动态创建代理函数</span><br><span class="line">proxyFn := reflect.MakeFunc(method.Func.Type(), proxy)</span><br><span class="line">//利用monkey框架替换代理函数</span><br><span class="line">guard = monkey.PatchInstanceMethod(pointType, method.Name, proxyFn.Interface())</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line">//注册切面</span><br><span class="line">func RegisterAspect(aspect AspectInterface) {</span><br><span class="line">aspectList = append(aspectList, aspect)</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line">//前置处理</span><br><span class="line">func beforeProcessed(point *JoinPoint, methodLocation string) bool {</span><br><span class="line">for _, aspect := range aspectList {</span><br><span class="line">if !isAspectMatch(aspect.GetAspectExpress(), methodLocation) {</span><br><span class="line">continue</span><br><span class="line">}</span><br><span class="line">if !aspect.Before(point) {</span><br><span class="line">return false</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">return true</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line">//后置处理</span><br><span class="line">func afterProcessed(point *JoinPoint, methodLocation string) {</span><br><span class="line">for i := len(aspectList) - 1; i &gt;= 0; i-- {</span><br><span class="line">aspect := aspectList[i]</span><br><span class="line">if !isAspectMatch(aspect.GetAspectExpress(), methodLocation) {</span><br><span class="line">continue</span><br><span class="line">}</span><br><span class="line">aspect.After(point)</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line">//最终处理</span><br><span class="line">func finallyProcessed(point *JoinPoint, methodLocation string) {</span><br><span class="line">for i := len(aspectList) - 1; i &gt;= 0; i-- {</span><br><span class="line">aspect := aspectList[i]</span><br><span class="line">if !isAspectMatch(aspect.GetAspectExpress(), methodLocation) {</span><br><span class="line">continue</span><br><span class="line">}</span><br><span class="line">aspect.Finally(point)</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line">func isAspectMatch(aspectExpress, methodLocation string) bool {</span><br><span class="line">//aspectExpress采用正则表达式</span><br><span class="line">pattern, err := regexp.Compile(aspectExpress)</span><br><span class="line">if err != nil {</span><br><span class="line">return false</span><br><span class="line">}</span><br><span class="line">return pattern.MatchString(methodLocation)</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h2><span id="测试">测试</span></h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"> </span><br><span class="line">import (</span><br><span class="line">"fmt"</span><br><span class="line">"reflect"</span><br><span class="line">"aop/aop"</span><br><span class="line">)</span><br><span class="line"> </span><br><span class="line">func init()  {</span><br><span class="line">aop.RegisterPoint(reflect.TypeOf((*HelloAop)(nil)))</span><br><span class="line">aop.RegisterAspect(&amp;Aspect{})</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line">type Aspect struct {}</span><br><span class="line"> </span><br><span class="line">func (a *Aspect) Before(point *aop.JoinPoint) bool {</span><br><span class="line">fmt.Println("before")</span><br><span class="line">return true</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line">func (a *Aspect) After(point *aop.JoinPoint) {</span><br><span class="line">fmt.Println("after")</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line">func (a *Aspect) Finally(point *aop.JoinPoint) {</span><br><span class="line">fmt.Println("finally")</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line">func (a *Aspect) GetAspectExpress() string {</span><br><span class="line">return ".*\\.HelloAop"</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line">type HelloAop struct {</span><br><span class="line"> </span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line">func (h *HelloAop) HelloAop() {</span><br><span class="line">fmt.Println("helloAop")</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line">func main()  {</span><br><span class="line">h := &amp;HelloAop{}</span><br><span class="line">h.HelloAop()</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h2><span id="测试结果">测试结果</span></h2><p>执行：go run -gcflags=-l main.go</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">before</span><br><span class="line">helloAop</span><br><span class="line">after</span><br><span class="line">finally</span><br></pre></td></tr></tbody></table></figure><h2><span id="注意">注意</span></h2><p>monkey官网原话：Monkey sometimes fails to patch a function if inlining is enabled. Try running your tests with inlining disabled, for example: go test -gcflags=-l. The same command line argument can also be used for build.</p><p>即monkey有些环境无法替换内联函数，在编译时禁掉内联函数即可。go build/run/install -gcflags=-l main.go</p><h2><span id="缺陷">缺陷</span></h2><p>1.替换为全局替换，若需只调用原生方法则需先解除替换，比较麻烦</p><p>2.每次执行都要遍历所有代理列表，可以考虑在注册代理或注册方法时将方法与代理关联上，去掉不必要的遍历</p>]]></content>
      
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> aop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>markdown编辑技巧</title>
      <link href="2021/01/02/b1cd209b6ca38a18a31684a0500d8c5f/"/>
      <url>2021/01/02/b1cd209b6ca38a18a31684a0500d8c5f/</url>
      
        <content type="html"><![CDATA[<h2><span id="1字体颜色">1.字体颜色</span></h2><p><font color="#FF0000">红色</font></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;font color=#FF0000 &gt;红色&lt;/font&gt;</span><br><span class="line">红：255，0，0 #FF0000</span><br><span class="line">橙: 255,125,0 #FF7D00</span><br><span class="line">黄：255，255，0 #FFFF00</span><br><span class="line">绿：0，255，0 #00FF00</span><br><span class="line">蓝：0，0，255 #0000FF</span><br><span class="line">靛: 0,255,255 #00FFFF</span><br><span class="line">紫: 255,0,255 #FF00FF</span><br></pre></td></tr></tbody></table></figure><h2><span id="2字体">2.字体</span></h2><p><font face="微软雅黑">微软雅黑</font><br><font face="黑体">黑体</font></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;font face="微软雅黑" &gt;微软雅黑字体&lt;/font&gt;</span><br><span class="line">&lt;font face="黑体" &gt;黑体&lt;/font&gt;</span><br></pre></td></tr></tbody></table></figure><h2><span id="3-字号">3. 字号</span></h2><p><font size="12">12号字</font></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;font size=12 &gt;12号字&lt;/font&gt;</span><br></pre></td></tr></tbody></table></figure><h2><span id="4加粗-斜体设置">4.加粗、斜体设置</span></h2><p><strong>粗体文字</strong>,或__粗体文字__——&gt; 粗体文字<br><em>斜体文字</em>,或_斜体文字_——&gt; 斜体文字</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">**粗体文字**,或__粗体文字__——&gt; 粗体文字</span><br><span class="line">*斜体文字*,或_斜体文字_——&gt; 斜体文字</span><br></pre></td></tr></tbody></table></figure><h2><span id="5背景色设置">5.背景色设置</span></h2><table><tbody><tr><td bgcolor="#FF00FF">背景色的设置是按照十六进制颜色值：#7FFFD4</td></tr></tbody></table><table><tbody><tr><td bgcolor="#FF83FA">背景色的设置是按照十六进制颜色值：#FF83FA</td></tr></tbody></table><table><tbody><tr><td bgcolor="#D1EEEE">背景色的设置是按照十六进制颜色值：#D1EEEE</td></tr></tbody></table><table><tbody><tr><td bgcolor="#C0FF3E">背景色的设置是按照十六进制颜色值：#C0FF3E</td></tr></tbody></table><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;table&gt;&lt;tr&gt;&lt;td bgcolor=#FF00FF&gt;背景色的设置是按照十六进制颜色值：#7FFFD4&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;</span><br><span class="line">&lt;table&gt;&lt;tr&gt;&lt;td bgcolor=#FF83FA&gt;背景色的设置是按照十六进制颜色值：#FF83FA&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;</span><br><span class="line">&lt;table&gt;&lt;tr&gt;&lt;td bgcolor=#D1EEEE&gt;背景色的设置是按照十六进制颜色值：#D1EEEE&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;</span><br><span class="line">&lt;table&gt;&lt;tr&gt;&lt;td bgcolor=#C0FF3E&gt;背景色的设置是按照十六进制颜色值：#C0FF3E&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;</span><br></pre></td></tr></tbody></table></figure><h2><span id="6缩进">6.缩进</span></h2><blockquote><p>缩进一</p><blockquote><p>缩进二</p><blockquote><p>缩进三</p></blockquote></blockquote></blockquote><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;缩进一</span><br><span class="line">&gt;&gt;缩进二</span><br><span class="line">&gt;&gt;&gt;缩进三</span><br></pre></td></tr></tbody></table></figure><h2><span id="7插入链接">7.插入链接</span></h2><p><a href="http://baidu.com/">百度</a></p><figure class="highlight golang"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[百度](http:<span class="comment">//baidu.com)</span></span><br></pre></td></tr></tbody></table></figure><h2><span id="8插入网络图片">8.插入网络图片</span></h2><p><img src="http://www.baidu.com/img/bdlogo.gif" alt="baidu" title="百度logo"></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![baidu](http://www.baidu.com/img/bdlogo.gif "百度logo")</span><br></pre></td></tr></tbody></table></figure><h2><span id="9给图片加上超链接">9.给图片加上超链接</span></h2><p><a href="http://baidu.com/"><img src="http://www.baidu.com/img/bdlogo.gif" alt="baidu" title="百度Logo"></a> </p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[![baidu](http://www.baidu.com/img/bdlogo.gif  "百度Logo")](http://baidu.com) </span><br></pre></td></tr></tbody></table></figure><h2><span id="10部分文字高亮">10.部分文字高亮</span></h2><p><code>部分文字高亮</code><br><code>部分文字高亮</code></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">`部分文字高亮`</span><br><span class="line">``部分文字高亮``</span><br></pre></td></tr></tbody></table></figure><h2><span id="11内容引用">11.内容引用</span></h2><blockquote><p>引用内容，我是引用内容呀</p></blockquote><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; 引用内容，我是引用内容呀</span><br></pre></td></tr></tbody></table></figure><h2><span id="12表格">12.表格</span></h2><table><thead><tr><th>头1</th><th align="center">头2</th><th align="right">头3</th></tr></thead><tbody><tr><td>张三</td><td align="center">李四</td><td align="right">老王</td></tr></tbody></table><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">头1|头2|头3|</span><br><span class="line">--|:--:|--:</span><br><span class="line">张三|李四|老王|</span><br></pre></td></tr></tbody></table></figure><h2><span id="13-斜体加粗">13. 斜体加粗</span></h2><p><em><strong>斜体加粗</strong></em></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">***斜体加粗***</span><br></pre></td></tr></tbody></table></figure><h2><span id="14-删除线">14. 删除线</span></h2><p><del>删除线</del> </p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~~删除线~~ </span><br></pre></td></tr></tbody></table></figure><h2><span id="15缩进">15.缩进</span></h2><p style="text-indent:2em">这是第一句话</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p style="text-indent:2em"&gt;这是第一句话&lt;/p&gt;</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>golang LockOSThread子协程绑定问题</title>
      <link href="2021/01/02/70ccb00429dd7d11f90bc70a17cdc398/"/>
      <url>2021/01/02/70ccb00429dd7d11f90bc70a17cdc398/</url>
      
        <content type="html"><![CDATA[<p>转载：<a href="https://studygolang.com/articles/20867">https://studygolang.com/articles/20867</a></p><h2><span id="前言">前言:</span></h2><pre><code>   golang的runtime提供了一个LockOSThread的函数，该方法的作用是可以让当前协程绑定并独立一个线程 M。 那么绑定线程的那个协程new出来的子协程在哪里跑？  先说答案，子协程不会继承lockOSThread特性。 是否是这样，我们可以试一下 …</code></pre><p><img src="/2021/01/02/70ccb00429dd7d11f90bc70a17cdc398/1609601751367.png"><br><strong>测试代码</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"> </span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "net/http"</span><br><span class="line">    "runtime"</span><br><span class="line">    "syscall"</span><br><span class="line">    "time"</span><br><span class="line"> </span><br><span class="line">    "github.com/gin-gonic/gin"</span><br><span class="line">)</span><br><span class="line"> </span><br><span class="line">func main() {</span><br><span class="line">    runtime.LockOSThread()</span><br><span class="line">    router := gin.Default()</span><br><span class="line">    router.GET("/ping", func(c *gin.Context) {</span><br><span class="line">        fmt.Println("worker:", syscall.Gettid())</span><br><span class="line">        c.JSON(200, gin.H{</span><br><span class="line">            "message": "pong",</span><br><span class="line">        })</span><br><span class="line">    })</span><br><span class="line"> </span><br><span class="line">    s := &amp;http.Server{</span><br><span class="line">        Addr:           ":18282",</span><br><span class="line">        Handler:        router,</span><br><span class="line">        ReadTimeout:    600 * time.Second,</span><br><span class="line">        WriteTimeout:   600 * time.Second,</span><br><span class="line">        MaxHeaderBytes: 1 &lt;&lt; 20,</span><br><span class="line">    }</span><br><span class="line">    fmt.Println("listen:", syscall.Gettid())</span><br><span class="line">    s.ListenAndServe()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>注释， 通过 syscall.Gettid()是可以获取当前G绑定的线程id  (lwp).<br>测试代码的日志结果很明显，虽然我们在main主协程里配了runtime.LockOSThread()线程绑定，但因为net/http底层会针对每个accept后的连接new一个子协程，这些子协程不会继承父协程的LockOSThread线程绑定。<br><img src="/2021/01/02/70ccb00429dd7d11f90bc70a17cdc398/1609601813135.jpg"></p><p>除了syscall方法外，我们还可以 include &lt;pthread.h&gt; 方法来打印线程标识，C.phread_self() 来输出线程标识。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"> </span><br><span class="line">// #include &lt;pthread.h&gt;</span><br><span class="line">import "C"</span><br><span class="line">import (</span><br><span class="line">    "fmt"</span><br><span class="line">    "runtime"</span><br><span class="line">)</span><br><span class="line">// xiaorui.cc</span><br><span class="line">func main() {</span><br><span class="line">    runtime.GOMAXPROCS(runtime.NumCPU())</span><br><span class="line">    ch1 := make(chan bool)</span><br><span class="line">    ch2 := make(chan bool)</span><br><span class="line">    fmt.Println("main", C.pthread_self())</span><br><span class="line">    go func() {</span><br><span class="line">        runtime.LockOSThread()</span><br><span class="line">        fmt.Println("locked", C.pthread_self())</span><br><span class="line">        go func() {</span><br><span class="line">            fmt.Println("locked child", C.pthread_self())</span><br><span class="line">            ch1 &lt;- true</span><br><span class="line">        }()</span><br><span class="line">        ch2 &lt;- true</span><br><span class="line">    }()</span><br><span class="line">    &lt;-ch1</span><br><span class="line">    &lt;-ch2</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>为什么golang的子协程不能继承main goroutine的线程绑定?</p></blockquote><p> 因为官方doc有runtime.LockOSThread线程方面的描述，包括子协程. <a href="https://tip.golang.org/doc/go1.10#runtime">https://tip.golang.org/doc/go1.10#runtime</a><br> golang nuts和issuse里有不少帖子是关于子协程线程绑定的，看样子作者是没有兴趣做这方面的扩展，主要会影响当前的go的调度策略。 有兴趣的朋友可以追看下issuse页 <a href="https://github.com/golang/go/issues/23758">https://github.com/golang/go/issues/23758</a></p><blockquote><p>什么场景下用到runtime.LockOSThread?</p></blockquote><p>我们知道golang的scheduler可以理解为公平协作调度和抢占的综合体，他不支持优先级调度。当你开了几十万个goroutine，并且大多数协程已经在runq等待调度了, 那么如果你有一个重要的周期性的协程需要优先执行该怎么办？</p><p>可以借助runtime.LockOSThread()方法来绑定线程，绑定线程M后的好处在于，他可以由system kernel内核来调度，因为他本质是线程了。  </p><p>先前我们有在定时器场景中使用runtime.LockOSThread，达到少许的优先级效果。效果不明显的原因是，我们自定义的定时器需要time.sleep来解决cpu忙讯轮，但time.sleep又依赖于go自身的heap定时器…. 解决方法是，独立一个M线程后，使用syscall来实现时间等待. </p><h2><span id="总结">总结:</span></h2><p>runtime.LockOSThread会锁定当前协程只跑在一个系统线程上，这个线程里也只跑该协程。他们是相互牵制的 !!!</p>]]></content>
      
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>golang开发常用库</title>
      <link href="2021/01/02/7baa33739b514cc32dc0efc56c3fbb4a/"/>
      <url>2021/01/02/7baa33739b514cc32dc0efc56c3fbb4a/</url>
      
        <content type="html"><![CDATA[<p><strong>1.</strong> 变量拷贝：<a href="https://github.com/jinzhu/copier">copy</a><br><strong>2.</strong> 时间处理：1.<a href="https://github.com/jinzhu/now">now</a>   2.<a href="https://github.com/golang-module/carbon">carbon</a><br><strong>3.</strong> 更新结构体tag工具 <a href="https://github.com/fatih/gomodifytags">gomodifytags</a><br><strong>4.</strong> 打印数据的结构  <a href="github.com/davecgh/go-spew/spew">go-spew</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>golang编程技巧</title>
      <link href="2021/01/01/8383c83726d2269063c6ed989409032b/"/>
      <url>2021/01/01/8383c83726d2269063c6ed989409032b/</url>
      
        <content type="html"><![CDATA[<p><strong>1.</strong>  option模式</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>golang trace</title>
      <link href="2020/12/30/6d802f62f4c4d693e9a9c05179178991/"/>
      <url>2020/12/30/6d802f62f4c4d693e9a9c05179178991/</url>
      
        <content type="html"><![CDATA[<p>对于绝大部分服务，跟踪刨析是用不到的。但是如果遇到了下面问题，可以不妨一试：</p><p>怀疑哪个协程慢了<br>系统调用有问题<br>协程调度问题 (chan 交互、互斥锁、信号量等)<br>怀疑是 gc (Garbage-Collect) 影响了服务性能<br>网络阻塞<br>等等<br>坦白的讲，通过跟踪刨析可以看到每个协程在某一时刻在干什么。</p><p>做跟踪刨析，首先需要获取trace 数据。可以通过代码中插入trace， 或者上节提到的通过pprof 下载即可。</p><p><a href="https://blog.csdn.net/lengyue1084/article/details/108252799?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_title-6&amp;spm=1001.2101.3001.4242">go trace 剖析 go1.14 异步抢占式调度</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>golang服务内存信息</title>
      <link href="2020/12/30/8ee6e562cee56457039b54c622d6858f/"/>
      <url>2020/12/30/8ee6e562cee56457039b54c622d6858f/</url>
      
        <content type="html"><![CDATA[<p>runtime中和内存使用情况相关的结构体为runtime.MemStats，这个结构定义了golang运行过程中所有内存相关的信息，在源代码中定义如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br></pre></td><td class="code"><pre><span class="line">// A MemStats records statistics about the memory allocator. 记录内存分配器的信息</span><br><span class="line">type MemStats struct {</span><br><span class="line">    // General statistics.</span><br><span class="line"></span><br><span class="line">    // Alloc is bytes of allocated heap objects.</span><br><span class="line">    // 堆空间分配的字节数</span><br><span class="line">    // This is the same as HeapAlloc (see below).</span><br><span class="line">    Alloc uint64</span><br><span class="line"></span><br><span class="line">    // TotalAlloc is cumulative bytes allocated for heap objects.</span><br><span class="line">    //</span><br><span class="line">    // TotalAlloc increases as heap objects are allocated, but</span><br><span class="line">    // unlike Alloc and HeapAlloc, it does not decrease when</span><br><span class="line">    // objects are freed. 从服务开始运行至今分配器为分配的堆空间总和</span><br><span class="line">    TotalAlloc uint64</span><br><span class="line"></span><br><span class="line">    // Sys is the total bytes of memory obtained from the OS.</span><br><span class="line">    //</span><br><span class="line">    // Sys is the sum of the XSys fields below. Sys measures the</span><br><span class="line">    // virtual address space reserved by the Go runtime for the</span><br><span class="line">    // heap, stacks, and other internal data structures. It's</span><br><span class="line">    // likely that not all of the virtual address space is backed</span><br><span class="line">    // by physical memory at any given moment, though in general</span><br><span class="line">    // it all was at some point. 服务现在使用的内存</span><br><span class="line">    Sys uint64</span><br><span class="line"></span><br><span class="line">    // Lookups is the number of pointer lookups performed by the</span><br><span class="line">    // runtime.</span><br><span class="line">    //</span><br><span class="line">    // This is primarily useful for debugging runtime internals. 被runtime监视的指针数</span><br><span class="line">    Lookups uint64</span><br><span class="line"></span><br><span class="line">    // Mallocs is the cumulative count of heap objects allocated. 服务malloc的次数</span><br><span class="line">    // The number of live objects is Mallocs - Frees.</span><br><span class="line">    Mallocs uint64</span><br><span class="line"></span><br><span class="line">    // Frees is the cumulative count of heap objects freed. 服务回收的heap objects</span><br><span class="line">    Frees uint64</span><br><span class="line"></span><br><span class="line">    // Heap memory statistics.</span><br><span class="line">    //</span><br><span class="line">    // Interpreting the heap statistics requires some knowledge of</span><br><span class="line">    // how Go organizes memory. Go divides the virtual address</span><br><span class="line">    // space of the heap into "spans", which are contiguous</span><br><span class="line">    // regions of memory 8K or larger. A span may be in one of</span><br><span class="line">    // three states:</span><br><span class="line">    //</span><br><span class="line">    // An "idle" span contains no objects or other data. The</span><br><span class="line">    // physical memory backing an idle span can be released back</span><br><span class="line">    // to the OS (but the virtual address space never is), or it</span><br><span class="line">    // can be converted into an "in use" or "stack" span.</span><br><span class="line">    //</span><br><span class="line">    // An "in use" span contains at least one heap object and may</span><br><span class="line">    // have free space available to allocate more heap objects.</span><br><span class="line">    //</span><br><span class="line">    // A "stack" span is used for goroutine stacks. Stack spans</span><br><span class="line">    // are not considered part of the heap. A span can change</span><br><span class="line">    // between heap and stack memory; it is never used for both</span><br><span class="line">    // simultaneously.</span><br><span class="line"></span><br><span class="line">    // HeapAlloc is bytes of allocated heap objects.</span><br><span class="line">    //</span><br><span class="line">    // "Allocated" heap objects include all reachable objects, as</span><br><span class="line">    // well as unreachable objects that the garbage collector has</span><br><span class="line">    // not yet freed. Specifically, HeapAlloc increases as heap</span><br><span class="line">    // objects are allocated and decreases as the heap is swept</span><br><span class="line">    // and unreachable objects are freed. Sweeping occurs</span><br><span class="line">    // incrementally between GC cycles, so these two processes</span><br><span class="line">    // occur simultaneously, and as a result HeapAlloc tends to</span><br><span class="line">    // change smoothly (in contrast with the sawtooth that is</span><br><span class="line">    // typical of stop-the-world garbage collectors).</span><br><span class="line">    //服务分配的堆内存</span><br><span class="line">    HeapAlloc uint64</span><br><span class="line"></span><br><span class="line">    // HeapSys is bytes of heap memory obtained from the OS.</span><br><span class="line">    //</span><br><span class="line">    // HeapSys measures the amount of virtual address space</span><br><span class="line">    // reserved for the heap. This includes virtual address space</span><br><span class="line">    // that has been reserved but not yet used, which consumes no</span><br><span class="line">    // physical memory, but tends to be small, as well as virtual</span><br><span class="line">    // address space for which the physical memory has been</span><br><span class="line">    // returned to the OS after it became unused (see HeapReleased</span><br><span class="line">    // for a measure of the latter).</span><br><span class="line">    //</span><br><span class="line">    // HeapSys estimates the largest size the heap has had.</span><br><span class="line">    //系统分配的堆内存</span><br><span class="line">    HeapSys uint64</span><br><span class="line"></span><br><span class="line">    // HeapIdle is bytes in idle (unused) spans.</span><br><span class="line">    //</span><br><span class="line">    // Idle spans have no objects in them. These spans could be</span><br><span class="line">    // (and may already have been) returned to the OS, or they can</span><br><span class="line">    // be reused for heap allocations, or they can be reused as</span><br><span class="line">    // stack memory.</span><br><span class="line">    //</span><br><span class="line">    // HeapIdle minus HeapReleased estimates the amount of memory</span><br><span class="line">    // that could be returned to the OS, but is being retained by</span><br><span class="line">    // the runtime so it can grow the heap without requesting more</span><br><span class="line">    // memory from the OS. If this difference is significantly</span><br><span class="line">    // larger than the heap size, it indicates there was a recent</span><br><span class="line">    // transient spike in live heap size.</span><br><span class="line">    //申请但是为分配的堆内存，（或者回收了的堆内存）</span><br><span class="line">    HeapIdle uint64</span><br><span class="line"></span><br><span class="line">    // HeapInuse is bytes in in-use spans.</span><br><span class="line">    //</span><br><span class="line">    // In-use spans have at least one object in them. These spans</span><br><span class="line">    // can only be used for other objects of roughly the same</span><br><span class="line">    // size.</span><br><span class="line">    //</span><br><span class="line">    // HeapInuse minus HeapAlloc esimates the amount of memory</span><br><span class="line">    // that has been dedicated to particular size classes, but is</span><br><span class="line">    // not currently being used. This is an upper bound on</span><br><span class="line">    // fragmentation, but in general this memory can be reused</span><br><span class="line">    // efficiently.</span><br><span class="line">    //正在使用的堆内存</span><br><span class="line">    HeapInuse uint64</span><br><span class="line"></span><br><span class="line">    // HeapReleased is bytes of physical memory returned to the OS.</span><br><span class="line">    //</span><br><span class="line">    // This counts heap memory from idle spans that was returned</span><br><span class="line">    // to the OS and has not yet been reacquired for the heap.</span><br><span class="line">    //返回给OS的堆内存，类似C/C++中的free。</span><br><span class="line">    HeapReleased uint64</span><br><span class="line"></span><br><span class="line">    // HeapObjects is the number of allocated heap objects.</span><br><span class="line">    //</span><br><span class="line">    // Like HeapAlloc, this increases as objects are allocated and</span><br><span class="line">    // decreases as the heap is swept and unreachable objects are</span><br><span class="line">    // freed.</span><br><span class="line">    //堆内存块申请的量</span><br><span class="line">    HeapObjects uint64</span><br><span class="line"></span><br><span class="line">    // Stack memory statistics.</span><br><span class="line">    //</span><br><span class="line">    // Stacks are not considered part of the heap, but the runtime</span><br><span class="line">    // can reuse a span of heap memory for stack memory, and</span><br><span class="line">    // vice-versa.</span><br><span class="line"></span><br><span class="line">    // StackInuse is bytes in stack spans.</span><br><span class="line">    //</span><br><span class="line">    // In-use stack spans have at least one stack in them. These</span><br><span class="line">    // spans can only be used for other stacks of the same size.</span><br><span class="line">    //</span><br><span class="line">    // There is no StackIdle because unused stack spans are</span><br><span class="line">    // returned to the heap (and hence counted toward HeapIdle).</span><br><span class="line">    //正在使用的栈</span><br><span class="line">    StackInuse uint64</span><br><span class="line"></span><br><span class="line">    // StackSys is bytes of stack memory obtained from the OS.</span><br><span class="line">    //</span><br><span class="line">    // StackSys is StackInuse, plus any memory obtained directly</span><br><span class="line">    // from the OS for OS thread stacks (which should be minimal).</span><br><span class="line">    //系统分配的作为运行栈的内存</span><br><span class="line">    StackSys uint64</span><br><span class="line"></span><br><span class="line">    // Off-heap memory statistics.</span><br><span class="line">    //</span><br><span class="line">    // The following statistics measure runtime-internal</span><br><span class="line">    // structures that are not allocated from heap memory (usually</span><br><span class="line">    // because they are part of implementing the heap). Unlike</span><br><span class="line">    // heap or stack memory, any memory allocated to these</span><br><span class="line">    // structures is dedicated to these structures.</span><br><span class="line">    //</span><br><span class="line">    // These are primarily useful for debugging runtime memory</span><br><span class="line">    // overheads.</span><br><span class="line"></span><br><span class="line">    // MSpanInuse is bytes of allocated mspan structures. 用于测试用的结构体使用的字节数</span><br><span class="line">    MSpanInuse uint64</span><br><span class="line"></span><br><span class="line">    // MSpanSys is bytes of memory obtained from the OS for mspan</span><br><span class="line">    // structures. 系统为测试用的结构体分配的字节数</span><br><span class="line">    MSpanSys uint64</span><br><span class="line"></span><br><span class="line">    // MCacheInuse is bytes of allocated mcache structures. mcache结构体申请的字节数</span><br><span class="line">    MCacheInuse uint64</span><br><span class="line"></span><br><span class="line">    // MCacheSys is bytes of memory obtained from the OS for</span><br><span class="line">    // mcache structures. 操作系统申请的堆空间用于mcache的量</span><br><span class="line">    MCacheSys uint64</span><br><span class="line"></span><br><span class="line">    // BuckHashSys is bytes of memory in profiling bucket hash tables.用于剖析桶散列表的堆空间</span><br><span class="line">    BuckHashSys uint64</span><br><span class="line"></span><br><span class="line">    // GCSys is bytes of memory in garbage collection metadata. 垃圾回收标记元信息使用的内存</span><br><span class="line">    GCSys uint64</span><br><span class="line"></span><br><span class="line">    // OtherSys is bytes of memory in miscellaneous off-heap</span><br><span class="line">    // runtime allocations.  golang系统架构占用的额外空间</span><br><span class="line">    OtherSys uint64</span><br><span class="line"></span><br><span class="line">    // Garbage collector statistics.</span><br><span class="line"></span><br><span class="line">    // NextGC is the target heap size of the next GC cycle.</span><br><span class="line">    //</span><br><span class="line">    // The garbage collector's goal is to keep HeapAlloc ≤ NextGC.</span><br><span class="line">    // At the end of each GC cycle, the target for the next cycle</span><br><span class="line">    // is computed based on the amount of reachable data and the</span><br><span class="line">    // value of GOGC. 垃圾回收器检视的内存大小</span><br><span class="line">    NextGC uint64</span><br><span class="line"></span><br><span class="line">    // LastGC is the time the last garbage collection finished, as</span><br><span class="line">    // nanoseconds since 1970 (the UNIX epoch).</span><br><span class="line">    // 垃圾回收器最后一次执行时间。</span><br><span class="line">    LastGC uint64</span><br><span class="line"></span><br><span class="line">    // PauseTotalNs is the cumulative nanoseconds in GC</span><br><span class="line">    // stop-the-world pauses since the program started.</span><br><span class="line">    //</span><br><span class="line">    // During a stop-the-world pause, all goroutines are paused</span><br><span class="line">    // and only the garbage collector can run. </span><br><span class="line">    // 垃圾回收或者其他信息收集导致服务暂停的次数。</span><br><span class="line">    PauseTotalNs uint64</span><br><span class="line"></span><br><span class="line">    // PauseNs is a circular buffer of recent GC stop-the-world</span><br><span class="line">    // pause times in nanoseconds.</span><br><span class="line">    //</span><br><span class="line">    // The most recent pause is at PauseNs[(NumGC+255)%256]. In</span><br><span class="line">    // general, PauseNs[N%256] records the time paused in the most</span><br><span class="line">    // recent N%256th GC cycle. There may be multiple pauses per</span><br><span class="line">    // GC cycle; this is the sum of all pauses during a cycle. 一个循环队列，记录最近垃圾回收系统中断的时间</span><br><span class="line">    PauseNs [256]uint64</span><br><span class="line"></span><br><span class="line">    // PauseEnd is a circular buffer of recent GC pause end times,</span><br><span class="line">    // as nanoseconds since 1970 (the UNIX epoch).</span><br><span class="line">    //</span><br><span class="line">    // This buffer is filled the same way as PauseNs. There may be</span><br><span class="line">    // multiple pauses per GC cycle; this records the end of the</span><br><span class="line">    // last pause in a cycle. 一个循环队列，记录最近垃圾回收系统中断的时间开始点。</span><br><span class="line">    PauseEnd [256]uint64</span><br><span class="line"></span><br><span class="line">    // NumGC is the number of completed GC cycles.</span><br><span class="line">    //垃圾回收的内存大小</span><br><span class="line">    NumGC uint32</span><br><span class="line"></span><br><span class="line">    // NumForcedGC is the number of GC cycles that were forced by</span><br><span class="line">    // the application calling the GC function.</span><br><span class="line">    //服务调用runtime.GC()强制使用垃圾回收的次数。</span><br><span class="line">    NumForcedGC uint32</span><br><span class="line"></span><br><span class="line">    // GCCPUFraction is the fraction of this program's available</span><br><span class="line">    // CPU time used by the GC since the program started.</span><br><span class="line">    //</span><br><span class="line">    // GCCPUFraction is expressed as a number between 0 and 1,</span><br><span class="line">    // where 0 means GC has consumed none of this program's CPU. A</span><br><span class="line">    // program's available CPU time is defined as the integral of</span><br><span class="line">    // GOMAXPROCS since the program started. That is, if</span><br><span class="line">    // GOMAXPROCS is 2 and a program has been running for 10</span><br><span class="line">    // seconds, its "available CPU" is 20 seconds. GCCPUFraction</span><br><span class="line">    // does not include CPU time used for write barrier activity.</span><br><span class="line">    //</span><br><span class="line">    // This is the same as the fraction of CPU reported by</span><br><span class="line">    // GODEBUG=gctrace=1.</span><br><span class="line">    //垃圾回收占用服务CPU工作的时间总和。如果有100个goroutine，垃圾回收的时间为1S,那么久占用了100S</span><br><span class="line">    GCCPUFraction float64</span><br><span class="line"></span><br><span class="line">    // EnableGC indicates that GC is enabled. It is always true,</span><br><span class="line">    // even if GOGC=off.</span><br><span class="line">    //是否启用GC</span><br><span class="line">    EnableGC bool</span><br><span class="line"></span><br><span class="line">    // DebugGC is currently unused.</span><br><span class="line">    DebugGC bool</span><br><span class="line"></span><br><span class="line">    // BySize reports per-size class allocation statistics.</span><br><span class="line">    //</span><br><span class="line">    // BySize[N] gives statistics for allocations of size S where</span><br><span class="line">    // BySize[N-1].Size &lt; S ≤ BySize[N].Size.</span><br><span class="line">    //</span><br><span class="line">    // This does not report allocations larger than BySize[60].Size.</span><br><span class="line">    //内存分配器使用情况</span><br><span class="line">    BySize [61]struct {</span><br><span class="line">        // Size is the maximum byte size of an object in this</span><br><span class="line">        // size class.</span><br><span class="line">        Size uint32</span><br><span class="line"></span><br><span class="line">        // Mallocs is the cumulative count of heap objects</span><br><span class="line">        // allocated in this size class. The cumulative bytes</span><br><span class="line">        // of allocation is Size*Mallocs. The number of live</span><br><span class="line">        // objects in this size class is Mallocs - Frees.</span><br><span class="line">        Mallocs uint64</span><br><span class="line"></span><br><span class="line">        // Frees is the cumulative count of heap objects freed</span><br><span class="line">        // in this size class.</span><br><span class="line">        Frees uint64</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>runtime.MemStats这个结构体包含的字段比较多，但是大多都很有用，去掉那些注释来看各个属性，会发现各个属性都是很有价值的：<br>1、Alloc uint64 //golang语言框架堆空间分配的字节数<br>2、TotalAlloc uint64 //从服务开始运行至今分配器为分配的堆空间总 和，只有增加，释放的时候不减少<br>3、Sys uint64 //服务现在系统使用的内存<br>4、Lookups uint64 //被runtime监视的指针数<br>5、Mallocs uint64 //服务malloc的次数<br>6、Frees uint64 //服务回收的heap objects的字节数<br>7、HeapAlloc uint64 //服务分配的堆内存字节数<br>8、HeapSys uint64 //系统分配的作为运行栈的内存<br>9、HeapIdle uint64 //申请但是未分配的堆内存或者回收了的堆内存（空闲）字节数<br>10、HeapInuse uint64 //正在使用的堆内存字节数<br>10、HeapReleased uint64 //返回给OS的堆内存，类似C/C++中的free。<br>11、HeapObjects uint64 //堆内存块申请的量<br>12、StackInuse uint64 //正在使用的栈字节数<br>13、StackSys uint64 //系统分配的作为运行栈的内存<br>14、MSpanInuse uint64 //用于测试用的结构体使用的字节数<br>15、MSpanSys uint64 //系统为测试用的结构体分配的字节数<br>16、MCacheInuse uint64 //mcache结构体申请的字节数(不会被视为垃圾回收)<br>17、MCacheSys uint64 //操作系统申请的堆空间用于mcache的字节数<br>18、BuckHashSys uint64 //用于剖析桶散列表的堆空间<br>19、GCSys uint64 //垃圾回收标记元信息使用的内存<br>20、OtherSys uint64 //golang系统架构占用的额外空间<br>21、NextGC uint64 //垃圾回收器检视的内存大小<br>22、LastGC uint64 // 垃圾回收器最后一次执行时间。<br>23、PauseTotalNs uint64 // 垃圾回收或者其他信息收集导致服务暂停的次数。<br>24、PauseNs [256]uint64 //一个循环队列，记录最近垃圾回收系统中断的时间<br>25、PauseEnd [256]uint64 //一个循环队列，记录最近垃圾回收系统中断的时间开始点。<br>26、NumForcedGC uint32 //服务调用runtime.GC()强制使用垃圾回收的次数。<br>27、GCCPUFraction float64 //垃圾回收占用服务CPU工作的时间总和。如果有100个goroutine，垃圾回收的时间为1S,那么久占用了100S。<br>28、BySize //内存分配器使用情况 </p><p>从runtime.MemStats的属性可以看到，golang中的runtime包其实是一个带有一点维护性质的功能包。开发者可以获取大量golang服务运行时的信息，查看runtime.MenStats的方法也很简单。直接调用runtime.ReadMemStats方法即可获取调用点服务运行信息。一下是我测试过程中获取到的runtime.MenStats，内容如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">memstat: {</span><br><span class="line">Alloc:69257680 //golang语言框架堆空间分配的字节数 大概68M</span><br><span class="line">TotalAlloc:79489528 //从服务开始运行至今分配器为分配的堆空间总 和，只有增加，释放的时候不减少。大约79M</span><br><span class="line">Sys:1345724664 //服务现在系统使用的内存, 大约1345M</span><br><span class="line">Lookups:3 //被runtime监视的指针数</span><br><span class="line">Mallocs:307494 //服务malloc的次数</span><br><span class="line">Frees:9105  //服务回收的heap objects的字节数 free次数</span><br><span class="line">HeapAlloc:69257680 //golang语言框架堆空间分配的字节数 大概68M</span><br><span class="line">HeapSys:71434240  //系统分配的堆内存 大概71M</span><br><span class="line">HeapIdle:974848 //申请但是未分配的堆内存或者回收了的堆内存（空闲）字节数 大概1M</span><br><span class="line">HeapInuse:70459392 //正在使用的堆内存字节数 大概70M</span><br><span class="line">HeapReleased:0 //返回给OS的堆内存，</span><br><span class="line">HeapObjects:298389  //堆内存块申请的量</span><br><span class="line">StackInuse:1220804608 //正在使用的栈字节数 约1220M</span><br><span class="line">StackSys:1220804608 //系统分配的作为运行栈的内存 约1220M</span><br><span class="line">MSpanInuse:6924360  //用于测试用的结构体使用的字节数 不受GC控制， 约7M</span><br><span class="line">MSpanSys:6979584 //系统为测试用的结构体分配的字节数 约7M</span><br><span class="line">MCacheInuse:6816 //mcache结构体申请的字节数(不会被视为垃圾回收) 约6K</span><br><span class="line">MCacheSys:16384 //操作系统申请的堆空间用于mcache的字节数,约16K</span><br><span class="line">BuckHashSys:1468496 //用于剖析桶散列表的堆空间 约14K</span><br><span class="line">GCSys:40984576 //垃圾回收标记元信息使用的内存 约40M</span><br><span class="line">OtherSys:4036776 //golang系统架构占用的额外空间 约4M</span><br><span class="line">NextGC:135394784  //垃圾回收器检视的内存大小 约135M</span><br><span class="line">LastGC:1506577064496115700 //最后一次GC的时间戳</span><br><span class="line">PauseTotalNs:1834800 //系统暂停的时间，大约1.8毫秒</span><br><span class="line">PauseNs:[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 833700 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 131600 0 69500 299900 500100 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0] //最近垃圾回收消耗情况</span><br><span class="line">PauseEnd:[1506576868237062600 1506576873250702600 1506576878266318900 1506576883290562700 1506576888313706000 1506576893339216000 1506576898380539200 1506576903430807600 1506576908483751100 1506576913540053700 1506576918589605600 1506576923651466900 1506576928716329900 1506576933785270400 1506576938872682700 1506576943987556700 1506576949080171300 1506576954205844600 1506576959319027700 1506576964454667000 1506576969604832300 1506576974795338100 1506576979945880300 1506576985117374500 1506576990330379400 1506576995548568900 1506577000766977100 1506577005980367800 1506577011190038400 1506577016427160200 1506577021671897800 1506577026958806600 1506577032285905300 1506577037561334600 1506577042926588300 1506577048190473200 1506577053579177600 1506577059147393600 1506577064496115700 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0] //垃圾回收调用的时间点</span><br><span class="line">NumGC:39 //垃圾回收调用次数</span><br><span class="line">NumForcedGC:39 </span><br><span class="line">GCCPUFraction:-1.325626798158314e-06 //调用GC消耗的性能</span><br><span class="line">EnableGC:true </span><br><span class="line">DebugGC:false </span><br><span class="line">BySize:[</span><br><span class="line">{Size:0 Mallocs:0 Frees:0} </span><br><span class="line">{Size:8 Mallocs:45 Frees:41} </span><br><span class="line">{Size:16 Mallocs:4316 Frees:4273} </span><br><span class="line">{Size:32 Mallocs:118 Frees:58} </span><br><span class="line">{Size:48 Mallocs:192 Frees:1} </span><br><span class="line">{Size:64 Mallocs:149078 Frees:52} </span><br><span class="line">{Size:80 Mallocs:6 Frees:1} </span><br><span class="line">{Size:96 Mallocs:4 Frees:0} </span><br><span class="line">{Size:112 Mallocs:1 Frees:1} </span><br><span class="line">{Size:128 Mallocs:41 Frees:41} </span><br><span class="line">{Size:144 Mallocs:0 Frees:0} </span><br><span class="line">{Size:160 Mallocs:1 Frees:1} </span><br><span class="line">{Size:176 Mallocs:0 Frees:0} </span><br><span class="line">{Size:192 Mallocs:50 Frees:50} </span><br><span class="line">{Size:208 Mallocs:2 Frees:0} </span><br><span class="line">{Size:224 Mallocs:0 Frees:0} </span><br><span class="line">{Size:240 Mallocs:0 Frees:0} </span><br><span class="line">{Size:256 Mallocs:48 Frees:41} </span><br><span class="line">{Size:288 Mallocs:0 Frees:0} </span><br><span class="line">{Size:320 Mallocs:1 Frees:0} </span><br><span class="line">{Size:352 Mallocs:0 Frees:0} </span><br><span class="line">{Size:384 Mallocs:149024 Frees:0} </span><br><span class="line">{Size:416 Mallocs:1 Frees:0} </span><br><span class="line">{Size:448 Mallocs:0 Frees:0} </span><br><span class="line">{Size:480 Mallocs:3 Frees:0} </span><br><span class="line">{Size:512 Mallocs:80 Frees:80} </span><br><span class="line">{Size:576 Mallocs:0 Frees:0} </span><br><span class="line">{Size:640 Mallocs:0 Frees:0} </span><br><span class="line">{Size:704 Mallocs:0 Frees:0} </span><br><span class="line">{Size:768 Mallocs:0 Frees:0} </span><br><span class="line">{Size:896 Mallocs:7 Frees:0} </span><br><span class="line">{Size:1024 Mallocs:41 Frees:41} </span><br><span class="line">{Size:1152 Mallocs:1 Frees:0} </span><br><span class="line">{Size:1280 Mallocs:8 Frees:8} </span><br><span class="line">{Size:1408 Mallocs:0 Frees:0} </span><br><span class="line">{Size:1536 Mallocs:0 Frees:0} </span><br><span class="line">{Size:1792 Mallocs:10 Frees:8} </span><br><span class="line">{Size:2048 Mallocs:33 Frees:33} </span><br><span class="line">{Size:2304 Mallocs:8 Frees:8} </span><br><span class="line">{Size:2688 Mallocs:31 Frees:31} </span><br><span class="line">{Size:3072 Mallocs:8 Frees:8} </span><br><span class="line">{Size:3200 Mallocs:0 Frees:0} </span><br><span class="line">{Size:3456 Mallocs:31 Frees:31} </span><br><span class="line">{Size:4096 Mallocs:10 Frees:10} </span><br><span class="line">{Size:4864 Mallocs:35 Frees:31} </span><br><span class="line">{Size:5376 Mallocs:0 Frees:0} </span><br><span class="line">{Size:6144 Mallocs:39 Frees:39} </span><br><span class="line">{Size:6528 Mallocs:0 Frees:0} </span><br><span class="line">{Size:6784 Mallocs:0 Frees:0} </span><br><span class="line">{Size:6912 Mallocs:0 Frees:0} </span><br><span class="line">{Size:8192 Mallocs:3 Frees:2} </span><br><span class="line">{Size:9472 Mallocs:0 Frees:0} </span><br><span class="line">{Size:9728 Mallocs:0 Frees:0} </span><br><span class="line">{Size:10240 Mallocs:2 Frees:2} </span><br><span class="line">{Size:10880 Mallocs:0 Frees:0} </span><br><span class="line">{Size:12288 Mallocs:0 Frees:0} </span><br><span class="line">{Size:13568 Mallocs:2 Frees:2} </span><br><span class="line">{Size:14336 Mallocs:1 Frees:0} </span><br><span class="line">{Size:16384 Mallocs:0 Frees:0} </span><br><span class="line">{Size:18432 Mallocs:2 Frees:2} </span><br><span class="line">{Size:19072 Mallocs:0 Frees:0}</span><br><span class="line">] //具体内存分配情况 </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>for循环内defer</title>
      <link href="2020/12/28/8cb3dc7e45f963bebee0323515a4dd31/"/>
      <url>2020/12/28/8cb3dc7e45f963bebee0323515a4dd31/</url>
      
        <content type="html"><![CDATA[<p>在项目中经常用到redis连接，数据库连接，mongodb连接还有grpc连接等。一般这些都是长连接的，都会有一个建立连接的过程，建立完连接后会得到一个连接，任务结束时可能会关闭连接。所以就有可能出现下面的情况：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">for {</span><br><span class="line">conn, err := grpc.DialContext(context.Background(), ":8080", grpc.WithInsecure(),</span><br><span class="line"></span><br><span class="line">if err != nil {</span><br><span class="line">log.Fatalf("failed to dial: %v", err)</span><br><span class="line">}</span><br><span class="line">defer conn.Close()</span><br><span class="line"></span><br><span class="line">c := pb.NewMailServiceClient(conn)</span><br><span class="line">c.SendMail(context.TODO(), &amp;pb.MailRequest{</span><br><span class="line">Mail: "qq@mail.com",</span><br><span class="line">Text: "test,test",</span><br><span class="line">})</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这种情况会导致for循环里面的defer永远都不会执行。最后内存泄漏。很容易复现。正确的做法是将defer放入一个函数内或者匿名函数内</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">for {</span><br><span class="line">conn, err := grpc.DialContext(context.Background(), ":8080", grpc.WithInsecure())</span><br><span class="line"></span><br><span class="line">if err != nil {</span><br><span class="line">log.Fatalf("failed to dial: %v", err)</span><br><span class="line">}</span><br><span class="line">func () {</span><br><span class="line">defer conn.Close()</span><br><span class="line"></span><br><span class="line">c := pb.NewMailServiceClient(conn)</span><br><span class="line">c.SendMail(context.TODO(), &amp;pb.MailRequest{</span><br><span class="line">Mail: "qq@mail.com",</span><br><span class="line">Text: "test,test",</span><br><span class="line">})</span><br><span class="line">}()</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>这样的话就没问题了。上面举的例子是很容易发现这个问题的。但是有些时候问题不会这么明细，所以我们在编写代码的时候尽量不在for循环内部直接用defer。</p>]]></content>
      
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> defer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线上问题排查</title>
      <link href="2020/12/22/537a218b943ee8b49b05b6a5ea61812c/"/>
      <url>2020/12/22/537a218b943ee8b49b05b6a5ea61812c/</url>
      
        <content type="html"><![CDATA[<p><strong>持续整理网上其他人出现的线上问题以及排查过程，方便日后自己遇到类似问题可以快速得到灵感。</strong></p><h2><span id="1-容器中某go服务gc停顿经常超过100ms排查-或者-容器中某go服务gc停顿经常超过100ms排查">1.     或者   </span></h2><h2><span id="2快速分析cpu高负载问题">2.</span></h2><h2><span id="3高频-golang-服务接口超时排查amp性能调优">3.</span></h2><h2><span id="4golang跟踪剖析trace的使用">4.</span></h2><h2><span id="5为什么-go-模块在下游服务抖动恢复后cpu-占用无法恢复">5.</span></h2><h2><span id="6一个-go-程序系统线程暴涨的问题">6.</span></h2><h2><span id="7disk-io引起golang线程数暴涨的问题">7.</span></h2><h2><span id="8无人值守的自动-dump">8.</span></h2><h2><span id="9分析go程序的off-cpu性能">9.</span></h2><h2><span id="10gopsutil">10.</span></h2><h2><span id="11golang-http-client连接池不复用的问题">11.</span></h2><h2><span id="12dead-lock">12.</span></h2><h2><span id="13golang-性能问题-内存篇">13.</span></h2>]]></content>
      
      
      
        <tags>
            
            <tag> 问题排查 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>有意思的仓库</title>
      <link href="2020/12/20/4f2bf6f4693f58359f510a6af2f61c7f/"/>
      <url>2020/12/20/4f2bf6f4693f58359f510a6af2f61c7f/</url>
      
        <content type="html"><![CDATA[<p><a href="https://github.com/dgryski/go-perfbook/blob/master/performance-zh.md">编写和优化Go代码</a><br><a href="github.com/glycerine/offheap">go堆外哈希表</a><br>github.com/Knetic/govaluate</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>仓库说明</title>
      <link href="2020/12/20/ace446a19ec125b883f81cf36952d392/"/>
      <url>2020/12/20/ace446a19ec125b883f81cf36952d392/</url>
      
        <content type="html"><![CDATA[<p><a href="github.com/yexm/golib">go-lib</a>: go 工具仓库</p>]]></content>
      
      
      
        <tags>
            
            <tag> 个人代码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go电子书</title>
      <link href="2020/12/19/7451f44f4142a41b41fe20fbf0d491b7/"/>
      <url>2020/12/19/7451f44f4142a41b41fe20fbf0d491b7/</url>
      
        <content type="html"><![CDATA[<p><a href="https://qcrao91.gitbook.io/go/">码农桃花源</a><br><a href="https://geektutu.com/post/high-performance-go.html">极客兔兔</a><br><a href="https://golang.design/under-the-hood/zh-cn/preface/">go语言原本</a><br><a href="https://github.com/cch123/golang-notes">golang-notes(曹大)</a><br><a href="https://github.com/hapi666/GOBook">GoBook</a><br><a href="https://eddycjy.gitbook.io/golang/">和煎鱼学go</a><br><a href="https://draveness.me/golang/">面向信仰编程大佬的书</a><br><a href="https://github.com/aceld/golang">golang修养之路</a><br><a href="https://book.itsfun.top/gopl-zh/">Go语言圣经中文版</a><br><a href="https://github.com/chai2010/advanced-go-programming-book">Go语言高级编程</a>   <a href="https://chai2010.cn/advanced-go-programming-book/">https://chai2010.cn/advanced-go-programming-book/</a><br><a href="https://github.com/chai2010/go-ast-book">Go语法树入门</a><br><a href="https://github.com/chai2010/go2-book">Go2编程指南</a></p><h2><span id="文档">文档</span></h2><ul><li><a href="https://github.com/golang/proposal">Proposing Changes to Go</a> - Go 语言设计文档</li><li><a href="https://draveness.me/golang/"><strong>Go 语言设计与实现</strong></a></li><li><a href="https://github.com/changkun/go-under-the-hood"><strong>Go 语言原本</strong></a></li><li><a href="https://github.com/go101/go101"><strong>Go 101</strong></a> <a href="https://github.com/golang101/golang101">（中文版）</a></li><li><a href="http://tour.studygolang.com/">Go 官方入门指南</a></li><li><a href="https://github.com/chai2010/advanced-go-programming-book">Go 语言高级编程</a></li><li><a href="https://github.com/RainbowMango/GoExpertProgramming">Go 专家编程</a></li><li><a href="http://docscn.studygolang.com/">Go 编程语言</a></li><li><a href="https://studygolang.com/pkgdoc">Golang 标准库文档(官方/中文)</a></li><li><a href="https://github.com/polaris1119/The-Golang-Standard-Library-by-Example">Go 语言标准库</a> <em><a href="https://books.studygolang.com/The-Golang-Standard-Library-by-Example/"><code>在线阅读</code></a></em></li><li><a href="https://github.com/Unknwon/the-way-to-go_ZH_CN">《The Way to Go》中文版</a></li><li><a href="https://github.com/gopl-zh/gopl-zh.github.com">Go 语言圣经（中文版）</a></li><li><a href="http://c.biancheng.net/golang/">Go语言入门教程</a></li><li><a href="https://github.com/astaxie/Go-in-Action">Go 实战开发</a></li><li><a href="https://github.com/astaxie/build-web-application-with-golang">Go Web 应用开发</a></li><li><a href="http://yougg.github.io/static/gonote/GolangStudy.html">Go 学习技能树</a></li><li><a href="https://go-zh.org/doc/effective_go.html">实效 Go 编程</a></li><li><a href="https://github.com/yougg/gonote">Go 语言语法详解笔记</a></li><li><a href="https://github.com/Unknwon/go-study-index">Go 语言学习资料与社区索引</a></li><li><a href="http://go-database-sql.org/">Go database/sql tutorial</a></li><li><a href="https://github.com/hyper0x/go_command_tutorial">GO 命令教程</a></li><li><a href="https://github.com/tiancaiamao/go-internals">深入解析 Go</a></li><li><a href="https://github.com/achun/Go-Blog-In-Action">Go 语言博客实践</a></li><li><a href="https://github.com/mikespook/Learning-Go-zh-cn">学习 Go 语言</a></li><li><a href="https://github.com/chai2010/go2-book">Go2编程指南</a></li><li><a href="https://github.com/VividCortex/go-database-sql-tutorial">Go database/sql tutorial</a> - Go 数据库(database/sql)开发使用教程</li><li><a href="https://github.com/gowebexamples/gowebexamples">Go Web Examples</a> - Go Web 开发示例</li><li><a href="https://colobu.com/goasm/">Go Assembly</a> - 通过示例介绍 Go 汇编功能</li><li><a href="https://github.com/hoanhan101/ultimate-go">Ultimate Go</a> - 终极 Go 学习指南，包含大量文档化的代码和程序分析</li><li><a href="https://cloud.tencent.com/developer/doc/1101">Go 教程</a> - 腾讯云开发者手册</li><li><a href="https://github.com/guyan0319/golang_development_notes/blob/master/zh/preface.md">Golang 开发笔记</a></li><li><a href="https://github.com/cch123/golang-notes">golang-notes</a> - Go 源码阅读笔记</li><li><a href="https://github.com/karlseguin/the-little-go-book">The Little Go Book</a> <a href="https://github.com/songleo/the-little-go-book_ZH_CN">（中文版）</a></li><li><a href="https://www.freecodecamp.org/news/learning-go-from-zero-to-hero-d2a3223b3d86/">Learning Go — from zero to hero</a></li><li><a href="https://github.com/teh-cmc/go-internals">go-internals</a> - 深入理解 Go</li><li><a href="https://github.com/quii/learn-go-with-tests">Learn Go with Tests</a></li><li><a href="http://www.topgoer.com/">Go基础教程</a></li><li><a href="https://github.com/geektutu/7days-golang">7天用Go从零实现系列</a></li><li><a href="https://github.com/geektutu/high-performance-go">Go 语言高性能编程</a></li><li><a href="https://github.com/rubyhan1314/Golang-100-Days">Golang - 100天从新手到大师</a> - 某培训机构的部分教程内容</li><li><a href="https://github.com/hoanhan101/algo">algo</a> - 107+ 编码面试问题，包括详细的解决方案，测试用例和程序分析</li><li><a href="https://github.com/overnote/over-golang">over-golang</a> - Go 学习笔记</li><li><a href="https://github.com/overnote/over-algorithm">over-algorithm</a> - Go 算法笔记</li><li><a href="https://github.com/inancgumus/learngo">learngo</a> - 1000+ Go 示例、练习和测试</li><li><a href="https://github.com/austingebauer/go-leetcode">go-leetcode</a> - LeetCode 实现</li><li><a href="https://github.com/hantmac/Mastering_Go_ZH_CN">玩转 GO</a> - 《Mastering GO》中文译本</li><li><a href="https://github.com/halfrost/LeetCode-Go">leetcode-cookbook</a> - LeetCode in Go</li><li><a href="https://github.com/aceld/golang">Golang修养之路</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> 电子书 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大神</title>
      <link href="2020/12/19/dba1b51b859cc86394a469a8224b5bf3/"/>
      <url>2020/12/19/dba1b51b859cc86394a469a8224b5bf3/</url>
      
        <content type="html"><![CDATA[<h2><span id="国内">国内</span></h2><p><a href="https://xargin.com/">Xargin(曹大)的博客</a><br><a href="https://www.qcrao.com/">码农桃花源的博客</a><br><a href="https://eddycjy.com/tags/">煎鱼的迷之博客</a><br><a href="https://colobu.com/archives/">鸟窝</a><br><a href="http://xiaorui.cc/">峰云就她了</a><br><a href="https://draveness.me/">面向信仰编程</a><br><a href="https://gfw.go101.org/article/101.html">go语言101</a><br><a href="https://github.com/yangwenmai">go夜读发起人杨文</a><br><a href="https://wujunze.com/">panda</a><br><a href="https://blog.changkun.de/">欧神</a><br><a href="https://lessisbetter.site/">大彬</a><br><a href="https://wzxaini9.cn/">powerless</a><br><a href="http://blog.studygolang.com/">go语言中文网站长</a><br><a href="https://blog.csdn.net/qiya2007">伢之国(博客质量不错)</a></p><h2><span id="国外">国外</span></h2><p><a href="https://dave.cheney.net/">Go大神Dave Cheney的博客</a><br><a href="https://github.com/ardanlabs/gotraining/blob/master/reading/README.md">大量优秀Go文章</a><br><a href="https://github.com/mattn?after=Y3Vyc29yOnYyOpK5MjAyMC0xMS0wNFQxMTowMjozMCswODowMM4HiTcQ&amp;tab=repositories">mattn</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>gc实现原理系列</title>
      <link href="2020/12/19/683459bc26b0af3fc8463311ec6063b7/"/>
      <url>2020/12/19/683459bc26b0af3fc8463311ec6063b7/</url>
      
        <content type="html"><![CDATA[<p>系列：<br><a href="https://cloud.tencent.com/developer/article/1756159">GC的实现原理(1)</a><br><a href="https://cloud.tencent.com/developer/article/1756161">GC的实现原理(2)</a><br><a href="https://cloud.tencent.com/developer/article/1756163">GC的实现原理(3)</a><br><a href="https://cloud.tencent.com/developer/article/1756166">GC的实现原理(4)</a><br><a href="https://cloud.tencent.com/developer/article/1756172">GC的实现原理(5)</a><br><a href="https://cloud.tencent.com/developer/article/1756177">GC的实现原理(6)</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>每周一库-groupCache</title>
      <link href="2020/12/19/526b3d3aa68f7514781c729e2a41046d/"/>
      <url>2020/12/19/526b3d3aa68f7514781c729e2a41046d/</url>
      
        <content type="html"><![CDATA[<p>groupcache  是  Brad Fitzpatrick  最新的作品，目标在于取代一部分memcached的功能。以官方的说明是：groupcache is a caching and cache-filling library, intended as a replacement for memcached in many cases. 另外一篇介绍文是「Playing With Groupcache」。跟memcached 差异最大的地方在于「没有更改与删除的功能」，一旦写进去后就不会变动。在放弃update/delete 的特性后，换来的是：</p><p>refer:<br><a href="https://cloud.tencent.com/developer/article/1071399">https://cloud.tencent.com/developer/article/1071399</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> 每周一库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《如何学习》读后总结(下)</title>
      <link href="2020/12/17/ab7d717facc37977b0f6d55bfc369ba6/"/>
      <url>2020/12/17/ab7d717facc37977b0f6d55bfc369ba6/</url>
      
        <content type="html"><![CDATA[<h2><span id="前言">前言</span></h2><p>　　上篇针对《如何学习》这本书的重要内容进行了汇总，建议还没看的同学可以先看下：《如何学习》读后总结及对学习的思考（上篇）。其实从豆瓣上对本书的评论可以看出虽然大家对本书比较推崇，但也有很多人说书上并没有结合实际场景来给出学习计划建议，就像给了一碗鸡汤却不给勺子。本篇就对本书的一些关键结论进行进一步提炼，并结合自己的思考来给出实际学习场景的学习计划，以供大家参考和讨论，如果大家觉得哪里不对，或有更好的方法，欢迎留下评论，共同探讨。</p><h2><span id="1-重要结论汇总">1. 重要结论汇总</span></h2><p>遗忘后努力回忆能记得更牢；<br>还原学习场景记忆效果更好；<br>切换更多环境学习记得更牢；<br>相同重复次数，分开多次来完成效果更好；<br>要想一直记住知识点，应该在学习后间隔一两天、一个星期、一个月、两个月、两个月…再复习，就能持续记住；<br>对于终身学习，复习间隔最好为两个月；<br>要记忆文章，最好三分一时间来学习，三分二时间来背诵；<br>学习后马上考试能有效加深记忆，并且最好增加考试的频率；<br>对知识向外表述和输出能加深记忆并识别出其实不理解的内容；<br>遇到难题实在想不出解决办法时，放松能够让大脑关注到更多东西，提供解决灵感；<br>学习过程适当打断并有意识地反思能够提供持续的进步；<br>若有一个困难的项目，最好尽早开始，遇到难题卡壳时适当放下一段时间；<br>把相关又不相同的题材混合到一起学习能大大提高学习效果；<br>交替学习时要注意把学过的但一段时间没复习过的内容混在一起学；<br>知觉学习训练时节奏必须要快，让大脑的全部感官系统快速运作和调整，达到看一眼就能知道答案的效果；<br>睡眠开始时的深度睡眠阶段能对新学习的知识进行整理，睡眠中后段能对运动相关能力进行加固；<br>午休1-1.5小时对知识整理的效果，跟晚上睡一觉的效果相当；<br>可以考虑早上五六点起来学习，利用午休的时间加固学习效果；</p><h3><span id="2-对于一些学习场景的思考">2. 对于一些学习场景的思考</span></h3><p><strong>2.1 如何学习技术组件</strong><br>　　比如要学习消息队列组件。首先收集主流的消息队列有哪些，从中挑选3种主流的组件（为交叉学习做准备），然后收集这三种组件的笔试面试题，先做一遍，不管对错，只求对这些组件有个初步的重点内容印象（先考试后学习）。买来相应的书，把3种组件中相类似的章节对应起来，在学习过程中，学完第一种组件第一章后，改为学习第二种组件的第一章，然后学第三种组件的第一章，然后再回到第一种组件进行第二章的学习（交替学习，中断）。一边看一边把关键知识点整理成题目，每个章节看完2天后用这些题目进行自考（尽早考试，适当遗忘，第一次复习，学习过程混杂学过的内容），自考一个星期后、一个月后分别再次自考，之后的复习以两个月为一次进行，可以只挑选出更核心的知识点作为每两个月一次的复习材料（长效记忆的最优复习时间）。在每次复习时，都可以换到不同的场所进行（切换环境）。每学习几个章节后，都尝试把这些章节写成博客，或做成PPT给别人讲解（有意识地反思）。<br>若只是单单学习一种组件，也能按照上面的节奏来进行。</p><p><strong>2.2 如何刷算法题</strong><br>　　假设6个月后就要去面试，可以按照这样的节奏来学习：学习两天后和3个星期后复习（尽早考试），然后再每个月复习一次（最优复习时间），最后在6个月后进行一次全面复习，每次集中练习一类的算法，比如与分治法相关的基于不同数据结构来设计的题进行集中学习（混合学习），先尝试解题后再看答案（先考试后学习），每道题搜索多种解题思路进行对比（有意识地反思），并简单记录每种解题思路的区别及其优缺点，作为每次复习的自考内容。学习时切换到不同的场所来进行（切换环境），复习时可以在不同于学习时的场景来进行。</p><p><strong>2.3 如何提高英文技术文档阅读能力</strong><br>　　假设目标是能较为流畅地看英文的官方文档或技术博客，该目标可以转化为要在看文档的时候遇到单词能够不经思考地获知其含义。想一下自己是怎么看中文文档的，凡是在看公众号文章有一目看几行能力的人都知道，看文档时心中不会默念，看一行字的时候并不一定是从左往右看的，文字的含义是不经思考就知道的，并且往往在阅读时会自动略过不重要的部分。快速阅读可以看作是一种视觉的模式识别，我们需要的是进行有效的知觉训练，使我们达到不经思考就能感知到这一连串文字的含义。再来回想下我们阅读英文文档的场景，由于对英文单词的不熟悉，我们在阅读英文文档时往往会出现心中默读的情况，大大影响速度，并且由于前面内容没看懂，导致做不到跳跃式阅读，一篇文档要看很久很难坚持下来。其实计算机类别技术文档中出现的词汇主要就是计算机相关的词汇，词汇量并不会像新闻类的那么大，并且如果是某一种特定技术的文档，比如Kafka的官方文档，使用的词汇量更少。因此我们只要针对常用的计算机词汇进行专门的知觉训练，就能大大提高此类文档的阅读速度。</p><p>　　训练方法：<br>　　挑选一篇中等长度的技术文章先看一遍，其中遇到不认识的单词或句子先查一下做好标记，看完后反复确认下标记的位置确保能短时记忆住这些单词的含义，开始训练。第一阶段：先按习惯的阅读方式从头到尾看一遍，记录用时；第二阶段：用手指以比默读更快的速度从左往右划过句子，以眼睛跟踪手指来看文字代替心中默读，逐渐提高手指划动速度反复阅读同一篇文章，直到速度稳定到第一阶段的三倍以上；第三阶段：还是用手指划过句子看，但改为S字形划动，如第一行从左往右滑动，第二行则从右往左，第三行从右往左，当然每一行的单词不能过多，以自己能够理解句子的程度来控制文档宽度，直到阅读速度也稳定到第一阶段的三倍以上，就可以换下一篇文章再从第一阶段开始。第四阶段：前面三个阶段每读过的文章，都要记录下是哪一天训练的，后续在间隔2天、1星期、1个月分别以第三阶段方式重读文章直到恢复到第一次训练的计时速度，起到复习效果。</p><p><strong>2.4 如何提高代码编写速度</strong><br>　　现代IDE都提供了大量的快捷键来编写代码，但看一圈周围的同事写代码的状态就知道，绝大多数人都做不到大部分操作不通过鼠标来完成，很多人都只懂ctrl+a/s/f/z/x/c/v，alt+tab这几个快捷键，操作基本靠鼠标。不仅限于IDE的快捷键，大家用了这么多年的Window系统也有大量快捷键。其实只要熟练使用快捷键，就能大大减少手离开键盘的时间，能显著地提高代码编写速度。本人作为使用快捷键的深度用户，在使用快捷键的时候感觉其实就跟打字时应该输入按哪个字母一样，并不需要思考手指就能按到那几个位置，而且往往真要说出来按了哪几个键，可能还得思考一下才能答得上来（比如你可以在脑中想一下26个字母每个按键的位置也会有同样的感觉）。因此学习快捷键就跟学习打字是一样的，开始学习打字的时候是一个个字地思考打什么字母，字母在哪里，在打多了相同的字后，速度慢慢就上来了，学习快捷键也是这样，不可能一下子记住很多快捷键的，要有意识的关注自己平常经常用鼠标进行的操作是否有对应的快捷键（当然首先你得先查一下IDE有哪些快捷键，有个印象就行），然后每次挑选一个最常用的鼠标操作替换为快捷键，等到这个快捷键习惯之后，再选择下一个常用的鼠标操作来替换为快捷键，直到能做到90%的操作都能通过快捷键完成。这种反复刻意的训练方法其实就是知觉训练。</p><p>　　还有一种训练方法：挑选几道简单的并且涉及到多个代码文件来回切换编写的题目来练手（比如按照先写测试后写代码的方式来编写代码，包括了写测试、运行测试、实现代码、运行测试、写新测试的反复流程）。每道题目在实现时需要做到完全不碰鼠标，在第一次编写的时候可以先记录下哪些操作用到鼠标了，然后查一下IDE有没有对应的快捷键，贴在电脑旁边，第二次实现的时候开始完全不用鼠标。反复地新建项目来实现，直到所有快捷键都能在3秒内按出来。对于Window的快捷键也可以设计操作步骤来进行专门的练习。</p><h3><span id="3-总结">3. 总结</span></h3><p>　　以上所说的各种学习场景，都需要每次学习完一个知识点后记录下这个知识点是在什么时间、什么地点学的，以此来确定应该什么时候复习、复习时怎么切换环境。此外，由于程序员学习的内容基本上是偏逻辑性的，深度睡眠阶段（第三四阶段）对知识整理具有显著效果，因此要注意睡眠的规律性，充分发挥深度睡眠对知识的加固作用，可以清晨学习一次，利用午休的深度睡眠提升效果。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 书籍 </tag>
            
            <tag> 方法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《如何学习》读后总结(上)</title>
      <link href="2020/12/17/cb2822dcfcebe090bae08b6c103ab898/"/>
      <url>2020/12/17/cb2822dcfcebe090bae08b6c103ab898/</url>
      
        <content type="html"><![CDATA[<h3><span id="前言">前言</span></h3><p><img src="/2020/12/17/cb2822dcfcebe090bae08b6c103ab898/1608215640668.png"><br>　　最近看了《如何学习》这本书，感觉自己的认知受到了很大的冲击，脑子里很多想法冒出来了，对学习这件事的理解完全不同了，强烈推荐大家都看一下。出于对这本书的喜爱和希望记录自己脑子里迸发出来的一些学习念头，有了这上下两篇文章。《上篇》是基于原书的内容，抽取出书中我认为重要的实验和结论汇集而成，里面的描述以自己的叙述逻辑进行了调整和精简，对不重要的内容进行了删减；《下篇》则是对本书的重要结论进行进一步总结，并结合实际的学习场景谈下应该如何运用这些结论来提高学习效果。</p><p>　　不足之处希望大家指正，有更多的想法也希望大家在评论区一起讨论。</p><h3><span id="1-基础理论学习时大脑是如何运作的">1. 基础理论：学习时大脑是如何运作的</span></h3><p><strong>1.1 编故事的能手：大脑学习的机制</strong><br>大脑的内嗅皮层过滤涌入大脑的信息；海马是构筑新记忆的地方；新皮层用来存放显意识记忆。<br>　　<br>　　学习的奥秘：当我们看到听到某个事件时大脑里会有一串细胞被同时“点亮”，就形成了第一次记忆，把这些细胞连接起来的是神经元突触，每当记忆被提取一次这些突触就会被加厚一次，信息的传输速度也会变快。某些分子式的书签夹在神经网络中，在回忆的时候能通过这些书签查阅到历史记忆，同时还会连带更多的关联记忆，但大脑不断变化，记忆也会随着阅历不断变化，时间拉得越长记忆越不准确。</p><p>　　记忆的细节并不会丢失，但每次提取的踪迹都不一样，导致每次提取后的记忆又和之前存储的内容交织在一起，相当于用我们的记忆来改变我们的记忆，因此随着时间流式，记忆就越发不准确。</p><p><strong>1.2 遗忘的威力：过滤干扰信息，激活深处的宝藏</strong><br>　　遗忘能使大脑能够专注于一件事，只让该出现的信息出现在脑海。正常的遗忘有助于继续的学习，这一特性很像我们的肌肉锻炼：当我们提取存储的信息时，为了强化“习得”，一定程度的“损耗”是必不可少的，先损耗，后增长。<br>　　<br>　　记忆遗忘曲线并不完全准确，记忆并非只沿着单一方向一路消散下去，有时候记忆会根据场景自动冒出一些我们并不记得曾经学过的词语、数据，会出现测试得分自动提升的效果。如果学习材料是无意义或无关联的符号或音节，在一两天后的考试检验时不会出现自动提升的效果，如果学习材料是图片、照片、诗歌和诗情画意的文字等，大概率会出现自动提示的效果，这种效果需要一两天后才会显现出来。</p><p>遗忘式学习：任何记忆都具备存储和提取能力。记忆的存储能力只会越变越强，永远不会减弱，这意味着每一样我们刻意交代给记忆的东西都会被永久存储起来，大脑的存储空间足以存储我们从生到死每一秒钟的所见所闻。记忆的丢失其实是提取能力变得很低，我们一时无法提取。提取能力会因为学习和反复运用而变得越加坚实，能够提取的记忆容量很少，我们自能提取与大脑发出的提示和给定线索有关的记忆，而且仅仅是非常有限的一小部分。我们在提取某项记忆的时候越是费力气，那么在回忆起后，记忆的提取能力及存储能力都会得到加强。</p><h3><span id="2-增强记忆我们怎样才能记住新东西">2. 增强记忆：我们怎样才能记住新东西</span></h3><p><strong>2.1 打破学习的好习惯：环境对学习的影响</strong><br>　　<br>　　实验：三组学生分别学习单词，场地分别为安静教室、放爵士音乐的教室、放古典音乐的教室，两天后测试，每种学习场地的组各自再分为三组，分别到这三种场地进行测试，结果表明，在相同环境学习和测试的成绩明显好于在不同环境进行测试，并且在安静教室测试的成绩最差。一种可能的原因是安静教室缺乏更多能起到提示作用的信息，因此通常认为的要在安静整洁的场所学习并不一定是正确的。<br>　　结论：在学习中，只要你能看见、听到、意识到的背景或者内在的心境状态，都能成为回忆时的提示。<br>　　<br>　　实验：两组学生学习单词，一组学习前吸了真大麻，一组吸了假大麻，测试时每组学生都再分为两组，一组吸真大麻考试，一组吸假大麻考试，最终的四组测试结果表明，考试前后吸相同类型大麻的成绩接近，考试前后吸不同类型大麻的成绩更差，说明记忆效果与提取时大脑的状态是否相同更相关，大麻并没能明显提高学习效果。<br>　　结论：如果能还原到最初学习的场景中，记忆效果会更好。<br>　　<br>　　实验：三组学生学习单词，第一组在小而凌乱地下室A学两次，第二组在能看到窗外院子的房间B学习两次，第三组一次在小而无窗的房间C学习，一次在能看到窗外院子的房间B学习，考试安排在一个全部人都没来过的教室，结果是第三组的成绩比第一二组的成绩高出40%。<br>　　 结论：变换场所学习能大大提高学习效果。</p><p>建议：备考复习时，不要直接照着笔记复习，先把笔记放一边，重新整理学习材料，自己想出一套全新的重点概述出来，这样会强迫你把学习材料都过一遍，并且是以一种不同的思路过一遍。无论你改变了环境中的哪些方面，只要你改变了能够改变的（环境、时间段、顺序等），就会有效。如果习惯了在一个场景里重复练习，容易导致到了另外环境时发挥不出来练习时的水平。<br><strong>2.2 拉开时间间隔：化整为零才能记得持久</strong><br>　　<br>　　实验：对无意义的音节表按不同复习间隔进行学习，第一种间隔为第一天学习68次全部记住，第二天再复习7次，即共学习76次；第二种为第一天学习20次不求全部记住，第二天学习12次，第三天学习6次，即共学习38次。这两种间隔最终都达到了记住全部音节的效果。<br>　　结论：相同的重复次数，若恰当地分为几组、拉开时间距离来完成，要比集中起来一次完成的效果明显好很多。<br>　　<br>　　实验：对一份单词表进行学习，详细记录每次多长时间会忘记，也记录再次复习后会在多长时间后忘记。最终发现最佳复习间隔：第一次学习后，一两天内复习一次，过一个星期后再复习，然后过一个月后再复习，就能持续保持记住。<br>　　结论：对于短时的需要保证记住的考核目标，可以采用如上的时间间隔进行复习，达到以更少的复习时间记住更多内容的目的。<br>　　<br>　　实验：一份300个陌生单词的词汇表，平均分为6组，每组按照不同时间计划进行学习，比如一组每两个星期学习一次，一组每个月学习一次，还有的两个月一次等等，每次学习都要记住全部单词为止，每一组的总学习次数都都26次，5年后测试每组还能记住多少。最高分为每两个月学习一次的组，得分76，每两个星期一次的组得分56。<br>　　结论：对于终生学习，在相同复习次数的情况下，最大复习间隔最好约为两个月，能达到记忆更长时间的最优效果。<br>　　<br>　　实验：对于32条生僻问答题资料，设定不同的待考时间点，在待考时间点之前只能学习两次，学习两次的时间间隔分为多种情况，最终对于相同待考时间点的不同学习间隔的成绩进行对比。<br>　　结论：对于不同的待考时间点，两次学习的最佳间隔如下：<br>　　1. 1星期后考试时，两次学习间隔最好为1-2天；<br>　　2. 1个月后考试时，两次学习间隔最好为1星期；<br>　　3. 3个月后考试时，两次学习间隔最好为2星期；<br>　　4. 6个月后考试时，两次学习间隔最好为3星期；<br>　　5. 1年后考试时，两次学习间隔最好为1个月。</p><p>结合前面几个实验的结论，可以这样安排复习时间：若3个月后考试，可以先学习一次，在2天、2个星期和 1个月后分别复习一次，考试前最后复习一次；若6个月后考试，可以在学习之后间隔2天、3个星期分别复习第一次，然后进行2次间隔2个月的复习，考试前最后复习一次。<br>　　这样的复习计划，不仅和考试前集中复习几次的效果相当，而且记忆的时间能够持续更久，保留记忆到下个学期还能显著提高新知识的学习效果。对于大多数学生来说，期中和期末考试各2-3个月，意味着只要在第一次学习后的1-2天内和1-2个星期后分别复习一次，就能在考试中有不错的表现。<br>　　<br>　　对于为何拉开学习时间间隔能提高学习效果，科学界尚无定论，可能的原因：<br>　　1. 大脑对于快速重复出现的信息容易变得不感兴趣，短时间内多次复习对于增加记忆提取能力的效果越来越差，拉开时间间隔学习，大脑对遗忘的知识再次提取能更有效提高记忆提取能力；<br>　　2. 分散式学习能够提供更多的背景提示；<br>　　3. 跨度更大的时间间隔能让更难记住的知识变得明显，有利于针对性的加强这些知识的记忆。</p><p><strong>2.3 先考试后学习：利用无知的潜在价值</strong><br>　　<br>　　实验：安排三组学生花9分钟时间背诵一篇短文章，第一组花2分钟学习，再用7分钟背诵，第二组学习和背诵各一半时间，第三组用8分钟学习，1分钟背诵，过了3小时后背诵，最终高年级学习占30%比例的学习效果最好，低年级占40%比例最好。<br>　　结论：要想记忆一篇文章，最好是先花三分之一时间学习，剩下的时间都凭记忆背诵。<br>　　<br>　　实验：招募3605名学生学习一篇文章，只有一次学习机会，学完后分为8组，并在后面的2个月里分别接受几次考试，不同组的学生考试时间不同，比如第一组学完后当即考一次，第二天又考一次，三星期后再考一次，第三组则学完后在第三个星期才进行一次考试，每组考完试都不会给答案也不给复习。最终在第一个星期接受了1~2次考试的小组在两个月后的最终考试时得分最高，学习后放空了两个星期的组得分最低。<br>　　结论：学习后马上考试能有效地加深记忆，应该多增加考试的频率。大脑从记忆中提取学过的知识，付出的努力远比直接重读一遍或重学一遍要多得多，这份额外的努力加强了那些记忆的提取能力，让我们记得更牢。<br>　　<br>　　实验：两个班学生分别上3堂课，其中一个班在每次上课的前一天先对将要教授的课程进行预考，预考时每个学生都考得一塌糊涂，3节课后过了两个星期后再进行考试，最终测试中每次都进行了预考的班级得分高出10%。<br>　　结论：预考能让人提前接触日后将要涉及的知识，在后续学习的过程中就能有意识地关注这些知识点，从而达到更好的学习效果。<br>　　<br>　　此外，在学习了一样东西之后，尝试对着自己或他人表述出来，能有效消除熟练度错觉，让自己真正看清还有哪些地方是不理解的，就能更有针对性地复习。</p><h3><span id="3-解答难题如何完成生活与工作中的负责课题">3. 解答难题：如何完成生活与工作中的负责课题</span></h3><p><strong>3.1 孵化：沉淀思维离不开分心与分享</strong><br>　　<br>　　顿悟往往包含如下4个步骤：<br>　　1. 准备期。花费大量时间进行琢磨，直到没有思路为止；<br>　　2. 孵化期。这时候把问题搁到一边，去做其他时间或者放松一下，这段时间大脑会围绕课题继续工作，时不时地把早就装在大脑里的知识加到课题中；<br>　　3. 顿悟期。大脑在某一时刻加入的想法足够让课题进行下去；<br>　　4. 验证期。对顿悟的想法进行验证。<br>　　<br>　　实验：一间宽敞的房间里有几张桌子，椅子，一组各式各样的工具，包括夹子，钳子，金属杆和电源线，此外天花板上垂下来两条绳子，一根在房间正中，一根贴着墙垂着，参与者需要把两根绳子绑在一起，其中不借助任何工具单靠人手拖绳子是不可能拉在一起。解决方案有4种，难度不一。最终40%的参与者在10分钟内想到了4种方案，剩下的60%参与者先休息一会，然后组织者有意的在房间里走动和碰触绳子，两分钟后基本全部人都想出了答案，休息时间可以看做孵化期。实验结束后询问参与者是怎么想出解决方案的，大多数参与者都觉得答案是灵光一现的，没有意识到是被绳子的晃动提醒了。<br>　　结论：在孵化期里，大脑会周围任何可能与解决问题相关联的信息都很敏感。<br>　　<br>　　实验1：一间房间中有一张桌子，几把椅子，桌上有榔头、钳子、回形针、纸、胶带和细绳等，还有几个小盒子里面装着些零七八碎的东西，如图钉、小蜡烛、纽扣、火柴等，要求每个参与者在10分钟内想到尽可能多点办法，使用桌子上的任何东西，把三支小蜡烛固定到门上与眼睛持平的高度点亮。大多数人尝 装试了几种办法后就想不到更多办法了，但只要做一个小调整：把图钉火柴等小东西从盒子里拿出来，参与者就很容易想到用图钉把盒子固定到门上来摆放蜡烛。盒子腾空这一动作使得参与者脑中的认为盒子是用来装东西的虚拟实体发生了变化：盒子的作用不再局限于装东西。<br>　　实验2：参与者进行远程联想测试，比如拿到3个词：旅行(trip)、房屋(house)、进球(goal)，需要找到一个词能同时跟前面3个词组成惯用词组。参与者分为两组，每组拿到20道题，第一组中每道题只有3个词语，第二组每道题的旁边都有误导字眼，比如上诉3个词旁边写着道路(road)可以跟头两个词组成词组，和第三个则不匹配。10分钟后第一组平均解出5道，第二组平均解出2道。随后两组各自分别再拆分成两组，其中一组立即投入工作，另外一组则休息5分钟看科幻小说（孵化期），10分钟后四组人再进行考试。结果表明有孵化期的成绩明显上升，相对来说测试题中有误导词的人进步更大。<br>　　结论：大脑会在思考问题之前自动的构建一个虚拟实体，这个实体会蒙蔽我们的思路，让大脑只能往预定的轨迹来思考，适当休息能淡化虚拟实体的影响，让人产生顿悟。但孵化期并不见得在所有场合下都能起作用，科学家把孵化休息分为三类：一是放松，比如在沙发上听音乐；二是轻度用脑，比如上网冲浪玩游戏等；三是高度用脑，比如写一篇短文或做作业。对于数学或空间类的难题，三种休息方式都不错，而对于语言类的难题，则轻度用脑效果最好。</p><p><strong>3.2 渗滤：适度中断，欲冲向前，先退一退</strong><br>　　<br>　　孵化期并不能对各种问题都适用，说到底学习不可能被简化为谜语或竞赛题，只需要一次顿悟就能解决，我们面对的问题往往是需要多种办法、旷日持久地去面对的，我们需要的不是速效药，而是长效药。我们都体验过在完成某项复杂任务时，会有疲倦和卡壳的时候，我们都曾在这样的时刻停下来，通过休息来驱散脑子里的迷雾，从而找到解决办法，这可以看作是长时间的多次孵化，为了区分前面说的短时孵化，我们把这种长期的，逐渐积累的过程称之为渗滤。<br>　　<br>　　实验：要求参与者做一连串的需要三到五分钟就能做完的小事情，如用纸做个盒子、猜一个字谜等，在做的过程中随机打断参与者的工作，在做到一半的时候交代另外一项任务，结束时，参与者被分派的任务中有些任务做完了，有些没做完，要求参与者列出分配给他们的任务。结果参与者能记住的被中断的任务数量比已经完成的任务多出近一倍，而且那些被中断的任务最先被写下来。<br>　　结论：中断任务能使任务记得更牢，并且越是在关键的时刻被打断，对那件事情的记忆就越长久。</p><p>渗滤第一要素：打断。<br>　　实验：把参与者分为两组，一组先吃了糖，另一组没有吃糖，把参与者待到一个办公室中，里面有椅子、书桌、书本、纸张、铅笔、文件档案夹、电脑等等，在这些东西附近随意摆放着一些跟喝水有关的东西，如矿泉水瓶、水杯、茶杯、饮料罐等，参与者在办公室中先填写一段跟实验毫无关系的问卷，然后继续枯坐4分钟，最终让参与者写出在办公室中记得的所有东西。结果表明吃了糖的组记得跟喝水有关的物品数量是对照组的两倍之多。</p><p>渗滤第二要素：一旦某个目标被激活，它便能盖过其他一切，调动起我们的感知、思维和心态去关注身边的一切。<br>　　那么我们该如何激活心中的某个目标呢？通过打断的方式，能让大脑把当前在做的事情推到首要位置，在中断任务期间，大脑会自动的关注身边的一切，以期来更好的解决问题。<br>　　<br>　　实验：在教学课程中需要在一个学期中写6篇文章，按照通常的做法最终交上来的文章更像是前人发表过的学术文章的剪贴编辑。下面改变写文章的要求：总共也是写6篇文章，但前5篇以练习为主，如一篇练习文章描述如何访问一名专家，另一篇则练习如何确定核心词语，第三篇则是针对自己所选主题面临的有争议的各个思想流派，他们该如何加以应答，要求学生在调研过程中做笔记，记录下他们面对调研中的各种人物或资料时，自己心中有什么感受，是否认为某篇文章的论述合情合理，是否认同文章中的主要观点等。在期末写第6篇正式文章时，学生们明显变得能够担当起行家的角色，以充分的自信和充足的论据展示了足以真正促进学术交流的能力。<br>　　结论：学生的每一次记录笔记，都是对自己接触的东西的反思，让他们在编写文章的时候，能够有自己的思考，不至于人云亦云。</p><p>渗滤第三要素：有意识地反思。<br>　　总结：所谓渗滤，其关键在于一直保持着心神的警觉，不断想办法调动起我们的头脑来，关注跟手中那份未完成项目相关联的一切，随时采集各种对外界的感知，并感悟自己内心的反思。</p><p>如果我们手上有一个相当庞大的项目，那就应该尽早开始，遇到思路不畅的时候我们不妨停一停，告诉自己这样的停顿不是逃避困难，而是主动进入渗滤的过程。<br>　　在继续向前猛冲之前，先停下来，这并不等于就此放弃了应该完成的任务，相反，停下来意味着我心里会一直惦记着它，这就是渗滤的第一阶段，同时开启了第二阶段，大脑会有意无意地采集数据和资料。第三阶段则是听取自己的想法：我怎么思考，怎么分析这些收集起来的东西。</p><p><strong>3.3 交替：混杂在一起印象更深刻</strong><br>　　<br>　　通常我们会信奉一种观点：想要掌握某种技能，我们只要埋头苦干，专心地重复练习，就能很快掌握这种技能。但实际上我们会发现，现实并不如我们所愿，在经过长时间的练习时，我们并没有得到预期的熟练程度，而往往能看到其他并不专心练习的同伴，却能更熟练地掌握这种技能。是时候停下来思考一下，我们的这种练习方法，到底对不对。<br>　　<br>　　实验：孩子分为两组，练习遮住眼睛来投掷沙包到指定圆圈，一开始两组的测试结果相当，下面进行为期12周的练习，第一组向固定的离站立点1米之外的小圆圈投掷沙包，第二组则练习向两个远近不同的圆圈投掷，一个半米远，一个1.2米远，每次投掷都是一远一近交替练习。12周后进行测试，往接近1米距离的圆圈投掷，按距离来说更偏向于第一组孩子，但结果是第二组孩子获胜了。<br>　　结论：不同动作的交替训练比单一动作的固定训练更为有效，因为它能内化肌体动作的基本法则，从而使肌体经过调整，对任何距离的目标都更有准头。<br>　　<br>　　实验：参与者分为3组练习三种羽毛球发球动作，每周训练3次每次发36个球，统一站在右半场，A组是固定训练，每次只反复练习一个动作，比如第一天发36个网前球，第二天发高远球，第三天发平快球，B组是顺序练习，每次均按照网前球、高远球和平快球的固定顺序循环发球，C组则是让参与者自己随意决定练习什么球，唯一的要求是同一种发球不能连续出现。3周结束后进行测试，要求参与者站到左半场发球，考核员要求每次都发不同的球，每种球各发6次。最终A组得分12，B组得分14，C组得分18，而在练习过程中，A组在单项的测试中都是一直领先其他组的。<br>　　结论：对单一而重复的集中训练的搅扰，使得受训者不得不一再做出调整，结果反而培养出了总体上的灵活应变能力，更由此提高了某项特定动作的准确度。<br>　　<br>　　实验：参与者分为两组记忆50个姓名的名单，A组专心记忆，B组在学习过程中故意安排他们学习其他东西来干扰他的学习，在30分钟后进行测试，收到打搅的B组得分比A组高出10%。此外还有其他针对键盘指法、电玩技巧、精确手臂运动等方面的实验，都有一个共同的特点：只要研究者以各种方式打乱训练动作的单一重复，受训者的成绩最终都会超过不收打扰的集中训练的成绩。<br>　　<br>　　这里并不是说重复训练一无是处，对于任意一种技巧或学习材料，我们都需要一定程度的重复来熟悉它，问题是一再的重复，会让大脑产生你已经掌握的错觉，进步会变得缓慢。</p><p>结合前面章节所说的学习技巧。把整块学习时间打散成数次就是一种穿插模式，能让我们事半功倍，学习时变换环境，也能使我们学得更牢。这些技巧无一不是在破环学习时的专注度，无疑会导致我们在每次学过之后都会忘掉一些内容，但根据遗忘式学习的理论，在遗忘后大脑会花更大力气提取记忆，这一额外的努力能够强化记忆提取能力和存储能力。<br>　　实验：两组小学生学习数学知识，首先研究员对每组学生进行一次辅导，教他们怎么根据棱柱体上下底面的边数来计算棱柱体有多少个面、多少个棱、多少个顶点和转角。辅导时，A组学生采用集中学习法，先练习8个面的习题，然后是8个“棱”的习题，然后是8个“顶点”的习题，最后是8个“转角”的习题，每种题目都是一口气练习8个，中间有30秒的休息。B组也也练习了相同的题目，但是每次一口气练习的8道题是不同题型交叉混合的。第二天进行测试，A组正确率是38%，B组正确率是77%，大幅领先A组。<br>　　<br>　　实验：两组学生进行12名画家风格辨识的练习，A组每次看一个画家的6张作品，每幅画显示3秒，画的下方标有画家的名字，B组学习了相同的时长和画作数量，但在学习过程中同一画家不是连在一起集中学习的，而是把不同画家的作品穿插到一起。学习后，两组学生都进行数数来放松以清除短时记忆，然后以在学习过程中没有出现的画作进行测试。结果A组正确率是50%，B组正确率65%。<br>　　结论：交替学习是把既相关又不相同的题材混合到一起来学习，能够大大提高学习的效果。<br>　　<br>　　实验后研究员询问参与者的看法，让他们评价哪种学习方法对自己更有帮助，结果将近80%的学生认为集中学习比交替学习效果更好，哪怕他们已经知道了正是交替学习让他们的测试成绩遥遥领先。因此虽然我们现在已经知道交替学习不但能使我们更清楚了解每一项之间的不同之处，还能使我们更彻底地掌握好每一项内容，但要应用这一结论，困难在于我们不肯放弃对简单重复的固有信奉。<br>　　<br>　　交替学习的方法非常因人而异，因内容而异，用在某些科目或技巧上的效果尤为突出。不过最关键的地方在于，在设计自己的交替学习方案时，一定要把新的科目或技巧跟学过、练过但已经有一段时间没有复习过的内容混在一起。交替学习的功效就是让大脑准备好随时面对意想不到的事情。</p><h3><span id="4-潜入意识的深海学霸的终极武器">4. 潜入意识的深海：学霸的终极武器</span></h3><p><strong>4.1 不加思考地习得：把握感知的力量</strong><br>　　<br>　　棒球运动中击球手需要在250毫秒中辨别飞过来的球的轨迹，国际象棋中大师能在5秒内就记住棋盘上所有棋子的位置，在跟电脑比赛的过程中只考虑几种不同的对策以及接下来的攻防手段，就能跟电脑搜索到的10亿中可能的手法进行对抗，这些现象，都是知觉学习的效果。<br>　　<br>　　知觉学习是主动式学习，我们的眼睛或鼻子等其他器官会主动搜寻正确的信息，这是大脑的自主行为，无需借助外力，大脑能够根据我们所关注内容的差别进行自我修正，为关键的信息打上标记，同时自动过滤其余信息。因此棒球高手眼睛看到的仅仅是与判断轨迹有关的动态光斑，象棋大师看一眼就能排除掉不必要的选择，所需考虑的步骤更少，更容易找出最有效的攻防手段。<br>　　<br>　　实验：两组飞行员进行知觉训练，A组是毫无经验的新手，B组是具有1000小时飞行经验的飞行员，训练内容为观看6个表示飞机不同飞行参数的电子仪表盘，判断飞机的飞行状态。训练过程中屏幕上会显示一组仪表图，下面是多个选择，选错会提示并弹出正确答案。一个小时训练后，A组的成绩就达到了跟B组接近的水平，就算是B组也在这次训练中得到了提高。<br>　　<br>　　实验：两组医学院学生进行胆囊切除手术过程判别是哪一个环节的知觉训练。A组观看一段段的手术实况剪辑，一遍迅速判断剪辑镜头属于手术中的哪个环节，B组观看同样的剪辑，但按照自己的喜好随意自学，还可以根据自己的需要回放相应的部分。学习半小时后，A组学生的成绩比B组高出4倍之多。<br>　　<br>　　实验：作者为了能辨认出画作的艺术流派，设计了一套知觉学习训练。先挑选12种艺术流派，每种流派从网上下载10幅作品，共120幅画。每次只显示一幅画，画作下面显示12种艺术流派，选对了则显示√，错误则显示×并高亮正确的选项。第一次全靠瞎猜，第二次开始对极简主义和未来主义有了感觉，第四次已经把表现主义和达达主义掌握得差不多。每次训练间隔休息一小会，一个小时后共进行了6次训练，然后使用36幅没有出现过的画作进行测试，正确率80%。<br>　　<br>　　结论：运用知觉学习训练时节奏必须要快，要让视觉等知觉系统快速运行，让认知系统、思考系统同样都快速运作起来，交替学习和知觉学习两者可以互相补充，相辅相成。</p><p><strong>4.2 打个盹儿就能赢：让睡眠来巩固你的学习成果</strong><br>　　<br>　　科学家发现了人在睡觉之后，会出现眼睛快速运动的情况，同时脑电波会出现不亚于清醒时的起伏，说明大脑在入睡后也在进行工作。<br>　　<br>　　实验：两组学生分别学习彩蛋的阶层关系：彩蛋图案之间存在大小的层级，每次只显示两个在层级中紧挨在一起的彩蛋并标注它们之间的大小。A组在早上学习，B组在晚上学习，学习后马上进行考试，只考紧挨的两个彩蛋的大小关系，两组都取得了出色的成绩。在12小时后，再次进行考试，这次要求他们辨识不紧挨在一起的两个彩蛋的层级关系。A组正确率只有69%，B组则高达93%，又过了24小时后，两组的差距拉大到35%。<br>　　<br>　　猜测：在睡眠过程中，大脑会拓宽记忆的透光孔，让我们看到更完整的景象，建立起不同的关联和组合等记忆。在其他实验中也证明了睡眠能增强前一天所学内容的理解力和记忆力，比如词汇学习、单词配对、逻辑推理、报告陈述、考试等，当然前提是需要记住这些项目的关键之处的细节，才能借助睡眠把这些要点拼凑起来，这样做能让成绩提升10%~30%。<br>大脑睡眠结构图：</p><p><img src="/2020/12/17/cb2822dcfcebe090bae08b6c103ab898/1608215859929.png"><br>　　第一阶段：睡眠的开头阶段，属于轻度睡眠，这一阶段常常会有类似快速眼动睡眠的模式出现。<br>　　快速眼动睡眠阶段：这一阶段大脑忙着进行模式识别，帮助我们感知在白天显现不出来的各种关系，如彩蛋实验，以及创造性难题的解决。<br>　　第二阶段：这是运动记忆的专场，如果这个阶段的睡眠被打断，会让运动学习效果显著变差，如音乐学习、体育运动、机械操作等技能的学习都属于运动学习。<br>　　第三和第四阶段：这两个阶段也被称为慢波阶段和深度睡眠阶段，是延长记忆的关键阶段，如果缺少这一阶段的睡眠，会削弱对新学的知识的记，这一阶段对巩固陈述性记忆十分重要。<br>　　此外实验表明，白天睡1~1.5个小时所得到的学习辅助效果，跟一整晚8小时的通宵睡眠几乎不相上下。</p><p>要发挥睡眠对记忆的效果，需要保证上面五个阶段都得到充足的时间，而不管是习惯于什么时间段睡觉的。当明后天需要进行考试时，适当调整作息时间能够使复习效果更好。假如平常习惯是23点睡到7点，大脑生物钟习惯在这段时间分段调整脑波，适当晚点睡，能够压缩深度睡眠时长，早上睡会懒觉增加第一二阶段的时长，有利于模式识别和运动记忆这两种考试，如数学或化学考试、音乐表演等。如果是要应付如默写单词等需要发挥记忆的考试，就可以稍微早点睡觉，然后早点起床再复习一遍，这样能拉长深度睡眠的时长，缩短对记忆效果不太明显的第一二阶段的时长。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 书籍 </tag>
            
            <tag> 方法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>服务端高并发分布式架构演进之路</title>
      <link href="2020/12/17/fa34b27740b8f3e67c8cad7657be3367/"/>
      <url>2020/12/17/fa34b27740b8f3e67c8cad7657be3367/</url>
      
        <content type="html"><![CDATA[<p>原文: <a href="https://segmentfault.com/a/1190000018626163">服务端高并发分布式架构演进之路</a>, 作者: huashiou 。<br>作者使用一个商城的例子，演示了架构的演变之路，思路清晰，并且解释了架构的瓶颈以及解决之道。</p><h2><span id="1-概述">1. 概述</span></h2><p>本文以淘宝作为例子，介绍从一百个并发到千万级并发情况下服务端的架构的演进过程，同时列举出每个演进阶段会遇到的相关技术，让大家对架构的演进有一个整体的认知，文章最后汇总了一些架构设计的原则。</p><h2><span id="2-基本概念">2. 基本概念</span></h2><p><strong>分布式</strong><br>系统中的多个模块在不同服务器上部署，即可称为分布式系统，如Tomcat和数据库分别部署在不同的服务器上，或两个相同功能的Tomcat分别部署在不同服务器上<br><strong>高可用</strong><br>系统中部分节点失效时，其他节点能够接替它继续提供服务，则可认为系统具有高可用性<br><strong>集群</strong><br><strong>负载均衡</strong><br>请求发送到系统时，通过某些方式把请求均匀分发到多个节点上，使系统中每个节点能够均匀的处理请求负载，则可认为系统是负载均衡的<br><strong>正向代理和反向代理</strong><br>系统内部要访问外部网络时，统一通过一个代理服务器把请求转发出去，在外部网络看来就是代理服务器发起的访问，此时代理服务器实现的是正向代理；当外部请求进入系统时，代理服务器把该请求转发到系统中的某台服务器上，对外部请求来说，与之交互的只有代理服务器，此时代理服务器实现的是反向代理。简单来说，正向代理是代理服务器代替系统内部来访问外部网络的过程，反向代理是外部请求访问系统时通过代理服务器转发到内部服务器的过程。</p><h2><span id="3-架构演进">3. 架构演进</span></h2><p><strong>1.单机架构</strong><br><img src="/2020/12/17/fa34b27740b8f3e67c8cad7657be3367/1608213738511.png"><br>以淘宝作为例子。在网站最初时，应用数量与用户数都较少，可以把Tomcat和数据库部署在同一台服务器上。浏览器往<a href="http://www.taobao.com发起请求时,首先经过dns服务器(域名系统)把域名转换为实际ip地址10.102.4.1,浏览器转而访问该ip对应的tomcat./">www.taobao.com发起请求时，首先经过DNS服务器（域名系统）把域名转换为实际IP地址10.102.4.1，浏览器转而访问该IP对应的Tomcat。</a></p><p>随着用户数的增长，Tomcat和数据库之间竞争资源，单机性能不足以支撑业务</p><p><strong>2.第一次演进：Tomcat与数据库分开部署</strong><br><img src="/2020/12/17/fa34b27740b8f3e67c8cad7657be3367/1608213788709.png"><br>Tomcat和数据库分别独占服务器资源，显著提高两者各自性能。</p><p>随着用户数的增长，并发读写数据库成为瓶颈</p><p><strong>3.第二次演进：引入本地缓存和分布式缓存</strong><br><img src="/2020/12/17/fa34b27740b8f3e67c8cad7657be3367/1608213880895.png"></p><p>在Tomcat同服务器上或同JVM中增加本地缓存，并在外部增加分布式缓存，缓存热门商品信息或热门商品的html页面等。通过缓存能把绝大多数请求在读写数据库前拦截掉，大大降低数据库压力。其中涉及的技术包括：使用memcached作为本地缓存，使用Redis作为分布式缓存，还会涉及缓存一致性、缓存穿透/击穿、缓存雪崩、热点数据集中失效等问题。</p><p>缓存抗住了大部分的访问请求，随着用户数的增长，并发压力主要落在单机的Tomcat上，响应逐渐变慢</p><p><strong>4.第三次演进：引入反向代理实现负载均衡</strong><br><img src="/2020/12/17/fa34b27740b8f3e67c8cad7657be3367/1608213907983.png"><br>在多台服务器上分别部署Tomcat，使用反向代理软件（Nginx）把请求均匀分发到每个Tomcat中。此处假设Tomcat最多支持100个并发，Nginx最多支持50000个并发，那么理论上Nginx把请求分发到500个Tomcat上，就能抗住50000个并发。其中涉及的技术包括：Nginx、HAProxy，两者都是工作在网络第七层的反向代理软件，主要支持http协议，还会涉及session共享、文件上传下载的问题。</p><p>反向代理使应用服务器可支持的并发量大大增加，但并发量的增长也意味着更多请求穿透到数据库，单机的数据库最终成为瓶颈</p><p><strong>5.第四次演进：数据库读写分离</strong><br><img src="/2020/12/17/fa34b27740b8f3e67c8cad7657be3367/1608213945606.png"><br>把数据库划分为读库和写库，读库可以有多个，通过同步机制把写库的数据同步到读库，对于需要查询最新写入数据场景，可通过在缓存中多写一份，通过缓存获得最新数据。其中涉及的技术包括：Mycat，它是数据库中间件，可通过它来组织数据库的分离读写和分库分表，客户端通过它来访问下层数据库，还会涉及数据同步，数据一致性的问题。</p><p>业务逐渐变多，不同业务之间的访问量差距较大，不同业务直接竞争数据库，相互影响性能</p><p><strong>6.第五次演进：数据库按业务分库</strong><br><img src="/2020/12/17/fa34b27740b8f3e67c8cad7657be3367/1608213972679.png"><br>把不同业务的数据保存到不同的数据库中，使业务之间的资源竞争降低，对于访问量大的业务，可以部署更多的服务器来支撑。这样同时导致跨业务的表无法直接做关联分析，需要通过其他途径来解决，但这不是本文讨论的重点，有兴趣的可以自行搜索解决方案。</p><p>随着用户数的增长，单机的写库会逐渐会达到性能瓶颈</p><p><strong>7.第六次演进：把大表拆分为小表</strong></p><p><img src="/2020/12/17/fa34b27740b8f3e67c8cad7657be3367/1608214003287.png"><br>比如针对评论数据，可按照商品ID进行hash，路由到对应的表中存储；针对支付记录，可按照小时创建表，每个小时表继续拆分为小表，使用用户ID或记录编号来路由数据。只要实时操作的表数据量足够小，请求能够足够均匀的分发到多台服务器上的小表，那数据库就能通过水平扩展的方式来提高性能。其中前面提到的Mycat也支持在大表拆分为小表情况下的访问控制。</p><p>这种做法显著的增加了数据库运维的难度，对DBA的要求较高。数据库设计到这种结构时，已经可以称为分布式数据库，但是这只是一个逻辑的数据库整体，数据库里不同的组成部分是由不同的组件单独来实现的，如分库分表的管理和请求分发，由Mycat实现，SQL的解析由单机的数据库实现，读写分离可能由网关和消息队列来实现，查询结果的汇总可能由数据库接口层来实现等等，这种架构其实是MPP（大规模并行处理）架构的一类实现。</p><p>目前开源和商用都已经有不少MPP数据库，开源中比较流行的有Greenplum、TiDB、Postgresql XC、HAWQ等，商用的如南大通用的GBase、睿帆科技的雪球DB、华为的LibrA等等，不同的MPP数据库的侧重点也不一样，如TiDB更侧重于分布式OLTP场景，Greenplum更侧重于分布式OLAP场景，这些MPP数据库基本都提供了类似Postgresql、Oracle、MySQL那样的SQL标准支持能力，能把一个查询解析为分布式的执行计划分发到每台机器上并行执行，最终由数据库本身汇总数据进行返回，也提供了诸如权限管理、分库分表、事务、数据副本等能力，并且大多能够支持100个节点以上的集群，大大降低了数据库运维的成本，并且使数据库也能够实现水平扩展。</p><p>数据库和Tomcat都能够水平扩展，可支撑的并发大幅提高，随着用户数的增长，最终单机的Nginx会成为瓶颈</p><p><strong>8.第七次演进：使用LVS或F5来使多个Nginx负载均衡</strong><br><img src="/2020/12/17/fa34b27740b8f3e67c8cad7657be3367/1608214040030.png"><br>由于瓶颈在Nginx，因此无法通过两层的Nginx来实现多个Nginx的负载均衡。图中的LVS和F5是工作在网络第四层的负载均衡解决方案，其中LVS是软件，运行在操作系统内核态，可对TCP请求或更高层级的网络协议进行转发，因此支持的协议更丰富，并且性能也远高于Nginx，可假设单机的LVS可支持几十万个并发的请求转发；F5是一种负载均衡硬件，与LVS提供的能力类似，性能比LVS更高，但价格昂贵。由于LVS是单机版的软件，若LVS所在服务器宕机则会导致整个后端系统都无法访问，因此需要有备用节点。可使用keepalived软件模拟出虚拟IP，然后把虚拟IP绑定到多台LVS服务器上，浏览器访问虚拟IP时，会被路由器重定向到真实的LVS服务器，当主LVS服务器宕机时，keepalived软件会自动更新路由器中的路由表，把虚拟IP重定向到另外一台正常的LVS服务器，从而达到LVS服务器高可用的效果。</p><p>此处需要注意的是，上图中从Nginx层到Tomcat层这样画并不代表全部Nginx都转发请求到全部的Tomcat，在实际使用时，可能会是几个Nginx下面接一部分的Tomcat，这些Nginx之间通过keepalived实现高可用，其他的Nginx接另外的Tomcat，这样可接入的Tomcat数量就能成倍的增加。</p><p>由于LVS也是单机的，随着并发数增长到几十万时，LVS服务器最终会达到瓶颈，此时用户数达到千万甚至上亿级别，用户分布在不同的地区，与服务器机房距离不同，导致了访问的延迟会明显不同</p><p><strong>9.第八次演进：通过DNS轮询实现机房间的负载均衡</strong><br><img src="/2020/12/17/fa34b27740b8f3e67c8cad7657be3367/1608214069844.png"></p><p>在DNS服务器中可配置一个域名对应多个IP地址，每个IP地址对应到不同的机房里的虚拟IP。当用户访问<a href="http://www.taobao.com时,dns服务器会使用轮询策略或其他策略,来选择某个ip供用户访问.此方式能实现机房间的负载均衡,至此,系统可做到机房级别的水平扩展,千万级到亿级的并发量都可通过增加机房来解决,系统入口处的请求并发量不再是问题./">www.taobao.com时，DNS服务器会使用轮询策略或其他策略，来选择某个IP供用户访问。此方式能实现机房间的负载均衡，至此，系统可做到机房级别的水平扩展，千万级到亿级的并发量都可通过增加机房来解决，系统入口处的请求并发量不再是问题。</a></p><p>随着数据的丰富程度和业务的发展，检索、分析等需求越来越丰富，单单依靠数据库无法解决如此丰富的需求</p><p><strong>10.第九次演进：引入NoSQL数据库和搜索引擎等技术</strong><br><img src="/2020/12/17/fa34b27740b8f3e67c8cad7657be3367/1608214102797.png"><br>当数据库中的数据多到一定规模时，数据库就不适用于复杂的查询了，往往只能满足普通查询的场景。对于统计报表场景，在数据量大时不一定能跑出结果，而且在跑复杂查询时会导致其他查询变慢，对于全文检索、可变数据结构等场景，数据库天生不适用。因此需要针对特定的场景，引入合适的解决方案。如对于海量文件存储，可通过分布式文件系统HDFS解决，对于key value类型的数据，可通过HBase和Redis等方案解决，对于全文检索场景，可通过搜索引擎如ElasticSearch解决，对于多维分析场景，可通过Kylin或Druid等方案解决。</p><p>当然，引入更多组件同时会提高系统的复杂度，不同的组件保存的数据需要同步，需要考虑一致性的问题，需要有更多的运维手段来管理这些组件等。</p><p>引入更多组件解决了丰富的需求，业务维度能够极大扩充，随之而来的是一个应用中包含了太多的业务代码，业务的升级迭代变得困难</p><p><strong>11.第十次演进：大应用拆分为小应用</strong></p><p><img src="/2020/12/17/fa34b27740b8f3e67c8cad7657be3367/1608214137252.png"><br>按照业务板块来划分应用代码，使单个应用的职责更清晰，相互之间可以做到独立升级迭代。这时候应用之间可能会涉及到一些公共配置，可以通过分布式配置中心Zookeeper来解决。</p><p>不同应用之间存在共用的模块，由应用单独管理会导致相同代码存在多份，导致公共功能升级时全部应用代码都要跟着升级</p><p><strong>12.第十一次演进：复用的功能抽离成微服务</strong></p><p><img src="/2020/12/17/fa34b27740b8f3e67c8cad7657be3367/1608214164040.png"><br>如用户管理、订单、支付、鉴权等功能在多个应用中都存在，那么可以把这些功能的代码单独抽取出来形成一个单独的服务来管理，这样的服务就是所谓的微服务，应用和服务之间通过HTTP、TCP或RPC请求等多种方式来访问公共服务，每个单独的服务都可以由单独的团队来管理。此外，可以通过Dubbo、SpringCloud等框架实现服务治理、限流、熔断、降级等功能，提高服务的稳定性和可用性。</p><p>不同服务的接口访问方式不同，应用代码需要适配多种访问方式才能使用服务，此外，应用访问服务，服务之间也可能相互访问，调用链将会变得非常复杂，逻辑变得混乱</p><p><strong>13.第十二次演进：引入企业服务总线ESB屏蔽服务接口的访问差异</strong><br><img src="/2020/12/17/fa34b27740b8f3e67c8cad7657be3367/1608214189091.png"><br>通过ESB统一进行访问协议转换，应用统一通过ESB来访问后端服务，服务与服务之间也通过ESB来相互调用，以此降低系统的耦合程度。这种单个应用拆分为多个应用，公共服务单独抽取出来来管理，并使用企业消息总线来解除服务之间耦合问题的架构，就是所谓的SOA（面向服务）架构，这种架构与微服务架构容易混淆，因为表现形式十分相似。个人理解，微服务架构更多是指把系统里的公共服务抽取出来单独运维管理的思想，而SOA架构则是指一种拆分服务并使服务接口访问变得统一的架构思想，SOA架构中包含了微服务的思想。</p><p>业务不断发展，应用和服务都会不断变多，应用和服务的部署变得复杂，同一台服务器上部署多个服务还要解决运行环境冲突的问题，此外，对于如大促这类需要动态扩缩容的场景，需要水平扩展服务的性能，就需要在新增的服务上准备运行环境，部署服务等，运维将变得十分困难</p><p><strong>14.第十三次演进：引入容器化技术实现运行环境隔离与动态服务管理</strong><br><img src="/2020/12/17/fa34b27740b8f3e67c8cad7657be3367/1608214213366.png"><br>目前最流行的容器化技术是Docker，最流行的容器管理服务是Kubernetes(K8S)，应用/服务可以打包为Docker镜像，通过K8S来动态分发和部署镜像。Docker镜像可理解为一个能运行你的应用/服务的最小的操作系统，里面放着应用/服务的运行代码，运行环境根据实际的需要设置好。把整个“操作系统”打包为一个镜像后，就可以分发到需要部署相关服务的机器上，直接启动Docker镜像就可以把服务起起来，使服务的部署和运维变得简单。</p><p>在大促的之前，可以在现有的机器集群上划分出服务器来启动Docker镜像，增强服务的性能，大促过后就可以关闭镜像，对机器上的其他服务不造成影响（在3.14节之前，服务运行在新增机器上需要修改系统配置来适配服务，这会导致机器上其他服务需要的运行环境被破坏）。</p><p>使用容器化技术后服务动态扩缩容问题得以解决，但是机器还是需要公司自身来管理，在非大促的时候，还是需要闲置着大量的机器资源来应对大促，机器自身成本和运维成本都极高，资源利用率低</p><p><strong>15.第十四次演进：以云平台承载系统</strong><br><img src="/2020/12/17/fa34b27740b8f3e67c8cad7657be3367/1608214239362.png"><br>系统可部署到公有云上，利用公有云的海量机器资源，解决动态硬件资源的问题，在大促的时间段里，在云平台中临时申请更多的资源，结合Docker和K8S来快速部署服务，在大促结束后释放资源，真正做到按需付费，资源利用率大大提高，同时大大降低了运维成本。</p><p>所谓的云平台，就是把海量机器资源，通过统一的资源管理，抽象为一个资源整体，在之上可按需动态申请硬件资源（如CPU、内存、网络等），并且之上提供通用的操作系统，提供常用的技术组件（如Hadoop技术栈，MPP数据库等）供用户使用，甚至提供开发好的应用，用户不需要关系应用内部使用了什么技术，就能够解决需求（如音视频转码服务、邮件服务、个人博客等）。在云平台中会涉及如下几个概念：</p><p>IaaS：基础设施即服务。对应于上面所说的机器资源统一为资源整体，可动态申请硬件资源的层面<br>PaaS：平台即服务。对应于上面所说的提供常用的技术组件方便系统的开发和维护；<br>SaaS：软件即服务。对应于上面所说的提供开发好的应用或服务，按功能或性能要求付费。</p><p>至此，以上所提到的从高并发访问问题，到服务的架构和系统实施的层面都有了各自的解决方案，但同时也应该意识到，在上面的介绍中，其实是有意忽略了诸如跨机房数据同步、分布式事务实现等等的实际问题，这些问题以后有机会再拿出来单独讨论</p><h2><span id="4-架构设计总结">4. 架构设计总结</span></h2><p><strong>架构的调整是否必须按照上述演变路径进行？</strong></p><p>不是的，以上所说的架构演变顺序只是针对某个侧面进行单独的改进，在实际场景中，可能同一时间会有几个问题需要解决，或者可能先达到瓶颈的是另外的方面，这时候就应该按照实际问题实际解决。如在政府类的并发量可能不大，但业务可能很丰富的场景，高并发就不是重点解决的问题，此时优先需要的可能会是丰富需求的解决方案。</p><p><strong>对于将要实施的系统，架构应该设计到什么程度？</strong><br>对于单次实施并且性能指标明确的系统，架构设计到能够支持系统的性能指标要求就足够了，但要留有扩展架构的接口以便不备之需。对于不断发展的系统，如电商平台，应设计到能满足下一阶段用户量和性能指标要求的程度，并根据业务的增长不断的迭代升级架构，以支持更高的并发和更丰富的业务。<br><strong>服务端架构和大数据架构有什么区别？</strong><br>所谓的“大数据”其实是海量数据采集清洗转换、数据存储、数据分析、数据服务等场景解决方案的一个统称，在每一个场景都包含了多种可选的技术，如数据采集有Flume、Sqoop、Kettle等，数据存储有分布式文件系统HDFS、FastDFS，NoSQL数据库HBase、MongoDB等，数据分析有Spark技术栈、机器学习算法等。总的来说大数据架构就是根据业务的需求，整合各种大数据组件组合而成的架构，一般会提供分布式存储、分布式计算、多维分析、数据仓库、机器学习算法等能力。而服务端架构更多指的是应用组织层面的架构，底层能力往往是由大数据架构来提供。<br><strong>有没有一些架构设计的原则？</strong></p><ul><li>N+1设计。系统中的每个组件都应做到没有单点故障；</li><li>回滚设计。确保系统可以向前兼容，在系统升级时应能有办法回滚版本；</li><li>禁用设计。应该提供控制具体功能是否可用的配置，在系统出现故障时能够快速下线功能；</li><li>监控设计。在设计阶段就要考虑监控的手段；</li><li>多活数据中心设计。若系统需要极高的高可用，应考虑在多地实施数据中心进行多活，至少在一个机房断电的情况下系统依然可用；</li><li>采用成熟的技术。刚开发的或开源的技术往往存在很多隐藏的bug，出了问题没有商业支持可能会是一个灾难；</li><li>资源隔离设计。应避免单一业务占用全部资源；</li><li>架构应能水平扩展。系统只有做到能水平扩展，才能有效避免瓶颈问题；</li><li>非核心则购买。非核心功能若需要占用大量的研发资源才能解决，则考虑购买成熟的产品；</li><li>使用商用硬件。商用硬件能有效降低硬件故障的机率；</li><li>快速迭代。系统应该快速开发小功能模块，尽快上线进行验证，早日发现问题大大降低系统交付的风险；</li><li>无状态设计。服务接口应该做成无状态的，当前接口的访问不依赖于接口上次访问的状态。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>精彩文章-2020上</title>
      <link href="2020/12/13/4cf5e038625770918b6d66d603619fa0/"/>
      <url>2020/12/13/4cf5e038625770918b6d66d603619fa0/</url>
      
        <content type="html"><![CDATA[<p>TiDB中文手册(官方)<br><a href="https://github.com/pingcap-incubator/tidb-in-action/blob/master/SUMMARY.md">https://github.com/pingcap-incubator/tidb-in-action/blob/master/SUMMARY.md</a><br><a href="https://github.com/pingcap-incubator/tidb-in-action">https://github.com/pingcap-incubator/tidb-in-action</a></p><p>换种监控姿势：基于深度学习+流处理的时序告警系统<br><a href="https://netsecurity.51cto.com/art/202003/612196.htm">https://netsecurity.51cto.com/art/202003/612196.htm</a></p><p>传统基于规则的告警系统是通过同比、环比、差分、设置阀值等手段来判断当前指标是否存在异常</p><p>深入解析 Go 的信号处理—gsignal<br>signal.Notify signal.Ignore signal.Stop<br><a href="https://gocn.vip/topics/10028">https://gocn.vip/topics/10028</a></p><p>coredns 重点观注日志是中是否有超时，对于大的集群，需要50个实例左右<br>不然会有性能问题</p><p>Kubernetes生态体系落地过程中的选型和踩坑<br>监控/日志/正确的添加sidecar/自定义PodIP/任务调度/容器内时间模拟及系统参数模拟<br>容器中所谓的CPU限制，并不是绑定独占核，而是限制使用时间<br>改写相关内核参数，使用LXCFS实现，yaml中使用hostPath装载<br>项目地址:<a href="https://github.com/lxc/lxcfs">https://github.com/lxc/lxcfs</a><br>容器内时间的模拟，可使用libfaketime，进程启动时添加LD_PRELOAD和FAKETIME环境变量<br>项目地址：<a href="https://github.com/wolfcw/libfaketime">https://github.com/wolfcw/libfaketime</a><br>直接读取etcd中的数据，并解码Protobuf编译过的二进制数据，还原数据为yaml文本<br>项目地址：<a href="https://github.com/jpbetz/auger">https://github.com/jpbetz/auger</a><br><a href="https://blog.csdn.net/M2l0ZgSsVc7r69eFdTj/article/details/104911917">https://blog.csdn.net/M2l0ZgSsVc7r69eFdTj/article/details/104911917</a></p><p>常用正则表达式公式总结<br><a href="https://www.cnblogs.com/bce1100/p/11024212.html">https://www.cnblogs.com/bce1100/p/11024212.html</a></p><p>如何设计大型系统，以及如何应对系统设计面试<br>非常不错 stars 86k<br><a href="https://github.com/donnemartin/system-design-primer/blob/master/README-zh-Hans.md">https://github.com/donnemartin/system-design-primer/blob/master/README-zh-Hans.md</a><br>3 种发布策略，解决 K8s 中快速交付应用的难题<br>比较了k8s中滚动发布、蓝绿发布、金丝雀发布（灰度发布）并附有yaml文件的实现方式<br><a href="https://mp.weixin.qq.com/s/wSl6Gso3cTCpDnR7urS2fQ">https://mp.weixin.qq.com/s/wSl6Gso3cTCpDnR7urS2fQ</a></p><p>接入层Nginx架构及模块介绍分享<br>多图，介绍了nginx的方方面面，包括模块开发，如query_conf<br><a href="https://www.jianshu.com/p/1e4e3887ce9e">https://www.jianshu.com/p/1e4e3887ce9e</a><br><a href="https://mp.weixin.qq.com/s/kom5Qb2lL5ykfqLOhTQM8w">https://mp.weixin.qq.com/s/kom5Qb2lL5ykfqLOhTQM8w</a><br>go语言项目查询网站<br>awesomer go<br><a href="https://awesomer-go.pantas.net/">https://awesomer-go.pantas.net/</a></p><p>Kubernetes监控在小米的落地<br><a href="https://blog.csdn.net/pengzhouzhou/article/details/91921544">https://blog.csdn.net/pengzhouzhou/article/details/91921544</a></p><p>还分不清 Cookie、Session、Token、JWT？一篇文章讲清楚<br><a href="https://www.cnblogs.com/bigzhan/p/12560567.html">https://www.cnblogs.com/bigzhan/p/12560567.html</a></p><p>一文入门ETCD<br><a href="https://juejin.im/post/5e02fb1f518825123b1aa341">https://juejin.im/post/5e02fb1f518825123b1aa341</a></p><p>用 Go 编写能存数百万条记录仍非常快的缓存服务<br><a href="http://blog.studygolang.com/2020/03/writing-fast-cache-service-in-go/">http://blog.studygolang.com/2020/03/writing-fast-cache-service-in-go/</a></p><p>高频 golang 服务接口超时排查&amp;性能调优<br>redis超时排查<br><a href="https://blog.csdn.net/DiDi_Tech/article/details/103849934">https://blog.csdn.net/DiDi_Tech/article/details/103849934</a></p><p>CPU使用率和平均负载的关系<br>0.7 -&gt; 1.0 -&gt; 5 的指标<br><a href="https://blog.csdn.net/tongzhuo1220/article/details/105068723">https://blog.csdn.net/tongzhuo1220/article/details/105068723</a><br>后端程序员必备：书写高质量SQL的30条建议<br><a href="https://www.cnblogs.com/jay-huaxiao/p/12546973.html">https://www.cnblogs.com/jay-huaxiao/p/12546973.html</a></p><p>Golang连接池的几种实现案例<br><a href="https://juejin.im/post/5e58e3b7f265da57537eb7ed">https://juejin.im/post/5e58e3b7f265da57537eb7ed</a></p><p>每日一库的博客<br><a href="https://darjun.github.io/">https://darjun.github.io/</a></p><p>k8s命令执行原理<br>这是kubernetes学习笔记系列文章的一篇<br>介绍 kubectl exec 命令的实现原理<br><a href="https://www.yuque.com/baxiaoshi/tyado3/lxbg9m">https://www.yuque.com/baxiaoshi/tyado3/lxbg9m</a><br>轻量级 Kubernetes k3s 初探<br>史上最轻量级 Kubernetes<br><a href="https://www.infoq.cn/article/0c7viUfLrxOZeh7qlRBT">https://www.infoq.cn/article/0c7viUfLrxOZeh7qlRBT</a></p><p>在gin框架中使用JWT<br><a href="https://www.liwenzhou.com/posts/Go/jwt_in_gin/">https://www.liwenzhou.com/posts/Go/jwt_in_gin/</a><br>相关库<br><a href="https://github.com/dgrijalva/jwt-go">https://github.com/dgrijalva/jwt-go</a><br><a href="https://github.com/appleboy/gin-jwt">https://github.com/appleboy/gin-jwt</a></p><p>Socket Server的N种并发模型汇总<br><a href="https://www.jianshu.com/p/2d10fdaff297">https://www.jianshu.com/p/2d10fdaff297</a></p><p>介绍nginx匹配算法<br><a href="https://www.digitalocean.com/community/tutorials/">https://www.digitalocean.com/community/tutorials/</a><br><a href="understanding-nginx-server-and-location-block-selection-algorithms">understanding-nginx-server-and-location-block-selection-algorithms</a></p><p>Go使用gdb调试<br><a href="https://jiajunhuang.com/articles/2020_04_23-go_gdb.md.html">https://jiajunhuang.com/articles/2020_04_23-go_gdb.md.html</a></p><p>饿了么交易系统 5 年演化史<br><a href="https://www.jianshu.com/p/06e157f4ee37">https://www.jianshu.com/p/06e157f4ee37</a></p><p>TCP 半连接队列和全连接队列满了会发生什么？又该如何应对？<br><a href="https://blog.csdn.net/qq_34827674/article/details/106448326">https://blog.csdn.net/qq_34827674/article/details/106448326</a></p><p>JAVA线上故障排查全套路<br>推荐 非常全面的线上排错指南<br><a href="https://fredal.xin/java-error-check">https://fredal.xin/java-error-check</a></p><p>只用 3 步构建 Go docker 最小镜像<br>里面包含一个完整的Dockfile示例 可以借鉴<br><a href="https://studygolang.com/articles/24875">https://studygolang.com/articles/24875</a></p><p>面试官：换人！他连 TCP 这几个参数都不懂<br>推荐，网络内核参数优化必看 五星<br><a href="https://www.cnblogs.com/xiaolincoding/p/13067971.html">https://www.cnblogs.com/xiaolincoding/p/13067971.html</a></p><p>运维的报表之路，用 node.js 轻松发送 grafana 报表<br><a href="https://mp.weixin.qq.com/s?__biz=MzA4Nzg5Nzc5OA==&amp;mid=2651685074&amp;idx=2&amp;sn=5f913a8609a7f7ea17cbbf28a77cc640&amp;scene=6#wechat_redirect">https://mp.weixin.qq.com/s?__biz=MzA4Nzg5Nzc5OA==&amp;mid=2651685074&amp;idx=2&amp;sn=5f913a8609a7f7ea17cbbf28a77cc640&amp;scene=6#wechat_redirect</a></p><p>脱不花多年的工作心法全公开，想在职场脱颖而出的你赶紧来<br><a href="https://mp.weixin.qq.com/s?__biz=MzAwNjYxNzc0OA==&amp;mid=2649546728&amp;idx=1&amp;sn=b92d93f23cc482bd84ae2942ec4bf903&amp;scene=21#wechat_redirect">https://mp.weixin.qq.com/s?__biz=MzAwNjYxNzc0OA==&amp;mid=2649546728&amp;idx=1&amp;sn=b92d93f23cc482bd84ae2942ec4bf903&amp;scene=21#wechat_redirect</a></p><p>agentzh 的 Nginx 教程（版本 2020.03.19）<br>推荐 五星<br><a href="https://openresty.org/download/agentzh-nginx-tutorials-zhcn.html">https://openresty.org/download/agentzh-nginx-tutorials-zhcn.html</a></p><p>Go 每日一库之 cron<br><a href="https://segmentfault.com/a/1190000023029219">https://segmentfault.com/a/1190000023029219</a></p><p>腾讯 TKE 厉害了！用 eBPF绕过 conntrack 优化K8s Service，性能提升40%<br><a href="https://www.kubernetes.org.cn/7944.html">https://www.kubernetes.org.cn/7944.html</a></p><p>肝了三天，万字长文教你玩转 tcpdump，从此抓包不用愁<br><a href="https://blog.csdn.net/csdnnews/article/details/107096589">https://blog.csdn.net/csdnnews/article/details/107096589</a></p><p>nginx-lua-module中文翻译文档<br><a href="https://github.com/iresty/nginx-lua-module-zh-wiki">https://github.com/iresty/nginx-lua-module-zh-wiki</a></p><p>Go语言中文文档<br>内容比较全面 类似电子书的风格<br>推荐 4星<br><a href="http://topgoer.com/">http://topgoer.com/</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 精彩文章 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go优雅重启机制</title>
      <link href="2020/12/13/e022a93c9e57adc2eaac5f824376bf55/"/>
      <url>2020/12/13/e022a93c9e57adc2eaac5f824376bf55/</url>
      
        <content type="html"><![CDATA[<p>不停机的情况下，进行优雅重启的话，要么替换二进制文件，要么修改配置</p><p><strong>2种的方案</strong></p><h1><span id="方案一">方案一：</span></h1><p>在套接字上设置 SO_REUSEPORT 从而让多个进程能被绑定到同一个端口上，此时有多个接受队列向多个进程提供数据，现状：由于有多个接受队列，偶有丢弃挂起的TCP连接；Go对设置该属性支持不够好，需要借助第三方包，如 <a href="https://github.com/libp2p/go-reuseport">https://github.com/libp2p/go-reuseport</a><br>下面为示例代码</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">"fmt"</span><br><span class="line">"net"</span><br><span class="line">"net/http"</span><br><span class="line">"os"</span><br><span class="line">"os/signal"</span><br><span class="line">"strconv"</span><br><span class="line">"syscall"</span><br><span class="line">"time"</span><br><span class="line"></span><br><span class="line">"github.com/libp2p/go-reuseport"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">const (</span><br><span class="line">hotRestartFlag = "HOT_RESTART_FLAG"</span><br><span class="line"></span><br><span class="line">network = "tcp"</span><br><span class="line">address = ":8888"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func getListener(network, address string) (net.Listener, error) {</span><br><span class="line"></span><br><span class="line">flag, _ := os.LookupEnv(hotRestartFlag)</span><br><span class="line">hotRestart, _ := strconv.ParseBool(flag)</span><br><span class="line"></span><br><span class="line">if !hotRestart {</span><br><span class="line">fmt.Println("server started")</span><br><span class="line">os.Setenv(hotRestartFlag, "1")</span><br><span class="line"></span><br><span class="line">return reuseport.Listen(network, address)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// Q&amp;A: https://github.com/libp2p/go-reuseport/issues/80</span><br><span class="line">//</span><br><span class="line">// on darwin or iOS, reuseport again doesn't guarantee that the two sockets share the same queue,</span><br><span class="line">// so no balancing work.</span><br><span class="line">//</span><br><span class="line">// while, on linux, it works.</span><br><span class="line">//</span><br><span class="line">// on darwin, we must use the file descriptor to rebuild the listener.</span><br><span class="line">// the kernel guarantees that the files passed by &amp;ProcAttr{....,listenerFD} are shared, we can use the listenerFD</span><br><span class="line">// to rebuild the listener.</span><br><span class="line">//</span><br><span class="line">// so, how to get the listenerFD? Is it exactly 3? Yes!</span><br><span class="line">// When ForkExec runs, it first fork the process in which only the files in &amp;ProcAttr{...} are shared!</span><br><span class="line">// 0:stdin, 1:stdout, 2:stderr, listenerFD maybe 3 or 10 or other integer, but PID are allocated from the unused</span><br><span class="line">// minimum pid space, so the listener must be 3!</span><br><span class="line">fmt.Println("hot restart: server started")</span><br><span class="line">os.Setenv(hotRestartFlag, "")</span><br><span class="line"></span><br><span class="line">// MUST: use fd=3 to rebuild the listener</span><br><span class="line">nf := os.NewFile(3, "")</span><br><span class="line">ln, err := net.FileListener(nf)</span><br><span class="line"></span><br><span class="line">return ln, err</span><br><span class="line">}</span><br><span class="line">func startHttpServer(listener net.Listener) error {</span><br><span class="line"></span><br><span class="line">http.HandleFunc("/hello", func(w http.ResponseWriter, req *http.Request) {</span><br><span class="line">fmt.Fprintf(w, "Hello from %d\n", os.Getpid())</span><br><span class="line">})</span><br><span class="line"></span><br><span class="line">return http.Serve(listener, nil)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func forkWithFile(listener net.Listener) {</span><br><span class="line"></span><br><span class="line">exec, err := os.Executable()</span><br><span class="line">if err != nil {</span><br><span class="line">panic(err)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">wd, err := os.Getwd()</span><br><span class="line">if err != nil {</span><br><span class="line">panic(err)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">var listenerFile *os.File</span><br><span class="line">if l, ok := listener.(*net.TCPListener); ok &amp;&amp; l != nil {</span><br><span class="line">f, err := l.File()</span><br><span class="line">if err != nil {</span><br><span class="line">panic(err)</span><br><span class="line">}</span><br><span class="line">listenerFile = f</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// syscall.ForkExec is not just fork(), it includes exec(), so we cannot use `if pid == 0`  to judge</span><br><span class="line">// whether current process is parental process or not, use environment instead.</span><br><span class="line">os.Setenv(hotRestartFlag, "1")</span><br><span class="line"></span><br><span class="line">pid, err := syscall.ForkExec(exec, nil, &amp;syscall.ProcAttr{</span><br><span class="line">Dir:   wd,</span><br><span class="line">Env:   os.Environ(),</span><br><span class="line">Files: []uintptr{os.Stdin.Fd(), os.Stdout.Fd(), os.Stderr.Fd(), listenerFile.Fd()},</span><br><span class="line">})</span><br><span class="line">if err != nil {</span><br><span class="line">fmt.Println("fork error: ", err)</span><br><span class="line">os.Exit(1)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">fmt.Printf("fork succ, pid: %d\n", pid)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func handleSignal(signal os.Signal, listener net.Listener) {</span><br><span class="line">switch signal {</span><br><span class="line">case syscall.SIGUSR1, syscall.SIGUSR2:</span><br><span class="line">forkWithFile(listener)</span><br><span class="line">case syscall.SIGTERM, syscall.SIGQUIT:</span><br><span class="line">os.Exit(0)</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">ch := make(chan os.Signal, 16)</span><br><span class="line">signal.Notify(ch, syscall.SIGUSR1, syscall.SIGUSR2, syscall.SIGTERM, syscall.SIGTERM, syscall.SIGQUIT)</span><br><span class="line"></span><br><span class="line">ln, err := getListener(network, address)</span><br><span class="line">if err != nil {</span><br><span class="line">panic(err)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">go func() {</span><br><span class="line">err := startHttpServer(ln)</span><br><span class="line">if err != nil {</span><br><span class="line">panic(err)</span><br><span class="line">}</span><br><span class="line">}()</span><br><span class="line"></span><br><span class="line">for {</span><br><span class="line">select {</span><br><span class="line">case s := &lt;-ch:</span><br><span class="line">fmt.Printf("Recv signal: %v\n", s.String())</span><br><span class="line">handleSignal(s, ln)</span><br><span class="line">default:</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>测试：<br>用go-wkr进行测试，执行命令：go-wrk -c 1 -d 120  <a href="http://127.0.0.1:8888/hello">http://127.0.0.1:8888/hello</a><br>同时执行发送信号命令：gops | grep main |  awk ‘{print $1}’ | xargs kill -SIGUSR2<br>最后的执行结果：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> ✘ yexm@MacBook-Pro-3  ~  go-wrk -c 1 -d 120  http://127.0.0.1:8888/hello</span><br><span class="line">Running 120s test @ http://127.0.0.1:8888/hello</span><br><span class="line">  1 goroutine(s) running concurrently</span><br><span class="line">1071552 requests in 1m55.938805835s, 118.54MB read</span><br><span class="line">Requests/sec:9242.39</span><br><span class="line">Transfer/sec:1.02MB</span><br><span class="line">Avg Req Time:108.197µs</span><br><span class="line">Fastest Request:44.737µs</span><br><span class="line">Slowest Request:49.936516ms</span><br><span class="line">Number of Errors:0</span><br></pre></td></tr></tbody></table></figure><p>可以看到所有的请求都正常响应，不存在有报错或者超时的。</p><h1><span id="方案二">方案二：</span></h1><pre><code>复制套接字，并将其以文件的形式传送给一个子进程，然后在新的进程中重新创建这个套接字，此时有一个接受队列向多个进程提供数据。os/exec实际不赞同这种用法，出于安全考虑，只传递stdin、stdout、stderr给子进程但os包确实提供较低级原语，用于将文件传递给子进程。使用SIGUSR2信号，当进程接收到该信号后，复制监听套接字，然后创建一个新的进程，同时将监听套接字以文件形式和这个套接字的元数据以环境变量形式传入子进程，子进程开始运行后，会依据传进来的文件和元数据重建套按字，并开始处理流量当一个套接字被复制时，入栈流量会在两个套接字之间以轮询方式进行负载。即在替换的过程中，两个进程都会接受新的连接父进程接受到SIGQUIT信号后，开始关闭进程，停止接受新的连接，待所有现有连接断开或超时，然后会关闭监听套接字并退出</code></pre><p>下面为示例代码(对原文代码进行了注解和修整)</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"> </span><br><span class="line">import (</span><br><span class="line">"context"</span><br><span class="line">"encoding/json"</span><br><span class="line">"flag"</span><br><span class="line">"fmt"</span><br><span class="line">"net"</span><br><span class="line">"net/http"</span><br><span class="line">"os"</span><br><span class="line">"os/signal"</span><br><span class="line">"path/filepath"</span><br><span class="line">"syscall"</span><br><span class="line">"time"</span><br><span class="line">)</span><br><span class="line"> </span><br><span class="line">type listener struct {</span><br><span class="line">Addr     string `json:"addr"`     // 监听地址 带端口</span><br><span class="line">FD       int    `json:"fd"`       // 文件描述符</span><br><span class="line">Filename string `json:"filename"` // 文件名</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line">// 从进程运行的环境变量中导入listener 变量名称LISTENER</span><br><span class="line">func importListener(addr string) (net.Listener, error) {</span><br><span class="line">// 从环境变量中获取被编码的listener元数据 json格式</span><br><span class="line">listenerEnv := os.Getenv("LISTENER")</span><br><span class="line">if listenerEnv == "" {</span><br><span class="line">return nil, fmt.Errorf("找不到环境变量LISTENER")</span><br><span class="line">}</span><br><span class="line">// fmt.Println(string(listenerEnv)) // 打印变量</span><br><span class="line"> </span><br><span class="line">// 解码listener元数据</span><br><span class="line">var l listener</span><br><span class="line">err := json.Unmarshal([]byte(listenerEnv), &amp;l)</span><br><span class="line">if err != nil {</span><br><span class="line">return nil, err</span><br><span class="line">}</span><br><span class="line">if l.Addr != addr {</span><br><span class="line">return nil, fmt.Errorf("找不到 %v 的listener", addr)</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line">// 文件已经被传入到这个进程中</span><br><span class="line">// 从元数据中抽离文件描述符和名字</span><br><span class="line">// 为listener 重建/发现 *os.file</span><br><span class="line">listenerFile := os.NewFile(uintptr(l.FD), l.Filename)</span><br><span class="line">if listenerFile == nil {</span><br><span class="line">return nil, fmt.Errorf("创建listener文件失败")</span><br><span class="line">}</span><br><span class="line">defer listenerFile.Close()</span><br><span class="line"> </span><br><span class="line">// 创建net.Listener</span><br><span class="line">ln, err := net.FileListener(listenerFile)</span><br><span class="line">if err != nil {</span><br><span class="line">return nil, err</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line">return ln, nil</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line">// 创建listener</span><br><span class="line">func createListener(addr string) (net.Listener, error) {</span><br><span class="line">ln, err := net.Listen("tcp", addr)</span><br><span class="line">if err != nil {</span><br><span class="line">return nil, err</span><br><span class="line">}</span><br><span class="line">return ln, nil</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line">// 导入或创建listener</span><br><span class="line">func createOrImportListener(addr string) (net.Listener, error) {</span><br><span class="line">// 尝试导入一个listener 若导入成功 则使用</span><br><span class="line">ln, err := importListener(addr)</span><br><span class="line">if err == nil {</span><br><span class="line">fmt.Printf("导入listener 描述符 %v\n", addr)</span><br><span class="line">return ln, nil</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line">// 没有listener被导入 则创建一个</span><br><span class="line">ln, err = createListener(addr)</span><br><span class="line">if err != nil {</span><br><span class="line">return nil, err</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line">fmt.Printf("创建listener 描述符 %v\n", addr)</span><br><span class="line">return ln, nil</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line">// 响应内容</span><br><span class="line">func handler(w http.ResponseWriter, r *http.Request) {</span><br><span class="line">fmt.Fprintf(w, "Hello from %v\n", os.Getpid())</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line">// Http Server</span><br><span class="line">func startServer(addr string, ln net.Listener) *http.Server {</span><br><span class="line">http.HandleFunc("/hello", handler)</span><br><span class="line">httpServer := &amp;http.Server{</span><br><span class="line">Addr: addr,</span><br><span class="line">}</span><br><span class="line">go httpServer.Serve(ln)</span><br><span class="line">return httpServer</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line">func getListenerFile(ln net.Listener) (*os.File, error) {</span><br><span class="line">switch t := ln.(type) {</span><br><span class="line">case *net.TCPListener:</span><br><span class="line">return t.File()</span><br><span class="line">case *net.UnixListener:</span><br><span class="line">return t.File()</span><br><span class="line">}</span><br><span class="line">return nil, fmt.Errorf("不支持的listener %T", ln)</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line">// fork子进程</span><br><span class="line">func forkChild(addr string, ln net.Listener) (*os.Process, error) {</span><br><span class="line">// 从listener中获取文件描述符 环境变量编码再传递给该子进程作为元数据</span><br><span class="line">lnFile, err := getListenerFile(ln)</span><br><span class="line">if err != nil {</span><br><span class="line">return nil, err</span><br><span class="line">}</span><br><span class="line">defer lnFile.Close()</span><br><span class="line">l := listener{</span><br><span class="line">Addr:     addr,</span><br><span class="line">FD:       3,</span><br><span class="line">Filename: lnFile.Name(),</span><br><span class="line">}</span><br><span class="line">listenerEnv, err := json.Marshal(l)</span><br><span class="line">if err != nil {</span><br><span class="line">return nil, err</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line">// 将stdin,stdout,stderr,listener传入子进程</span><br><span class="line">// 以上四个文件描述符分别为0,1,2,3</span><br><span class="line">files := []*os.File{</span><br><span class="line">os.Stdin,</span><br><span class="line">os.Stdout,</span><br><span class="line">os.Stderr,</span><br><span class="line">lnFile,</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line">// 获取当前环境变量 并传入子进程</span><br><span class="line">environment := append(os.Environ(), "LISTENER="+string(listenerEnv))</span><br><span class="line"> </span><br><span class="line">// 获取当前进程名和工作目录</span><br><span class="line">execName, err := os.Executable()</span><br><span class="line">if err != nil {</span><br><span class="line">return nil, err</span><br><span class="line">}</span><br><span class="line">execDir := filepath.Dir(execName)</span><br><span class="line"> </span><br><span class="line">// 创建子进程</span><br><span class="line">p, err := os.StartProcess(execName, []string{execName}, &amp;os.ProcAttr{</span><br><span class="line">Dir:   execDir,</span><br><span class="line">Env:   environment,</span><br><span class="line">Files: files,</span><br><span class="line">Sys:   &amp;syscall.SysProcAttr{},</span><br><span class="line">})</span><br><span class="line">if err != nil {</span><br><span class="line">return nil, err</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line">return p, nil</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line">// 信号处理</span><br><span class="line">func waitForSignals(addr string, ln net.Listener, server *http.Server) error {</span><br><span class="line">signalCh := make(chan os.Signal, 1024)</span><br><span class="line">// 没有syscall.SIGUSR2 所以使用 syscall.Signal(12)</span><br><span class="line">// 注册要处理的信号</span><br><span class="line">signal.Notify(signalCh, syscall.SIGHUP, syscall.Signal(12), syscall.SIGINT, syscall.SIGQUIT)</span><br><span class="line">for {</span><br><span class="line">select {</span><br><span class="line">case s := &lt;-signalCh:</span><br><span class="line">fmt.Printf("接收到信号 %v\n", s)</span><br><span class="line">switch s {</span><br><span class="line">case syscall.SIGHUP:</span><br><span class="line">// Fork 一个子进程</span><br><span class="line">p, err := forkChild(addr, ln)</span><br><span class="line">if err != nil {</span><br><span class="line">fmt.Printf("不能fork子进程 %v\n", err)</span><br><span class="line">continue</span><br><span class="line">}</span><br><span class="line">fmt.Printf("Forked 子进程 %v\n", p.Pid)</span><br><span class="line"> </span><br><span class="line">// 创建一个5s过期的Context 用该超时定时器关闭</span><br><span class="line">ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)</span><br><span class="line">defer cancel()</span><br><span class="line"> </span><br><span class="line">// 返回关闭过程中发生的任何错误</span><br><span class="line">return server.Shutdown(ctx)</span><br><span class="line">case syscall.Signal(12):</span><br><span class="line">// Fork一个子进程</span><br><span class="line">p, err := forkChild(addr, ln)</span><br><span class="line">if err != nil {</span><br><span class="line">fmt.Printf("不能fork子进程 %v\n", err)</span><br><span class="line">continue</span><br><span class="line">}</span><br><span class="line">// 输出被fork的子进程的PID 并等待更多的信号</span><br><span class="line">fmt.Printf("Forked子进程 %v\n", p.Pid)</span><br><span class="line">case syscall.SIGQUIT:</span><br><span class="line">fallthrough</span><br><span class="line">case syscall.SIGINT:</span><br><span class="line">// 创建一个5s的Context 使用该超时定时器半闭</span><br><span class="line">ctx, chancel := context.WithTimeout(context.Background(), 5*time.Second)</span><br><span class="line">defer chancel()</span><br><span class="line"> </span><br><span class="line">// 返回关闭过程中发生的任何错误</span><br><span class="line">return server.Shutdown(ctx)</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line">func main() {</span><br><span class="line">// 解析命令行参数</span><br><span class="line">var addr string</span><br><span class="line">flag.StringVar(&amp;addr, "addr", ":8080", "设置监听端口")</span><br><span class="line">flag.Parse()</span><br><span class="line"> </span><br><span class="line">// 导入/创建一个net.Listener并启动gotoutine在这个net.Listener上运行HTTP Server</span><br><span class="line">ln, err := createOrImportListener(addr)</span><br><span class="line">if err != nil {</span><br><span class="line">fmt.Printf("不能导入或创建listener: %v\n", err)</span><br><span class="line">os.Exit(1)</span><br><span class="line">}</span><br><span class="line">server := startServer(addr, ln)</span><br><span class="line"> </span><br><span class="line">// 信号处理</span><br><span class="line">err = waitForSignals(addr, ln, server)</span><br><span class="line">if err != nil {</span><br><span class="line">fmt.Printf("Exiting... Err %v\n", err)</span><br><span class="line">return</span><br><span class="line">}</span><br><span class="line">fmt.Printf("Exiting.\n")</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>测试方法如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">./gracedown &amp;</span><br><span class="line">curl http://localhost:8080</span><br><span class="line">kill -SIGUSR2 1234</span><br><span class="line">curl http://localhost:8080</span><br><span class="line">curl http://localhost:8080</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>lsof -i :8080 -P<br>在发送完SIGUSR2信号后  可以看到 两个进程监听同一个端口8080</p>]]></content>
      
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> 优雅重启 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kubernetes源码分析（一）</title>
      <link href="2020/12/11/9d3be710c23eab946de6ad2a0c66f9c0/"/>
      <url>2020/12/11/9d3be710c23eab946de6ad2a0c66f9c0/</url>
      
        <content type="html"><![CDATA[<p>模块：xxx</p>]]></content>
      
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> k8s源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工具-gops</title>
      <link href="2020/12/07/2f9ba0e8f3e4f5b8e05af08b6eddf96d/"/>
      <url>2020/12/07/2f9ba0e8f3e4f5b8e05af08b6eddf96d/</url>
      
        <content type="html"><![CDATA[<p>gops是一个命令，用于列出和诊断系统上当前运行的Go进程。 用于优化golang程序已经诊断Go的问题</p><p>github 地址 <a href="https://github.com/google/gops">https://github.com/google/gops</a></p><p><img src="/2020/12/07/2f9ba0e8f3e4f5b8e05af08b6eddf96d/1607332943228.png"></p><p><strong>安装方式</strong><br>go get -u github.com/google/gops</p><p><strong>诊断</strong><br>对于启动诊断代理的进程，gops可以报告其他信息，如当前堆栈跟踪、Go版本、内存统计信息等。 例子如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import (</span><br><span class="line">"log"</span><br><span class="line">"time"</span><br><span class="line"></span><br><span class="line">"github.com/google/gops/agent"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">if err := agent.Listen(agent.Options{}); err != nil {</span><br><span class="line">log.Fatal(err)</span><br><span class="line">}</span><br><span class="line">time.Sleep(time.Hour)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>上面的是简单的demo，可配合http服务使用</p><p><strong>手册</strong><br>在本地和远程模式下都可以使用gops工具。</p><p>本地模式要求您以运行gops二进制文件的相同用户启动目标二进制文件。要在远程模式下使用gops，您需要知道目标的代理地址。 在局部模式下，以过程PID为目标;在远程模式下，目标是主机:端口组合。</p><p><strong>列出本地运行的所有进程</strong><br>打印所有go的进程 ，可以 直接 运行 gops 而不需要其他参数：<br><img src="/2020/12/07/2f9ba0e8f3e4f5b8e05af08b6eddf96d/1607332943228.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于</title>
      <link href="2020/12/06/46b3931b9959c927df4fc65fdee94b07/"/>
      <url>2020/12/06/46b3931b9959c927df4fc65fdee94b07/</url>
      
        <content type="html"><![CDATA[<p>一个普通程序员，喜欢折腾。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>开篇</title>
      <link href="2020/12/06/b63e01abe743dea598e2d57990875665/"/>
      <url>2020/12/06/b63e01abe743dea598e2d57990875665/</url>
      
        <content type="html"><![CDATA[<p>开始写博客，在工作中积累，记录。</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
